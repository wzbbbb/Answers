class Bicycle {

    int cadence = 0;
    int speed = 0;
    int gear = 1;

    void changeCadence(int newValue) {
         cadence = newValue;
    }

    void changeGear(int newValue) {
         gear = newValue;
    }

    void speedUp(int increment) {
         speed = speed + increment;   
    }

    void applyBrakes(int decrement) {
         speed = speed - decrement;
    }

    void printStates() {
         System.out.println("cadence:" +
             cadence + " speed:" + 
             speed + " gear:" + gear);
    }
}
class BicycleDemo {
    public static void main(String[] args) {

        // Create two different 
        // Bicycle objects
        Bicycle bike1 = new Bicycle(); //he object is stored in a region of memory known as the heap.
        Bicycle bike2 = new Bicycle();

        // Invoke methods on 
        // those objects
        bike1.changeCadence(50);
        bike1.speedUp(10);
        bike1.changeGear(2);
        bike1.printStates();

        bike2.changeCadence(50);
        bike2.speedUp(10);
        bike2.changeGear(2);
        bike2.changeCadence(40);
        bike2.speedUp(10);
        bike2.changeGear(3);
        bike2.printStates();
    }
}

The output of this test prints the ending pedal cadence, speed, and gear for the two bicycles:

cadence:50 speed:10 gear:2
cadence:40 speed:20 gear:3
//each class has to be stored in a different file?
// both class and the main function are class, and has to be in different files.
...........Inheritance

The syntax for creating a subclass is simple. At the beginning of your class declaration, use the extends keyword, followed by the name of the class to inherit from:

class MountainBike extends Bicycle {

    // new fields and methods defining 
    // a mountain bike would go here

}

...........Interface
In its most common form, an interface is a group of related methods with empty bodies. A bicycle's behavior, if specified as an interface, might appear as follows:

interface Bicycle {

    //  wheel revolutions per minute
    void changeCadence(int newValue);

    void changeGear(int newValue);

    void speedUp(int increment);

    void applyBrakes(int decrement);
}

To implement this interface, the name of your class would change (to a particular brand of bicycle, for example, such as ACMEBicycle), and you'd use the implements keyword in the class declaration:

class ACMEBicycle implements Bicycle {

    // remainder of this class 
    // implemented as before
}
If your class claims to implement an interface, all methods defined by that interface must appear in its source code before the class will successfully compile.

........... class variabls
Class Variables (Static Fields) A class variable is any field declared with the static modifier; this tells the compiler that there is exactly one copy of this variable in existence, regardless of how many times the class has been instantiated. A field defining the number of gears for a particular kind of bicycle could be marked as static since conceptually the same number of gears will apply to all instances. The code static int numGears = 6; would create such a static field. Additionally, the keyword final could be added to indicate that the number of gears will never change.
......................Array
// declares an array of integers
int[] anArray;
anArray = new int[10];
// initialize first element
anArray[0] = 100;
// initialize second element
anArray[1] = 200;
// and so forth

// this form is discouraged
float anArrayOfFloats[];

int[] anArray = { 
    100, 200, 300,
    400, 500, 600, 
    700, 800, 900, 1000
};
class MultiDimArrayDemo {
    public static void main(String[] args) {
        String[][] names = {
            {"Mr. ", "Mrs. ", "Ms. "},
            {"Smith", "Jones"}
        };
        // Mr. Smith
        System.out.println(names[0][0] + names[1][0]);
        // Ms. Jones
        System.out.println(names[0][2] + names[1][1]);
    }
}

System.out.println(anArray.length);

public static void arraycopy(Object src, int srcPos, 
							Object dest, int destPos, int length)


Some other useful operations provided by methods in the java.util.Arrays
class, are:

Searching an array for a specific value to get the index at which it is placed (the binarySearch() method).

Comparing two arrays to determine if they are equal or not (the equals() method).

Filling an array to place a specific value at each index (the fill() method).

Sorting an array into ascending order. This can be done either sequentially, using the sort() method, or concurrently, using the parallelSort() method introduced in Java SE 8. Parallel sorting of large arrays on multiprocessor systems is faster than sequential array sorting.
......................
The instanceof operator compares an object to a specified type. You can use it to test if an object is an instance of a class, an instance of a subclass, or an instance of a class that implements a particular interface.

.................................
The bitwise & operator performs a bitwise AND operation.

The bitwise ^ operator performs a bitwise exclusive OR operation.

The bitwise | operator performs a bitwise inclusive OR operation.

The following program, BitDemo, uses the bitwise AND operator to print the number "2" to standard output.

class BitDemo {
    public static void main(String[] args) {
        int bitmask = 0x000F;
        int val = 0x2222;
        // prints "2"
        System.out.println(val & bitmask);
    }
}

The increment/decrement operators can be applied before (prefix) or after (postfix) the operand. The code result++; and ++result; will both end in result being incremented by one. The only difference is that the prefix version (++result) evaluates to the incremented value, whereas the postfix version (result++) evaluates to the original value.
class PrePostDemo {
    public static void main(String[] args){
        int i = 3;
        i++;
        // prints 4
        System.out.println(i);
        ++i;			   
        // prints 5
        System.out.println(i);
        // prints 6
        System.out.println(++i); // print out the result of i +1
        // prints 6
        System.out.println(i++); // print i, then i +1
        // prints 7
        System.out.println(i);
    }
}
...................... do-while
The difference between do-while and while is that do-while evaluates its
expression at the bottom of the loop instead of the top. Therefore, the
statements within the do block are always executed at least once, as shown in
the following DoWhileDemo program:


class DoWhileDemo {
    public static void main(String[] args){
        int count = 1;
        do {
            System.out.println("Count is: " + count);
            count++;
        } while (count < 11);
    }
}
......................for loop
class ForDemo {
    public static void main(String[] args){
         for(int i=1; i<11; i++){
              System.out.println("Count is: " + i);
         }
    }
}
// infinite loop
for ( ; ; ) {
    
    // your code goes here
}

//for to loop through the array:
class EnhancedForDemo {
    public static void main(String[] args){
         int[] numbers = 
             {1,2,3,4,5,6,7,8,9,10};
         for (int item : numbers) {
             System.out.println("Count is: " + item);
         }
    }
}
......................break
//The break statement has two forms: labeled and unlabeled. 
An unlabeled break statement terminates the innermost switch, for, while, or
do-while statement, but a labeled break terminates an outer statement. The
following program, BreakWithLabelDemo, is similar to the previous program, but
uses nested for loops to search for a value in a two-dimensional array. When
the value is found, a labeled break terminates the outer for loop (labeled
"search"):


class BreakWithLabelDemo {
    public static void main(String[] args) {

        int[][] arrayOfInts = { 
            { 32, 87, 3, 589 },
            { 12, 1076, 2000, 8 },
            { 622, 127, 77, 955 }
        };
        int searchfor = 12;

        int i;
        int j = 0;
        boolean foundIt = false;

    search:
        for (i = 0; i < arrayOfInts.length; i++) {
            for (j = 0; j < arrayOfInts[i].length;
                 j++) {
                if (arrayOfInts[i][j] == searchfor) {
                    foundIt = true;
                    break search;
                }
            }
        }

        if (foundIt) {
            System.out.println("Found " + searchfor + " at " + i + ", " + j);
        } else {
            System.out.println(searchfor + " not in the array");
        }
    }
}
This is the output of the program.

Found 12 at 1, 0

......................continue
//The continue statement skips the current iteration of a for, while , or do-while loop.
//A labeled continue statement skips the current iteration of an outer loop marked with the given label. 

class ContinueWithLabelDemo {
    public static void main(String[] args) {

        String searchMe = "Look for a substring in me";
        String substring = "sub";
        boolean foundIt = false;

        int max = searchMe.length() - 
                  substring.length();

    test:
        for (int i = 0; i <= max; i++) {
            int n = substring.length();
            int j = i;
            int k = 0;
            while (n-- != 0) {
                if (searchMe.charAt(j++) != substring.charAt(k++)) {
                    continue test;
                }
            }
            foundIt = true;
                break test;
        }
        System.out.println(foundIt ? "Found it" : "Didn't find it");
    }
}
.................................class with constructor
public class Bicycle { //class declaration
    // the Bicycle class has
    // three fields
    public int cadence;
    public int gear;
    public int speed;
        
    // the Bicycle class has
    // one constructor, the same name as the class and no retrun type
    public Bicycle(int startCadence, int startSpeed, int startGear) {
        gear = startGear;
        cadence = startCadence;
        speed = startSpeed;
    }
        
    // the Bicycle class has
    // four methods
    public void setCadence(int newValue) {
        cadence = newValue;
    }
        
    public void setGear(int newValue) {
        gear = newValue;
    }
        
    public void applyBrake(int decrement) {
        speed -= decrement;
    }
        
    public void speedUp(int increment) {
        speed += increment;
    }
        
}
//A class declaration for a MountainBike class that is a subclass of Bicycle might look like this:


public class MountainBike extends Bicycle {
        
    // the MountainBike subclass has
    // one field
    public int seatHeight;

    // the MountainBike subclass has
    // one constructor
    public MountainBike(int startHeight, int startCadence,
                        int startSpeed, int startGear) {
        super(startCadence, startSpeed, startGear);
        seatHeight = startHeight;
    }   
        
    // the MountainBike subclass has
    // one method
    public void setHeight(int newValue) {
        seatHeight = newValue;
    }   

}
......................
class MyClass extends MySuperClass implements YourInterface {
	//The modifiers public and private, which determine what other classes can access MyClass        
    // field, constructor, and
    // method declarations
}
//means that MyClass is a subclass of MySuperClass and that it implements the YourInterface interface.

"Member variables" in a class.these are called fields.
"Variables" in a method or block of code.these are called local variables.
"Variables" in method declarations.these are called parameters.

public modifier: the field is accessible from all classes.

private modifier: the field is accessible only within its own class.

protected modifier : specifies that the member can only be accessed within its own package (as with package-private) and, in addition, by a subclass of its class in another package.  

A class may be declared with the modifier public, in which case that class is visible to all classes everywhere. If a class has no modifier (the default, also known as package-private), it is visible only within its own package 

A class that is declared public must be stored in a file with the same name.  For example, a public Imageclass must be stored in Image.java. A source file can declare one publictop-level class only. (It.s also possible to declare nested classes that are public,

			Access Levels
Modifier	Class	Package	Subclass	World
public		Y		Y		Y			Y
protected	Y		Y		Y			N
no modifier	Y		Y		N			N
private		Y		N		N			N
.................................
More generally, method declarations have six components, in order:

Modifiers.such as public, private, and others you will learn about later.

The return type.the data type of the value returned by the method, or void if the method does not return a value.

The method name.the rules for field names apply to method names as well, but the convention is a little different.

The parameter list in parenthesis.a comma-delimited list of input parameters, preceded by their data types, enclosed by parentheses, (). If there are no parameters, you must use empty parentheses.

An exception list.to be discussed later.

The method body, enclosed between braces.the method's code, including the declaration of local variables, goes here.
.................................  Overloading Methods

The Java programming language supports overloading methods, and Java can distinguish between methods with different method signatures. This means that methods within a class can have the same name if they have different parameter lists
A method.s name and the number, types, and order of its parameters are known as its signature.
.................................  Arbitrary Number of Arguments

//To use varargs, you follow the type of the last parameter by an ellipsis (three dots, ...), then a space, and the parameter name. The method can then be called with any number of that parameter, including none.  
public Polygon polygonFrom(Point... corners) {
    int numberOfSides = corners.length;
    double squareOfSide1, lengthOfSide1;
    squareOfSide1 = (corners[1].x - corners[0].x)
                     * (corners[1].x - corners[0].x) 
                     + (corners[1].y - corners[0].y)
                     * (corners[1].y - corners[0].y);
    lengthOfSide1 = Math.sqrt(squareOfSide1);

    // more method body code follows that creates and returns a 
    // polygon connecting the Points
}

double sum(double. . . values)
{
	int total = 0;
	for (int i = 0; i < values.length; i++)
		total += values[i];
	return total;
}

//You will most commonly see varargs with the printing methods; for example, this printf method:

public PrintStream printf(String format, Object... args)

//allows you to print an arbitrary number of objects. It can be called like this:

System.out.printf("%s: %d, %s%n", name, idnum, address);

//or like this

System.out.printf("%s: %d, %s, %s, %s%n", name, idnum, address, phone, email);

//or with yet a different number of arguments.
...................... Using the this Keyword, like self in python
A constructor calls another constructor by using keyword thisand a round bracket-delimited and comma-separated list of arguments. 
The this()constructor call (when present) must be the first code that is executed within the constructor -- this rule prevents you from specifying multiple this()constructor calls in the same constructor. Finally, you cannot specify this()in a method -- constructors can be called only by other constructors and during object creation. 

public class Rectangle {
    private int x, y;
    private int width, height;
        
    public Rectangle() {
        this(0, 0, 0, 0);
    }
    public Rectangle(int width, int height) {
        this(0, 0, width, height);
    }
    public Rectangle(int x, int y, int width, int height) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
    }
    ...
}
...................... static variable and method
Fields that have the static modifier in their declaration are called static fields or class variables. They are associated with the class, rather than with any object. Every instance of the class shares a class variable, which is in one fixed location in memory. So, don't need to create any object to use static method, like main()

public class Bicycle {
    private int cadence;
    private int gear;
    private int speed;
    // add an instance variable for the object ID
    private int id;
    // add a class variable for the
    // number of Bicycle objects instantiated
    private static int numberOfBicycles = 0;
    public Bicycle(int startCadence, int startSpeed, int startGear){
        gear = startGear;
        cadence = startCadence;
        speed = startSpeed;
        // increment number of Bicycles
        // and assign ID number
        id = ++numberOfBicycles;
    }
	public static int getNumberOfBicycles() {
		return numberOfBicycles;
	}
}
//Class variables are referenced by the class name itself, as in:
Bicycle.numberOfBicycles
ClassName.methodName(args)
................................. constant
The static modifier, in combination with the final modifier, is also used to define constants. The final modifier indicates that the value of this field cannot change.  
static final double PI = 3.141592653589793;
......................static initialization block
Instance variables can be initialized in constructors, where error handling or other logic can be used. To provide the same capability for class variables, the Java programming language includes static initialization blocks.  
A static initialization block is a normal block of code enclosed in braces, { }, and preceded by the static keyword. Here is an example:

static {
    // whatever code is needed for initialization goes here
}
......................Initializing Instance Members
Normally, you would put code to initialize an instance variable in a constructor. There are two alternatives to using a constructor to initialize instance variables: initializer blocks and final methods.
{
    // whatever code is needed for initialization goes here
}

A final method cannot be overridden in a subclass. 
class Whatever {
    private varType myVar = initializeInstanceVariable();
    protected final varType initializeInstanceVariable() {
        // initialization code goes here
    }
}
This is especially useful if subclasses might want to reuse the initialization method. The method is final because calling non-final methods during instance initialization can cause problems.
................................. assert
//You can use the assert statement to check your assignments. You write:

assert (boolean expression to test); 
//If the boolean expression is false, you will get an error message. For example,

assert toString(ACE) == "Ace";
//should return true, so there will be no error message.

//If you use the assert statement, you must run your program with the ea flag:

java -ea YourProgram.class // or
java -enableassertions ...
//disable/enable assertion for some class or package
java -ea:logging TestLogger

// -enableassertions == -da
java -ea -da:loneclass mainclass

//To enable system assertions, specify either 
//-enablesystemassertionsor -esa, for example, 
java -esa -ea:logging TestLogger 
//Specify either -disablesystemassertions or -dsa to disable system assertions.
.................................
1. Question: What's wrong with the following program?

public class SomethingIsWrong {
    public static void main(String[] args) {
        Rectangle myRect;
        myRect.width = 40;
        myRect.height = 50;
        System.out.println("myRect's area is " + myRect.area());
    }
}
Answer: The code never creates a Rectangle object. With this simple program,
the compiler generates an error. However, in a more realistic situation,
myRect might be initialized to null in one place, say in a constructor, and
used later. In that case, the program will compile just fine, but will
generate a NullPointerException at runtime.


2. Question: The following code creates one array and one string object. How
many references to those objects exist after the code executes? Is either
object eligible for garbage collection?

...
String[] students = new String[10];
String studentName = "Peter Smith";
students[0] = studentName;
studentName = null;
...
Answer: There is one reference to the students array and that array has one
reference to the string Peter Smith. Neither object is eligible for garbage
collection.


Qu3. estion: How does a program destroy an object that it creates?

Answer: A program does not explicitly destroy objects. A program can set all
references to an object to null so that it becomes eligible for garbage
collection. But the program does not actually destroy objects.


class NumberHolderDisplay {
static void main(String [] args) {
	NumberHolder v1= new NumberHolder();
	v1.anInt = 10;
	v1.aFloat = 1.232;
	System.out.println(v1.anInt);
	System.out.println(v1.aFloat);

}
................................. static nested class
Static nested classes are accessed using the enclosing class name:

OuterClass.StaticNestedClass

For example, to create an object for the static nested class, use this syntax:

OuterClass.StaticNestedClass nestedObject = new
OuterClass.StaticNestedClass();

......................Inner Classes

As with instance methods and variables, an inner class is associated with an
instance of its enclosing class and has direct access to that object's methods
and fields. Also, because an inner class is associated with an instance, it
cannot define any static members itself.

Objects that are instances of an inner class exist within an instance of the
outer class. Consider the following classes:

class OuterClass {
    ...
    class InnerClass {
        ...
    }
}
############################################
Android device emulator shortcuts
Shortcut	Description
Alt+Enter	Maximizes the emulator.
Ctrl+F11	Changes the orientation of the emulator from landscape to portrait
and vice versa.
F8			Turns the network on and off.

In Eclipse, press Ctrl + Shift + O to import missing classes

An Intent can carry a collection of various data types as key-value pairs
called extras. The putExtra() method takes the key name in the first parameter
and the value in the second parameter.
.................................

<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.test1"
    android:versionCode="1"
    android:versionName="1.0" >

    <uses-sdk
        android:minSdkVersion="8"
        android:targetSdkVersion="18" />

    <application
        android:allowBackup="true"
        android:icon="@drawable/ic_launcher"
        android:label="@string/app_name"
        android:theme="@style/AppTheme" >
        <activity
            android:name="com.example.test1.MainActivity"
            android:label="@string/app_name" >
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />

                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
        <activity
            android:name="com.example.test1.DisplayMessageActivity"
            android:label="@string/title_activity_display_message"
            android:parentActivityName="com.example.test1.MainActivity" >
            <meta-data
                android:name="android.support.PARENT_ACTIVITY"
                android:value="com.example.test1.MainActivity" />
        </activity>
    </application>

</manifest>

################################# java
System.errprovides the same families of println()and print()methods as System.out.) However, you should only switch from System.outto System.errwhen you need to output an error message so that the error messages are displayed on the screen, even when standard output is redirected to a file.
...................... read from input
java read from input as int, then conver to char ... 
	int ch;
	while ((ch = System.in.read())!= -1) {
		System.out.print((char) ch);
	}
.................................
Javadoc Comments
Everything from /**through */is ignored by the compiler.
/**
* Application entry point
*
* @param args array of command-line arguments passed to this method
*/
public static void main(String[] args)
{
// TODO code application logic here
}

 @author identifies the source code.s author.
 @deprecated identifies a source code entity (such as a method) that should no longer be used.
 @param identifies one of a method.s parameters.
 @see provides a see-also reference.
 @since identifies the software release where the entity first originated.
 @return identifies the kind of value that the method returns.
 @throws documents an exception thrown from a method. I discuss exceptions in Chapter 5.

You can extract these documentation comments into a set of HTML files by using the JDK.s javadoc tool, as follows:

javadoc DumpArgs.java

It will generate a set of html files.
.................................
			v	2
			00000010
sign bit
			v	-2
			11111110
.................................
>>> 	Unsigned right shift 
^		Bitwise exclusive OR , XOR
|		Bitwise inclusive OR 

cast float to short
short s = (short) 1.65 + 3

Java supports the following primitive-type conversions via cast operators:
Byte integer to character 
Short integer to byte integer or character 
Character to byte integer or short integer 
Integer to byte integer, short integer, or character 
Long integer to byte integer, short integer, character, or integer 
Floating-point to byte integer, short integer, character, integer, or long integer 
Double precision floating-point to byte integer, short integer, character, integer,  long integer, or floating-point

......................conditional operator
boolean b = true;
int i = b ? 1 : 0; // 1 assigns to i
.................................  Shift Operators
The shift operators consist of left shift (<<), signed right shift (>>), and unsigned right shift (>>>). Left shift shifts the binary representation of its left operand leftward by the number of positions specified by its right operand. Each shift is equivalent to multiplying by 2. For example, 2 << 3shifts 2.s binary representation left by 3 positions; the result is equivalent to multiplying 2 by 8.

Each of signed and unsigned right shift shifts the binary representation of its left operand rightward by the number of positions specified by its right operand. Each shift is equivalent to dividing by 2. 

The difference between signed and unsigned right shift is what happens to the sign bit during the shift.  Signed right shift includes the sign bit in the shift, whereas unsigned right shift ignores the sign bit. As a result, signed right shift preserves negative numbers, but unsigned right shift doesn.t. For example, .4 >> 1(the equivalent of .4 / 2) evaluates to .2, whereas .4 >>> 1evaluates to 2147483646.

Tip The shift operators are faster than multiplying or dividing by powers of 2.

float[][] matrix = { { 1.0F, 2.0F, 3.0F }, { 4.0F, 5.0F, 6.0F }};
for (int row = 0; row < matrix.length; row++)
{
	for (int col = 0; col < matrix[row].length; col++){ //collumn lenth
		System.out.print(matrix[row][col] + " ");} 
	System.out.print("\n");
}
.................................  Looping Over the Empty Statement
for (String line; (line = readLine()) != null; System.out.println(line));
................................. method chains
public class SavingsAccount {
	int balance;
	SavingsAccount deposit(int amount) { // class name as return type
		balance += amount;
		return this; }// retrun this
	SavingsAccount printBalance() { // class name as return type
		System.out.println(balance);
		return this; } // retrun this
	public static void main(String[] args) {
		new SavingsAccount().deposit(1000).printBalance(); }
}

you must specify the class.s name as the instance method.s return type.  Each of deposit()and printBalance()must specify SavingsAccountas the return type. Also, you must specify return this;(return current object.s reference) as the last statement.
...................... recursion
int factorial(int n)
{
	if (n == 1)
		return 1; // base problem
	else
		return n * factorial(n - 1);
}
Recursion consumes stack space, so make sure that your recursion eventually ends in a base problem; otherwise, you will run out of stack space and your application will be forced to terminate.
.................................  Class Initializers
class JDBCFilterDriver implements Driver
{
	static private Driver d;
	static
	{
	// Attempt to load JDBC-ODBC Bridge Driver and register that
	// driver.
	try
	{
		Class c = Class.forName("sun.jdbc.odbc.JdbcOdbcDriver");
		d = (Driver) c.newInstance();
		DriverManager.registerDriver(new JDBCFilterDriver());
	}
	catch (Exception e)
	{
		System.out.println(e);
	}
	}
	//. . .
}

class C
{
	static
	{
		System.out.println("class initializer 1");
	}
	static int counter = 1;
	static
	{
		System.out.println("class initializer 2");
		System.out.println("counter = " + counter);
	}
}
When the Java compiler compiles into a classfile a class that declares at least one class initializer or class field initializer, it creates a special void <clinit>()class method that stores the bytecode equivalent of all class initializers and class field initializers in the order they occur (from top to bottom). Only one <clinit>()

Note  <clinit>is not a valid Java method name but is a valid name from the runtime perspective.  The angle brackets were chosen as part of the name to prevent a name conflict with any clinit() methods that you might declare in the class.
......................Instance Initializers
class Graphics
{
	double[] sines;
	double[] cosines;
	{
		sines = new double[360];
		cosines = new double[sines.length];
		for (int degree = 0; degree < sines.length; degree++)
		{
			sines[degree] = Math.sin(Math.toRadians(degree));
			cosines[degree] = Math.cos(Math.toRadians(degree));
		}
	}
}
class C
{
	{
		System.out.println("instance initializer 1");
	}
	int counter = 1;
	{
		System.out.println("instance initializer 2");
		System.out.println("counter = " + counter);
	}
}
When the Java compiler compiles a class into a classfile, it creates a special void <init>()method representing the default noargument constructor when no constructor is explicitly declared; otherwise, it creates an <init>()method for each encountered constructor. Furthermore, it stores in each <init>()method the bytecode equivalent of all instance initializers and instance field initializers in the order they occur (from top to bottom) and before the constructor code. Could be mulitple <init>()

Note  <init>is not a valid Java method name but is a valid name from the runtime perspective. The angle brackets were chosen as part of the name to prevent a name conflict with any init()methods that you might declare in the class.

...........Initialiation order
Class fields initialize to default or explicit values just after a class is loaded. Immediately after a class loads, all class fields are zeroed to default values.  Code within the <clinit>()method performs explicit initialization.

All class initialization occurs prior to the   <clinit>()method returning.

Instance fields initialize to default or explicit values during object creation. When new allocates memory for an object, it zeros all instance fields to default values.  Code within an <init>()method performs explicit initialization.

All instance initialization occurs prior to the   <init>()method returning.
...................... ragged array
// Create the row array.
double[][] temperatures = new double[3][]; // Note the extra empty pair of brackets.
// Create a column array for each row.
for (int row = 0; row < temperatures.length; row++)
	temperatures[row] = new double[2]; // 2 columns per row

This kind of an array is known as a ragged array because each row can have a different number of columns; the array is not rectangular, but is ragged.
.................................super()
class Vehicle
{
	private String make;
	private String model;
	private int year;

	Vehicle(String make, String model, int year) {
		this.make = make;
		this.model = model;
		this.year = year;
	}
	void describe()
	{
		System.out.println(year + " " + make + " " + model);
	}
	String getMake() {
		return make; }
	String getModel() {
		return model; }
	int getYear() {
		return year; }
}
public class Car extends Vehicle
{
	private int numWheels;
	Car(String make, String model, int year, int numWheels)
	{
		super(make, model, year); // calling parent constructor
		this.numWheels = numWheels;
	}
	@Override //specifiy it to make sure it is override not overload; overloading here will get an error
	void describe()
	{
		System.out.print("This car is a "); // Print without newline . see Chapter 1.
		super.describe(); // calling parent method
	}
	public static void main(String[] args)
	{
		Car car = new Car("Ford", "Fiesta", 2009, 4);
		System.out.println("Make = " + car.getMake());
		System.out.println("Model = " + car.getModel());
		System.out.println("Year = " + car.getYear());
		// Normally, you cannot access a private field via an object
		// reference. However, numWheels is being accessed from
		// within a method (main()) that is part of the Car class.
		System.out.println("Number of wheels = " + car.numWheels);
	}
}

Car's constructor uses reserved word superto call Vehicle.s constructor with Vehicle-oriented Car.s constructor uses reserved word superto call Vehicle.s constructor with Vehicle-oriented arguments and then initializes Car.s numWheelsinstance field. The super()call is analogous to specifying this()to call another constructor in the same class, but invokes a superclass constructor instead.

Caution The super()call can only appear in a constructor. Furthermore, it must be the first code that is specified in the constructor. If super()is not specified, and if the superclass does not have a noargument constructor, the compiler will report an error because the subclass constructor must call a noargument superclass constructor when super()is not present.

A class whose instances cannot be modified is known as an immutable class.  // not set method
a class cannot inherit constructors, nor can it inherit privatefields and methods. //but can call the parent constructor with super()
Use superand the member access operator to access non-privatesuperclass fields from subclasses that mask these fields by declaring same-named fields.
You cannot override a final method.

// if the describe() function defined like this, it is overloading, not
// overriding, since the parameter is different.
void describe(String owner)
{
	System.out.print("This car, which is owned by " + owner + ", is a ");
	super.describe();
}

Java.s support for implementation inheritance only permits you to extend a single class. You cannot extend multiple classes because doing so can lead to problems.
...................... shallow clone
The clone()method clones(duplicates) an object without calling a constructor.  It copies each primitive or reference field.s value to its counterpart in the clone, a task known as shallow copyingor shallow cloning.  
public class Employee implements Cloneable // cloneable object
{
    String name;
    int age;
    Employee(String name, int age)
    {
		this.name = name;
		this.age = age;
    }
    public static void main(String[] args) throws CloneNotSupportedException
    {
		Employee e1 = new Employee("John Doe", 46);
		Employee e2 = (Employee) e1.clone(); // cast to Employee class
		System.out.println(e1 == e2); // Output: false
		System.out.println(e1.name == e2.name); // Output: true
    }
}
A class must implement the java.lang.Cloneable interface or its instances cannot be shallowly cloned via Object.s clone() method-this method performs a runtime check to see if the class implements Cloneable.  The java.lang.Stringclass is an example of a class that doesn.t implement Cloneable; hence, Stringobjects cannot be shallowly cloned.  

Only code within the same package as the class whose clone() method is to be called, or code within a subclass of this class (regardless of package), can call clone().
......................deep clone
override the original clone method from Object.
class Date
{
	int year, month, day;
	Date(int year, int month, int day)
{
	this.year = year;
	this.month = month;
	this.day = day;
}
}
public class Employee implements Cloneable
{
	String name;
	int age;
	Date hireDate;
	Employee(String name, int age, Date hireDate)
	{
		this.name = name;
		this.age = age;
	this.hireDate = hireDate;
	}
	@Override
	protected Object clone() throws CloneNotSupportedException
	{
		Employee emp = (Employee) super.clone();
		if (hireDate != null) // no point cloning a null object (one that doesn't exist)
			emp.hireDate = new Date(hireDate.year, hireDate.month, hireDate.day);
		return emp;
	}
	public static void main(String[] args) throws CloneNotSupportedException
	{
		Employee e1 = new Employee("John Doe", 46, new Date(2000, 1, 20));
		Employee e2 = (Employee) e1.clone();
		System.out.println(e1 == e2); // Output: false
		System.out.println(e1.name == e2.name); // Output: true
		System.out.println(e1.hireDate == e2.hireDate); // Output: false
		System.out.println(e2.hireDate.year + " " + e2.hireDate.month + " " + e2.hireDate.day); 
		// Output: 2000 1 20
	}
}
Employeeoverrides the clone()method to deeply clone the hireDatefield. This method first calls Object.s clone()method to shallowly clone the current Employeeobject.s instance fields and then stores the new object.s reference in emp. 
......................Equity
The ==and !=operators compare two primitive values (such as integers) for equality (==) or inequality (!=). These operators also compare two references to see whether they refer to the same object or not. This latter comparison is known as an identity check.
You cannot use ==and !=to determine whether two objects are logically the same (or not). For example, two Carobjects with the same field values are logically equivalent.  However, ==reports them as unequal because of their different references.
.................................Finalization
Finalization refers to cleanup via the finalize()method, which is known as a finalizer. The finalize()method.s Java documentation states that finalize()is .called by the garbage collector on an object when garbage collection determines that there are no more references to the object.  A subclass overrides the finalize()method to dispose of system resources or to perform other cleanup..  

protected void finalize() throws Throwable
{
	try
	{
		// Perform subclass cleanup.
	}
	finally
	{
		super.finalize();
	}
}
The example.s finalize()declaration appends throws Throwable to the method header because the cleanup code might throw an exception. If an exception is thrown, execution leaves the method and, in the absence of try-finally, super.finalize();never executes. (I will discuss exceptions and try-finally in Chapter 5.)
To guard against this possibility, the subclass.s cleanup code executes in a block that follows reserved word try. If an exception is thrown, Java.s exception-handling logic executes the block following the finallyreserved word, and super.finalize();executes the superclass.s finalize() method.

Note The finalize()method has often been used to perform resurrection(making an unreferenced object referenced) to implement object pools that recycle the same objects when these objects are expensive (time wise) to create (database connection objects are an example).

Resurrection occurs when you assign this(a reference to the current object) to a class or instance field (or to another long-lived variable). For example, you might specify r = this; within finalize() to assign the unreferenced object identified as thisto a class field named r. 

Because of the possibility for resurrection, there is a severe performance penalty imposed on the garbage collection of an object that overrides finalize().

A resurrected object.s finalizer cannot be called again.

......................Hash codes
The hashCode()method returns a 32-bit integer that identifies the current
object.s hash code, a small value that results from applying a mathematical
function to a potentially large amount of data. The calculation of this value
is known as hashing.  

You must override hashCode()when overriding equals()
1). An object's hashcode should remain the same during a java application
execution.  provided no information used in equals(Object)comparisons on the
object is modified. 

2). If two objects are equal according to the equals(Object) method, then
calling the hashCode()method on each of the two objects must produce the same
integer result.  

3). 2 unequal objects should have different hashcodes, however, not a must.

public class Point
{
	private int x, y;
	Point(int x, int y) {
		this.x = x;
		this.y = y; }
	int getX() {
		return x; }
	int getY() {
		return y; }
	@Override
	public boolean equals(Object o)
	{
		if (!(o instanceof Point))
			return false;
		Point p = (Point) o;
		return p.x == x && p.y == y;
	}
	public static void main(String[] args)
	{
	Point p1 = new Point(10, 20);
	Point p2 = new Point(20, 30);
	Point p3 = new Point(10, 20);
	// Test reflexivity
	System.out.println(p1.equals(p1)); // Output: true
	// Test symmetry
	System.out.println(p1.equals(p2)); // Output: false
	System.out.println(p2.equals(p1)); // Output: false
	// Test transitivity
	System.out.println(p2.equals(p3)); // Output: false
	System.out.println(p1.equals(p3)); // Output: true
	// Test nullability
	System.out.println(p1.equals(null)); // Output: false
	// Extra test to further prove the instanceof operator's usefulness.
	System.out.println(p1.equals("abc")); // Output: false

	java.util.Map<Point, String> map = new java.util.HashMap<Point, String>();
	map.put(p1, "first point"); // to start the object key p1 and value "first point" to hashmap
	System.out.println(map.get(p1)); // Output: first point, 
	System.out.println(map.get(new Point(10, 20))); // Output: null, because hashcode() need to be overridden to retrun same intrger value for logically equivalent objects..
	}
}
......................String Representation
The toString()method returns a string-based representation of the current object. This representation defaults to the object.s class name, followed by the @symbol, followed by a hexadecimal representation of the object's hash code.
For example: System.out.println(p1); // Output:  Point@3e25a5.
To override:
@Override
public String toString()
{
	return "(" + x + ", " + y + ")";
}
System.out.println(p1);//output: (10, 20).
......................Composition
Implementation inheritance is concerned with extending a class with a new class, which is based on an .is-a. relationship between them: a Caris a Vehicle, for example.

On the other hand, compositionis concerned with composing classes out of other classes, which is based on a .has-a. relationship between them. For example, a Carhas an Engine, Wheels, and a SteeringWheel.

public class ApptCalendar
{
	private final static int MAX_APPT = 1000;
	private Appt[] appts;
	private int size;
	public ApptCalendar()
	{
		appts = new Appt[MAX_APPT];
		size = 0; // redundant because field automatically initialized to 0
		// adds clarity, however
	}
	public void addAppt(Appt appt)
	{
		if (size == appts.length)
			return; // array is full
		appts[size++] = appt;
	}
	public void addAppts(Appt[] appts) {
		for (int i = 0; i < appts.length; i++)
			addAppt(appts[i]); }
}

public class LoggingApptCalendar
{
	private ApptCalendar apptCal;
	public LoggingApptCalendar(ApptCalendar apptCal)
	{
		this.apptCal = apptCal;
	}
	public void addAppt(Appt appt)
	{
		Logger.log(appt.toString());
		apptCal.addAppt(appt);
	}
	public void addAppts(Appt[] appts)
	{
		for (int i = 0; i < appts.length; i++)
			Logger.log(appts[i].toString());
			apptCal.addAppts(appts);
	}
}
Instead of extending the superclass, create a private field in a new class, and have this field reference an instance of the superclass. This task demonstrates composition because you are forming a .has-a. relationship between the new class and the superclass.
Additionally, have each of the new class.s instance methods call the corresponding superclass method via the superclass instance that was saved in the private field, and also return the called method.s return value. This task is known as forwarding, and the new methods are known as forwarding methods.

LoggingApptCalendaris an example of a wrapper class, a class whose instances wrap other instances. Each LoggingApptCalendarinstance wraps an ApptCalendarinstance.  LoggingApptCalendaris also an example of the Decorator design pattern, 

When should you extend a class and when should you use a wrapper class? Extend a class when an .is-a. relationship exists between the superclass and the subclass, and either you have control over the superclass or the superclass has been designed and documented for class extension.  Otherwise, use a wrapper class.

What does .design and document for class extension. mean? Design means provide protected methods that hook into the class.s inner workings (to support writing efficient subclasses) and ensure that constructors and the clone()method never call overridable methods.  Document means clearly state the impact of overriding methods.

CautionWrapper classes shouldn.t be used in a callback framework, an object framework in which an object passes its own reference to another object (via this) so that the latter object can call the former object.s methods at a later time. This .calling back to the former object.s method. is known as a callback. Because the wrapped object doesn.t know of its wrapper class, it passes only its reference (via this), and resulting callbacks don.t involve the wrapper class's methods
......................polymorphism
Java supports four kinds of polymorphism:
Coercion: An operation serves multiple types through implicit type conversion. 
Overloading: The same operator symbol or method name can be used in different contexts.
Parametric: Within a class declaration, a field name can associate with different types and a method name can associate with different parameter and return types. 
Subtype: A type can serve as another type.s subtype. When a subtype instance appears in a supertype context, executing a supertype operation on the subtype instance results in the subtype.s version of that operation executing.  For example, suppose that Circleis a subclass of Pointand that both classes contain a draw()method. Assigning a Circleinstance to a variable of type Point, and then calling the draw()method via this variable, results in Circle.s draw()method being called. 
The concerned method has to exist in both subclass and superclass.
using upcasting and late binding
......................abstract class and abstract method
abstract class cannot be instantiated
abstract class Shape
{
	abstract void draw(); // semicolon is required
}
The abstract reserved word is also used to declare a method without a body. The draw()method doesn.t need a body because it cannot draw an abstract shape.
abstract final class Shape is an error because an abstract class cannot be instantiated and a final class cannot be extended. The compiler also reports an error when you declare a method to be abstract but do not declare its class to be abstract.
......................Downcasting and Runtime Type Identification
The virtual machine.s cast verification illustrates runtime type identification(or RTTI, for short). Cast verification performs RTTI by examining the type of the cast operator.s operand to see whether the cast should be allowed or not.
......................  Covariant Return Types
A covariant return type is a method return type that, in the superclass.s method declaration, is the supertype of the return type in the subclass.s overriding method declaration.
Covariant return types minimize upcasting and downcasting. For example, Subclass.s createReturnType()method doesn.t need to upcast its SubReturnTypeinstance to its SubReturnType return type. Furthermore, this instance doesn.t need to be downcast to SubReturnTypewhen assigning to variable subrt.
......................interface
interface is  final, abstract by default. It is always instance method, can not be static.
interface Drawable
{
	int RED = 1; // For simplicity, integer constants are used. These constants
	are
	int GREEN = 2; // not that descriptive, as you will see.
	int BLUE = 3;
	int BLACK = 4;
	void draw(int color);
}
An interface that declares no members is known as a marker interface or a tagging interface.  It associates metadata with a class. For example, the presence of the Cloneablemarker/tagging interface implies that instances of its implementing class can be shallowly cloned. RTTI is used to detect that an object.s class implements a marker/tagging interface. For example, when Object.s clone()method detects, via RTTI, that the calling instance.s class implements Cloneable, it shallowly clones the object.  

To implement an interface, the class must specify, for each interface method header, a method whose header has the same signature and return type as the interface.s method header and a code body to go with the method header.  When implementing a method, don.t forget that the interface.s methods are implicitly declared public.

When a class implements an interface, the class inherits the interface.s constants and method headers and overrides the method headers by providing implementations (hence the @Override annotation). This is known as interface inheritance.

interface Drawable
{
	int RED = 1; // For simplicity, integer constants are used. These constants are
	int GREEN = 2; // not that descriptive, as you will see.
	int BLUE = 3;
	int BLACK = 4;
	void draw(int color);
}
interface Fillable
{
	int RED = 1;
	int GREEN = 2;
	int BLUE = 3;
	int BLACK = 4;
	void fill(int color);
}

class Point implements Drawable, Fillable
{
	private int x, y;
	Point(int x, int y)
	{
		this.x = x;
		this.y = y;
	}
	int getX() {
		return x; }
	int getY() {
		return y; }
	@Override
	public String toString() {
		return "(" + x + ", " + y + ")"; }
	@Override
	public void draw(int color) {
		System.out.println("Point drawn at " + toString() + " in color " + color); }
	@Override
	public void fill(int color){
	}
}
class Circle extends Point implements Drawable, Fillable
{
	private int radius;
	Circle(int x, int y, int radius)
	{
		super(x, y);
		this.radius = radius;
	}
	int getRadius()
	{
		return radius;
	}
	@Override
	public String toString()
	{
		return "" + radius;
	}
	@Override
	public void draw(int color)
	{
		System.out.println("Circle drawn at " + super.toString() +
		" with radius " + toString() + " in color " + color);
	}
	@Override
	public void fill(int color){
	}
}


public static void main(String[] args)
{
	Drawable[] drawables = new Drawable[] { new Point(10, 20), new Circle(10, 20, 30) };
	for (int i = 0; i < drawables.length; i++)
		drawables[i].draw(Drawable.RED);
	Fillable[] fillables = new Fillable[drawables.length];
	for (int i = 0; i < drawables.length; i++)
	{
		fillables[i] = (Fillable) drawables[i];
		fillables[i].fill(Fillable.GREEN);
	}
}

Because Point and Circle instances are drawables by virtue of these classes implementing the Drawable interface, it is legal to assign Point and Circle instance references to variables (including array elements) of type Drawable.  


class EnclosingClass
{
	private static int i;
	private static void m1()
	{
		System.out.println(i);
	}
	static void m2()
	{
		EnclosedClass.accessEnclosingClass();
	}
	static class EnclosedClass
	{
		static void accessEnclosingClass(){ //accessed from the class name
			i = 1;
			m1();
		}
		void accessEnclosingClass2(){ // accessed through an instance
			m2();
		}
	}
}

public class SMCDemo
{
	public static void main(String[] args)
	{
	EnclosingClass.EnclosedClass.accessEnclosingClass(); // Output: 1
	EnclosingClass.EnclosedClass ec = new EnclosingClass.EnclosedClass();
	ec.accessEnclosingClass2(); // Output: 1
	}
}

For nonstatic member class, EnclosedClassmust be instantiated before this method can be called. 
class EnclosingClass
{
	private int i;
	private void m()
	{
		System.out.println(i);
	}
	class EnclosedClass
	{
		void accessEnclosingClass()
		{
			i = 1;
			m();
		}
	}
}
public class NSMCDemo
{
	public static void main(String[] args)
	{
		EnclosingClass ec = new EnclosingClass(); //Create an object for EnclosingClass
		ec.new EnclosedClass().accessEnclosingClass(); //then ec.new ...  Output: 1
	}
}
Note: Prefixing newwith a reference to the enclosing class is rare. Instead, you will typically call an enclosed class.s constructor from within a constructor or an instance method of its enclosing class.

Note Code within an enclosed class can obtain a reference to its enclosing class instance by qualifying reserved word this with the enclosing class.s name and the member access operator. For example, if code within accessEnclosingClass()needed to obtain a reference to its EnclosingClassinstance, it would specify EnclosingClass.this.
......................Anonymous Classes
An anonymous classis a class without a name. Furthermore, it is not a member of its enclosing class. Instead, an anonymous class is simultaneously declared (as an anonymous extension of a class or as an anonymous implementation of an interface) and instantiated any place where it is legal to specify an expression.
abstract class Speaker
{
	abstract void speak();
}
public class ACDemo
{
	public static void main(final String[] args)
	{
		new Speaker() //anonymous class extending Speaker
		{
			String msg = (args.length == 1) ? args[0] : "nothing to say";
			@Override
			void speak()
			{
				System.out.println(msg);
			}
		}
		.speak(); //cause the class has no name, so only . to access the method
	}
}

//or use interface
interface Speakable
{
	void speak();
}
public class ACDemo
{
	public static void main(final String[] args)
	{
		new Speakable()
		{
			String msg = (args.length == 1) ? args[0] : "nothing to say";
			@Override
			public void speak()
			{
				System.out.println(msg);
			}
		}
		.speak();
	}
}

// to return a list of all filenames having the .javasuffix.
String[] list = new File(directory).list(new FilenameFilter()
	{
		@Override
		public boolean accept(File f, String s)
		{
			return s.endsWith(".java");
		}
	});
......................Local Classes
A local classis a class that is declared anywhere that a local variable is declared. Furthermore, it has the same scope as a local variable. 
Using class as a local variable.
A local class instance can access the surrounding scope.s local variables and parameters. However, the local variables and parameters that are accessed must be declared final.
class EnclosingClass
{
	void m(final int x)
	{
		final int y = x * 2;
		class LocalClass
		{
			int a = x;
			int b = y;
		}
		LocalClass lc = new LocalClass();
		System.out.println(lc.a);
		System.out.println(lc.b);
	}
}
public class LCDemo
{
	public static void main(String[] args)
	{
		EnclosingClass ec = new EnclosingClass();
		ec.m(10);
	}
}
...................... import
import ca.tutortutor.graphics.shapes.*; //search in that package
import ca.tutortutor.graphics.shapes.Circle;//to be exact
......................jar
jar cf logger.jar logging\*.class // or
jar tf logger.jar //(The toption stands for .list table of contents..)
......................constant interfaces 
interface Directions
{
	int NORTH = 0;
	int SOUTH = 1;
	int EAST = 2;
	int WEST = 3;
}

...................... static import
This static imports feature lets you import a class.s staticmembers so that you don.t have to qualify them with their class names. 
import static packagespec. classname. ( staticmembername| * );
import static java.lang.Math.PI; // Import the PI static field only.
import static java.lang.Math.cos; // Import the cos() static method only.
import static java.lang.Math.*; // Import all static members from Math.

................................. Exception
A "checked exception" is an exception that represents a problem with the possibility of recovery and for which the developer must provide a workaround. The developer should check(examine) the code to ensure that the exception is handled in the method where it is thrown or is explicitly identified as being handled elsewhere.
Exceptionand all subclasses except for java.lang.RuntimeException(and its subclasses) describe checked exceptions.  

A throws clause identifies all checked exceptions that are thrown out of the method and must be handled by some other method. It consists of reserved word throws followed by a comma-separated list of "checked exception" class names and is always appended to a method header. 

package media;
public class InvalidMediaFormatException extends Exception
{
	private String expectedFormat;
	private String existingFormat;
	public InvalidMediaFormatException(String expectedFormat, String existingFormat)
	{
		super("Expected format: " + expectedFormat + ", Existing format: " + existingFormat);
		this.expectedFormat = expectedFormat;
		this.existingFormat = existingFormat;
	}
	public String getExpectedFormat()
	{
		return expectedFormat;
	}
	public String getExistingFormat()
	{
		return existingFormat;
	}
}

package media;
import java.io.IOException;
public final class Media
{
public static void convert(String srcName, String dstName)
	throws InvalidMediaFormatException, IOException
	{
		if (srcName == null)
			throw new NullPointerException(srcName + " is null"); //unchecked exception
		if (dstName == null)
			throw new NullPointerException(dstName + " is null");
		// Code to access source file and verify that its format matches the
		// format implied by its file extension.
		//
		// Assume that the source file's extension is RM (for Real Media) and
		// that the file's internal signature suggests that its format is
		// Microsoft WAVE.
		String expectedFormat = "RM";
		String existingFormat = "WAVE";
		throw new InvalidMediaFormatException(expectedFormat, existingFormat);
	}
}
try
{
	int x = 1 / 0;
}
catch (ArithmeticException ae)
{
	System.out.println("attempt to divide by zero");
}
// catch multiple exception
import java.io.FileNotFoundException;
import java.io.IOException;
import media.InvalidMediaFormatException;
import media.Media;
public class Converter
{
	public static void main(String[] args)
	{
		if (args.length != 2)
		{
			System.err.println("usage: java Converter srcfile dstfile");
			return;
		}
		try
		{
			Media.convert(args[0], args[1]);
		}
		catch (InvalidMediaFormatException imfe)
		{
			System.out.println("Unable to convert " + args[0] + " to " + args[1]);
			System.out.println("Expecting " + args[0] + " to conform to " +
			imfe.getExpectedFormat() + " format.");
			System.out.println("However, " + args[0] + " conformed to " +
			imfe.getExistingFormat() + " format.");
		}
		catch (FileNotFoundException fnfe)
		{ // ....
		}
		catch (IOException ioe)
		{ // ....
		}
	}
}
Although not thrown, a catch block for IOException is required because this checked exception type appears in convert().s throws clause. Because the catch (IOException ioe)block can also handle thrown FileNotFoundExceptioninstances (because FileNotFoundExceptionsubclasses IOException), the catch (FileNotFoundException fnfe)block isn.t necessary at this point 

Although you can write catch blocks in any order, the compiler restricts this order when one catch block.s parameter is a supertype of another catch block.s parameter. The subtype parameter catch block must precede the supertype parameter catch block; otherwise, the subtype parameter catch block will never be executed.

......................Rethrowing Exceptions
//To give it to proper handler.
catch (IOException ioe)
{
	throw new ReportCreationException(ioe);
}
//To log the exception
catch (FileNotFoundException fnfe)
{
	logger.log(fnfe);
	throw fnfe; // Rethrow the exception here.
}
...................... finally
//The finally block consists of reserved word finallyfollowed by a body, which provides the cleanup code. A finally block follows either a catch block or a try block. In the former case, the exception may be handled (and possibly rethrown) before finally executes. In the latter case, the exception is handled (and possibly rethrown) after finally executes.

import java.io.IOException;
public class Copy
{
	public static void main(String[] args)
	{
		if (args.length != 2)
		{
			System.err.println("usage: java Copy srcFile dstFile");
			return;
		}
		int fileHandleSrc = 0;
		int fileHandleDst = 1;
		try
		{
			fileHandleSrc = open(args[0]);
			fileHandleDst = create(args[1]);
			copy(fileHandleSrc, fileHandleDst);
		}
		catch (IOException ioe)
		{
			System.err.println("I/O error: " + ioe.getMessage());
			return;
		}
		finally // always run
		{
			close(fileHandleSrc);
			close(fileHandleDst);
		}
	}
	static int open(String filename)
	{
		return 1; // Assume that filename is mapped to integer.
	}
	static int create(String filename)
	{
		return 2; // Assume that filename is mapped to integer.
	}
	static void close(int fileHandle)
	{
		System.out.println("closing file: " + fileHandle);
	}
	static void copy(int fileHandleSrc, int fileHandleDst) throws IOException
	{
		System.out.println("copying file " + fileHandleSrc + " to file " + fileHandleDst);
		if (Math.random() < 0.5)
			throw new IOException("unable to copy file");
	}
}
//Whether or not an I/O error occurs, notice that the finally block is the final code to execute. The finally block executes even though the catch block ends with a return statement.

//Or without catch, and throws in main() header
import java.io.IOException;
public class Copy
{
	public static void main(String[] args) throws IOException
	{
		if (args.length != 2)
		{
			System.err.println("usage: java Copy srcFile dstFile");
			return;
		}
		int fileHandleSrc = 0;
		int fileHandleDst = 1;
		try
		{
			fileHandleSrc = open(args[0]);
			fileHandleDst = create(args[1]);
			copy(fileHandleSrc, fileHandleDst);
		}
		finally
		{
			close(fileHandleSrc);
			close(fileHandleDst);
		}
	}
	static int open(String filename)
	{
		return 1; // Assume that filename is mapped to integer.
	}
	static int create(String filename)
	{
		return 2; // Assume that filename is mapped to integer.
	}
	static void close(int fileHandle)
	{
		System.out.println("closing file: " + fileHandle);
	}
	static void copy(int fileHandleSrc, int fileHandleDst) throws IOException
	{
		System.out.println("copying file " + fileHandleSrc + " to file " + fileHandleDst);
		if (Math.random() < 0.5)
			throw new IOException("unable to copy file");
	}
}
//The only difference is the throws clause appended to the main()method header and the removal of the catch block. When IOExceptionis thrown, the finally block executes before execution leaves the main()method. This time, Java.s default exception handler executes printStackTrace()and you observe output similar to the following:
copying file 1 to file 2
closing file: 1
closing file: 2
Exception in thread "main" java.io.IOException: unable to copy file
			at Copy.copy(Copy.java:48)
			at Copy.main(Copy.java:19)
......................Annotations
An annotationis an instance of an annotation type and associates metadata with an application element. It is expressed in source code by prefixing the type name with the @ symbol. For example, @Readonlyis an annotation and Readonlyis its type.
The compiler supports the Override, Deprecated, and SuppressWarnings annotation types.

@Deprecated annotations are useful for indicating that the marked application element is deprecated (phased out) and should no longer be used. The compiler warns you when a deprecated application element is accessed by nondeprecated code.
In contrast, the @deprecated javadoc tag and associated text warns you against using the deprecated item and tells you what to use instead.

When accessing a @Deprecated field within the same class, the compiler will surprse the warning message.
//otherwise
class Employee
{
	/**
	* Employee's name
	* @deprecated New version uses firstName and lastName fields.
	*/
	@Deprecated
	String name;
	String firstName;
	String lastName;
}
public class UseEmployee
{
	public static void main(String[] args)
	{
		Employee emp = new Employee();
		emp.name = "John Doe";
	}
}
//It will cause this error:
Note: UseEmployee.java uses or overrides a deprecated API.
Note: Recompile with -Xlint:deprecation for details.

//To find out the Deprecated item, recompile:
javac -Xlint:deprecation UseEmployee.java

//Then it will show:
Employee.java:18: warning: [deprecation] name in Employee has been deprecated
	emp.name = "John Doe";
	   ^
1 warning
// to supprse the warning
public class UseEmployee
{
	@SuppressWarnings("deprecation")
	public static void main(String[] args)
	{
		Employee emp = new Employee();
		emp.name = "John Doe";
	}
}
......................generics
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
class Employee
{
	private String name;
	Employee(String name)
	{
		this.name = name;
	}
	String getName()
	{
		return name;
	}
}
public class TypeSafety
{
	public static void main(String[] args)
	{
		List<Employee> employees = new ArrayList<Employee>();//to specify the type to store in list
		//List employees = new ArrayList(); // instead of this line
		employees.add(new Employee("John Doe"));
		employees.add(new Employee("Jane Smith"));
		employees.add("Jack Frost"); // this line should be illegle
		Iterator<Employee> iter = employees.iterator();
		while (iter.hasNext())
		{
			Employee emp = iter.next();
			System.out.println(emp.getName());
		}
	}
}
......................Generic Types
is to define and limit the container, like list, to one type of object.
A generic typeis a class or interface that introduces a family of parameterized types by declaring a formal type parameter list(a comma-separated list of type parameternames between angle brackets). This syntax is expressed as follows:

class identifier<formal_type_parameter_list> {}
interface identifier<formal_type_parameter_list> {}

A generic type also identifies a raw type, which is a generic type without its type parameters. For example, List<Employee>.s raw type is List. Raw types are nongeneric and can hold any Object.
......................Type Parameter Bounds
For example, ShapesList<E extends Shape>identifies Shapeas an upper bound. You can specify ShapesList<Circle>, ShapesList<Rectangle>, and even ShapesList<Shape>, but not ShapesList<String>because Stringis not a subclass of Shape.
abstract class Shape
{
}
class Circle extends Shape implements Comparable<Circle>
{
	private double x, y, radius;
	Circle(double x, double y, double radius)
	{
		this.x = x;
		this.y = y;
		this.radius = radius;
	}
	@Override
	public int compareTo(Circle circle)
	{
		if (radius < circle.radius)
			return -1;
		else
			if (radius > circle.radius)
				return 1;
			else
				return 0;
	}
	@Override
	public String toString()
	{
		return "(" + x + ", " + y + ", " + radius + ")";
	}
}
class SortedShapesList<S extends Shape & Comparable<S>>//multiple upper bounds
{
	@SuppressWarnings("unchecked")
	private S[] shapes = (S[]) new Shape[2];
	private int index = 0;
	void add(S shape)
	{
		shapes[index++] = shape;
		if (index < 2)
			return;
		System.out.println("Before sort: " + this);
		sort();
		System.out.println("After sort: " + this);
	}
	private void sort()
	{
		if (index == 1)
			return;
		if (shapes[0].compareTo(shapes[1]) > 0)
		{
			S shape = (S) shapes[0];
			shapes[0] = shapes[1];
			shapes[1] = shape;
		}
	}
	@Override
	public String toString()
	{
		return shapes[0].toString() + " " + shapes[1].toString();
	}
}
public class SortedShapesListDemo
{
	public static void main(String[] args)
	{
		SortedShapesList<Circle> ssl = new SortedShapesList<Circle>();
		ssl.add(new Circle(100, 200, 300));
		ssl.add(new Circle(10, 20, 30));
	}
}
A type parameter bound that includes the type parameter is known as a recursive type bound. For A type parameter bound that includes the type parameter is known as a recursive type bound. For example, Comparable<S>in S extends Shape & Comparable<S>is a recursive type bound. Recursive type bounds are rare and typically show up in conjunction with the Comparableinterface for specifying a type.s natural ordering.

the fundamental rule of generic types: for a given subtype x of type y, and given G as a raw type declaration, G<x> is not a subtype of G<y>.  For example, List<String> is not a specialized kind of List<Object>, can use List<?> instead.
// This CAN NOT WORK!!
static void copyList(List<?> src, List<?> dest)
{
	for (int i = 0; i < src.size(); i++)
		dest.add(src.get(i));
}
//Do it this way instead
static void copyList(List<? extends String> src, List<? super String> dest)
{
	for (int i = 0; i < src.size(); i++)
		dest.add(src.get(i));
}
Specifically, it shows an upper bound via extendsfollowed by the upper bound type after the ?, and a lower bound via superfollowed by the lower bound type after the ?.  You interpret ? extends Stringto mean that any actual type argument that is Stringor a subclass of this type can be passed, and you interpret ? super Stringto imply that any actual type argument that is Stringor a superclass of this type can be passed. Because Stringcannot be subclassed, this means that you can only pass source lists of Stringand destination lists of Stringor Object.
Unlike with arrays, a generic type.s type parameters are not reified. They.re not available at runtime because they.re thrown away after the source code is compiled. This .throwing away of type parameters. is a result of "erasure", which also involves inserting casts to appropriate types when the code isn.t type correct and replacing type parameters by their upper bounds (such as Object).
...................... enum
An enumerated type is a type that specifies a named sequence of related constants as its legal values.
...................... string
String intern() 
Search an internal table of String objects for an object whose string is equal to this String object.s string. This Stringobject.s string is added to the table when not present. Return the object contained in the table whose string is equal to this String object.s string. The same String object is always returned for strings that are equal.

This copy all strings to an interal pool. 

By default, Stringobjects denoted by literal strings ("abc") and string-valued constant expressions ("a" + "bc") are interned in this table, which is why System.out.println("abc" == "a" + "bc"); outputs true. However, Stringobjects created via Stringconstructors are not interned, which is why System.out.println("abc" == new String("abc"));outputs false. In contrast, System.out.  println("abc" == new String("abc").intern());outputs true.
......................StringBuffer and StringBuilder
StringBufferand StringBuilderare identical apart from the fact that StringBuilderoffers better performance than StringBufferbut cannot be used in the context of multiple threads without explicit thread synchronization (discussed in Chapter 8).
Use StringBufferin a multithreaded context (for safety) and StringBuilderin a single-threaded context (for performance).

A StringBufferor StringBuilderobject.s internal array is associated with the concepts of capacity and length. Capacityrefers to the maximum number of characters that can be stored in the array before the array grows to accommodate additional characters. Lengthrefers to the number of characters that are already stored in the array.

int numLeadingSpaces = 3; // default value
StringBuffer sb = new StringBuffer();
for (int j = 0; j < numLeadingSpaces; j++)
	sb.append('0');
String spacesPrefix = sb.toString();
.................................
Boolean isNegative(double d)
{
	return (d < 0) ? Boolean.TRUE : Boolean.FALSE;
}

This method avoids creating Booleanobjects by returning either the precreated TRUEor FALSE object.

public class FloatDoubleDemo
{
	public static void main(String[] args)
	{
		Float f1 = new Float(Float.NaN);
		System.out.println(f1.floatValue());
		Float f2 = new Float(Float.NaN);
		System.out.println(f2.floatValue());
		System.out.println(f1.equals(f2));
		System.out.println(Float.NaN == Float.NaN);
		System.out.println();
		Double d1 = new Double(+0.0);
		System.out.println(d1.doubleValue());
		Double d2 = new Double(-0.0);
		System.out.println(d2.doubleValue());
		System.out.println(d1.equals(d2));
		System.out.println(+0.0 == -0.0);
	}
}
NaN
NaN
true
false
0.0
-0.0
false
true

When you want to test a floator doublevalue for equality with +infinity or .infinity (but not both), don.t use isInfinite(). Instead, compare the value with NEGATIVE_INFINITYor POSITIVE_INFINITYvia ==. For example, f == Float.NEGATIVE_INFINITY.


public class Calc
{
	public static void main(String[] args)
	{
		if (args.length != 3)
		{
			System.err.println("usage: java Calc value1 op value2");
			System.err.println("op is one of +, -, x, or /");
			return;
		}
	try
	{
		double value1 = Double.parseDouble(args[0]);
		double value2 = Double.parseDouble(args[2]);
		if (args[1].equals("+"))
			System.out.println(value1 + value2);
		else
		if (args[1].equals("-"))
			System.out.println(value1 - value2);
		else
		if (args[1].equals("x"))
			System.out.println(value1 * value2);
		else
		if (args[1].equals("/"))
			System.out.println(value1 / value2);
		else
			System.err.println("invalid operator: " + args[1]);
		}
	catch (NumberFormatException nfe)
	{
		System.err.println("Bad number format: " + nfe.getMessage());
	}
	}
}
......................Thread
java.util.concurrent is the preferred API for working with threads

Java supports threads via its Threads API. This API consists of one interface (Runnable) and four classes (Thread, ThreadGroup, ThreadLocal, and InheritableThreadLocal) in the java.langpackage. 

Java provides the Runnable interface to identify those objects that supply code for threads to execute via this interface.s solitary void run()method.a thread receives no arguments and returns no value. Classes implement Runnableto supply this code, and one of these classes is Thread.

Thread provides a consistent interface to the underlying operating system.s threading architecture.  (The operating system is typically responsible for creating and managing threads.) Thread makes it possible to associate code with threads as well as start and manage those threads. Each Thread instance associates with a single thread.

Thread.State getState()
Return the state of the thread associated with this Threadobject. The state is identified by the Thread.Stateenum as one of BLOCKED(waiting to acquire a lock, discussed later), NEW(created but not started), RUNNABLE(executing), TERMINATED (the thread has died), TIMED_WAITING(waiting for a specified amount of time to elapse), or WAITING(waiting indefinitely).

void interrupt() 
Set the interrupt status flag in this Threadobject. If the associated thread is blocked or is waiting, clear this flag and wake up the thread by throwing an instance of the java.lang.InterruptedExceptionclass.

static boolean interrupted()
Return true when the thread associated with this Threadobject has a pending interrupt request. Clear the interrupt status flag.

boolean isDaemon() 
Return true when the thread associated with this Threadobject is a daemon thread, a thread that acts as a helper to a user thread(nondaemon thread) and dies automatically when the application.s last nondaemon thread dies so the application can exit.

boolean isInterrupted() 
Return true when the thread associated with this Thread object has a pending interrupt request.

void join() 
The thread that calls this method on this Threadobject waits for the thread associated with this object to die. This method throws InterruptedException when this Threadobject.s interrupt()method is called.

void join(long millis) 
The thread that calls this method on this Threadobject waits for the thread associated with this object to die, or until millismilliseconds have elapsed, whichever happens first. This method throws InterruptedExceptionwhen this Threadobject.s interrupt()method is called.

void setDaemon(boolean isDaemon)
Mark this Threadobject.s associated thread as a daemon thread when isDaemon is true. This method throws java.lang.IllegalThreadStateExceptionwhen the thread has not yet been created and started.

void setName(String threadName)
Assign threadName.s value to this Threadobject as the name of its associated thread.

static void sleep(long time)
Pause the thread associated with this Threadobject for timemilliseconds. This method throws InterruptedException when this Threadobject.s interrupt() method is called while the thread is sleeping.

void start() 
Create and start this Threadobject.s associated thread. This method throws IllegalThreadStateExceptionwhen the thread was previously started and is running or has died.

public class CountingThreads
{
	public static void main(String[] args)
	{
		Runnable r = new Runnable()
			{
				@Override
				public void run()
				{
					String name = Thread.currentThread().getName();
					int count = 0;
					while (true)
						System.out.println(name + ": " + count++);
				}
			};
		Thread thdA = new Thread(r);
		Thread thdB = new Thread(r);
		thdA.start();
		thdB.start();
	}
}
Thread-0: 0
Thread-0: 1
Thread-1: 0
Thread-0: 2
Thread-1: 1
Thread-0: 3
	...
	...

public class CountingThreads
{
	public static void main(String[] args)
	{
		Runnable r = new Runnable()
			{
				@Override
				public void run()
				{
					String name = Thread.currentThread().getName()
					int count = 0;
					while (true)
					{
						System.out.println(name + ": " + count++);
						try
						{
							Thread.sleep(100);
						}
						catch (InterruptedException ie)
						{
						}
					}
				}
			};
		Thread thdA = new Thread(r);
		thdA.setName("A");
		Thread thdB = new Thread(r);
		thdB.setName("B");
		thdA.start();
		thdB.start();
	}
}
A: 0
B: 0
A: 1
B: 1
B: 2
A: 2
B: 3
A: 3

//Starting a worker thread within a thread, then wait for worker to finish and
//send the result.

public class JoinDemo
{
	public static void main(String[] args)
		{
		Runnable r = new Runnable()
				{
					@Override
					public void run()
					{
						System.out.println("Worker thread is simulating " +
						"work by sleeping for 5 seconds.");
						try
						{
							Thread.sleep(5000);
						}
						catch (InterruptedException ie)
						{
						}
						System.out.println("Worker thread is dying.");
					}
				};
		Thread thd = new Thread(r);
		thd.start();
		System.out.println("Default main thread is doing work.");
		try
		{
			Thread.sleep(2000);
		}
		catch (InterruptedException ie)
		{
		}
		System.out.println("Default main thread has finished its work.");
		System.out.println("Default main thread is waiting for worker thread " + "to die.");
		try
		{
			thd.join(); //waiting the worker process to finish, with its join()
		}
		catch (InterruptedException ie)
		{
		}
		System.out.println("Main thread is dying.");
	}
}
......................Thread Synchronization
A "race condition" is a scenario in which multiple threads update the same object at the same time or nearly at the same time. Part of the object stores values written to it by one thread, and another part of the object stores values written to it by another thread.

"race condition" can show when a operation need 2 steps. The OS scheduler can interrupt the thread after the first step, then the second thread comes to update the same data, once it completes, the 1st thread is back to run the 2nd step. So, the data will be wrong. One step operation is called "atomic", can avoid race condition.
This problem can be corrected by synchronizing access to withdraw() so that only one thread at a time can execute inside this method. You synchronize access at the method level by adding reserved word synchronized to the method header prior to the method.s return type, for example, synchronized boolean withdraw(int amount).

As I demonstrate later, you can also synchronize access to a block of statements by specifying synchronized(object) { /* synchronized statements */ }, where objectis an arbitrary object reference. No thread can enter a synchronized method or block until execution leaves the method/block; this is known as "mutual exclusion".

public class CheckingAccount
{
private int balance;
	public CheckingAccount(int initialBalance)
	{
		balance = initialBalance;
	}
	public boolean withdraw(int amount)
	{
		if (amount <= balance)
		{
			try
			{
				Thread.sleep((int) (Math.random() * 200));
			}
			catch (InterruptedException ie)
			{
			}
			balance -= amount;
			return true;
		}
		return false;
	}
	public static void main(String[] args)
	{
		final CheckingAccount ca = new CheckingAccount(100);
			Runnable r = new Runnable()
				{
					public void run()
					{
						String name = Thread.currentThread().getName();
						for (int i = 0; i < 10; i++)
							System.out.println (name + " withdraws $10: " + ca.withdraw(10));
					}
				};
		Thread thdHusband = new Thread(r);
		thdHusband.setName("Husband");
		Thread thdWife = new Thread(r);
		thdWife.setName("Wife");
		thdHusband.start();
		thdWife.start();
	}
}
Synchronization is implemented in terms of monitors and locks. 
A "monitor" is a concurrency construct for controlling access to a critical section, a region of code that must execute atomically.  It is identified at the source code level as a synchronized method or a synchronized block.
A "lock" is a token that a thread must acquire before a monitor allows that thread to execute inside a monitor.s critical section. The token is released automatically when the thread exits the monitor to give another thread an opportunity to acquire the token and enter the monitor.

A thread that has acquired a lock doesn.t release this lock when it calls one of Thread.s sleep()methods.

Thread declares a static boolean holdsLock(Object o)method that returns true when the calling thread holds the monitor lock on object o. You will find this method handy in assertion statements, such as assert Thread.holdsLock(o);.

Synchronization guarantee threads to access a single shared copy of the data (not a cached copy).

"Synchronization" is necessary to support "mutual exclusion" or "mutual exclusion" combined with thread communication. However, there exists an alternative to synchronization when the only purpose is to communicate between threads. This alternative is reserved word volatile,

declares stopped (a variable in example) to be volatile; threads that access this field will always access a single shared copy (not cached copies on multiprocessor/multicore machines).  In addition to generating code that is less verbose, volatile might offer improved performance over synchronization.

When a field is declared volatile, it cannot also be declared final.

Use volatile only in a thread communication context. Also, you can only use this reserved word in the context of field declarations. Although you can declare doubleand longfields volatile, you should avoid doing so on 32-bit virtual machines because it takes two operations to access a doubleor long variable.s value, and mutual exclusion via synchronization is required to access their values safely.
Volatile can be used in thread communcation, but can not prevent race condition. mutex is required.

java.lang.Object.s wait(), notify(), and notifyAll()methods support a form of thread communication where a thread voluntarily waits for some condition(a prerequisite for continued execution) to arise, at which time another thread notifies the waiting thread that it can continue.  wait()causes its calling thread to wait on an object.s monitor, and notify()and notifyAll()wake up one or all threads waiting on the monitor.

Because the wait(), notify(), and notifyAll()methods depend on a lock, they cannot be called from outside of a synchronized method or synchronized block.  If you fail to heed this warning, you will encounter a thrown instance of the java.lang.IllegalMonitorStateException class. Also, a thread that has acquired a lock releases this lock when it calls one of Object.s wait() methods.

A classic example of thread communication involving conditions is the relationship between a producer thread and a consumer thread. The producer thread produces data items to be consumed by the consumer thread. Each produced data item is stored in a shared variable.

the producer thread must wait until it is notified that the previously produced data item has been consumed, and the consumer thread must wait until it is notified that a new data item has been produced. 

public class PC
{
	public static void main(String[] args)
	{
		Shared s = new Shared();
		new Producer(s).start();
		new Consumer(s).start();
	}
}
class Shared
{
	private char c = '\u0000';
	private boolean writeable = true;
	synchronized void setSharedChar(char c)
	{
		while (!writeable)
			try
			{
				wait();
			}
			catch (InterruptedException e) {}
		this.c = c;
		writeable = false;
		notify();
	}
	synchronized char getSharedChar()
	{
		while (writeable)
			try
			{
				wait();
			}
			catch (InterruptedException e) {}
		writeable = true;
		notify();
		return c;
	}
}
class Producer extends Thread
{
	private Shared s;
	Producer(Shared s)
	{
		this.s = s;
	}
	@Override
	public void run()
	{
		for (char ch = 'A'; ch <= 'Z'; ch++)
		{
			synchronized(s)// to make sure the output displayed in order
			{
				s.setSharedChar(ch);
				System.out.println(ch + " produced by producer.");
			}
		}
	}
}
class Consumer extends Thread
{
	private Shared s;
	Consumer(Shared s)
	{
		this.s = s;
	}
	@Override
	public void run()
	{
		char ch;
		do
		{
			synchronized(s) // to make sure the output displayed in order, synced on s object
			{
				ch = s.getSharedChar();
				System.out.println(ch + " consumed by consumer.");
			}
		}
		while (ch != 'Z');
	}
}

More than 2 levels of synchronized methods or block may cause deadlock.
2 threads hold each others lock but wait for each other thread to release the lock. For example, when a thread has to hold 2 or more lock before it can proceed, ... 

......................threadlocal
Each instance of the ThreadLocal class describes a thread-local variable, which is a variable that provides a separate storage slot to each thread that accesses the variable.  You can think of a thread-local variable as a multislot variable in which each thread can store a different value in the same variable. Each thread sees only its value and is unaware of other threads having their own values in this variable.

public class ThreadLocalDemo
{
	private static volatile ThreadLocal<String> userID = new ThreadLocal<String>();
	public static void main(String[] args)
	{
			Runnable r = new Runnable()
			{
				@Override
				public void run()
				{
					String name = Thread.currentThread().getName();
					if (name.equals("A"))
						userID.set("foxtrot");
					else
						userID.set("charlie");
					System.out.println(name + " " + userID.get());
				}
			};
		Thread thdA = new Thread(r);
		thdA.setName("A");
		Thread thdB = new Thread(r);
		thdB.setName("B");
		thdA.start();
		thdB.start();
	}
}
A foxtrot
B charlie

...........Inheritable Thread Local
//After instantiating InheritableThreadLocal and assigning it to a volatile class field named intVal, the default main thread creates a parent thread, which stores an Integerobject containing 10 in intVal. The parent thread creates a child thread, which accesses intValand retrieves its parent thread.s Integerobject.

public class InheritableThreadLocalDemo
{
	private static volatile InheritableThreadLocal<Integer> intVal =
								new InheritableThreadLocal<Integer>();
	public static void main(String[] args)
	{
		Runnable rP = new Runnable()
				{
					@Override
					public void run()
					{
						intVal.set(new Integer(10));
						Runnable rC = new Runnable()
							{
								@Override
								public void run()
								{
									Thread thd;
									thd = Thread.currentThread();
									String name = thd.getName();
									System.out.println(name + " " + intVal.get());
								}
							};
						Thread thdChild = new Thread(rC);
						thdChild.setName("Child");
						thdChild.start();
					}
				};
		new Thread(rP).start();
	}
}
Child 10
...................... system class
...................... Runtime
Garbage collection in implemented in Runtime.
Runtime declares a void gc()method. System.s static void gc()method executes Runtime.getRuntime().gc();.

//Creating a sub-process to run an external program
Process exec(String program)executes the program named programin a separate native process. The new process inherits the environment of the method.s caller, and a Processobject is returned to allow communication with the new process. IOExceptionis thrown when an I/O error occurs.

ProcessBuilder is a convenient alternative for configuring process attributes and running a process. For example, Process p = new ProcessBuilder("myCommand", "myArg").start();.

int waitFor() 
Cause the calling thread to wait for the native process associated with this Process object to terminate. The process.s exit value is returned. By convention, 0 indicates normal termination. This method throws InterruptedException when the current thread is interrupted by another thread while it is waiting.

import java.io.InputStream;
import java.io.IOException;
public class Exec
{
	public static void main(String[] args)
	{
		if (args.length != 1)
		{
			System.err.println("usage: java Exec program");
			return;
		}
		try
		{
			Process p = Runtime.getRuntime().exec(args[0]);
			// Obtaining process standard output.
			InputStream is = p.getInputStream();
			int _byte;
			while ((_byte = is.read()) != -1)
				System.out.print((char) _byte);
			// Obtaining process standard error.
			is = p.getErrorStream();
			while ((_byte = is.read()) != -1)
				System.out.print((char) _byte);
			System.out.println("Exit status: " + p.waitFor());
		}
		catch (InterruptedException ie)
		{
			assert false; // should never happen
		}
		catch (IOException ioe)
		{
			System.err.println("I/O error: " + ioe.getMessage());
		}
	}
}
// To guard against confusion, remember that Process.s getInputStream()method is used to read bytes that the new process writes to its output stream, whereas Process.s getErrorStream() method is used to read bytes that the new process writes to its error stream.
...................... collection
Comparable interface and Comparator interface
"Comparable's" compareTo()method
A sorted collection uses "compareTo()"to determine the natural ordering of this method.s element argument oin a collection.
It returns a negative value when the current element should precede    o.
It returns a zero value when the current element and o are the same.
It returns a positive value when the current element should succeed    o.

compareTo() must be reflexive: 
For any nonnull reference value x, x.compareTo(x) must return 0.  

 compareTo() must be symmetric: 
For any nonnull reference values xand y, x.compareTo(y) == -y.compareTo(x)must hold.

 compareTo() must be transitive: 
For any nonnull reference values x, y, and z, if x.compareTo(y) > 0is true, and if y.compareTo(z) > 0is true, then x.compareTo(z) > 0must also be true.


A "comparator" is an object whose class implements the Comparator interface. This interface, whose generic type is Comparator<T>, provides the following pair of methods:

 int compare(T o1, T o2)compares both arguments for order. This method returns 0 when o1equals o2, a negative value when o1is less than o2, and a positive value when o1is greater than o2.

 boolean equals(Object o)returns true when o.equals. this Comparatorin that ois also a Comparatorand imposes the same ordering. Otherwise, this method returns false.

...................... iterator
String[] verbs = { "run", "walk", "jump" }; 
for (String verb: verbs) 
	System.out.println (verb);
......................Autoboxing and Unboxing
Autoboxing automatically boxes(wraps) a primitive-type value in an object of the appropriate primitive type wrapper class whenever a primitive-type value is specified but a reference is required. 

Unboxing automatically unboxes(unwraps) a primitive-type value from its wrapper object whenever a reference is specified but a primitive-type value is required. 

Don.t assume that autoboxing and unboxing are used in the context of the ==and != operators.

......................ArrayList, fast to read, slow to delete or insert
The ArrayList class provides a list implementation that is based on an internal array. As a result, access to the list.s elements is fast. However, because elements must be moved to open a space for insertion or to close a space after deletion, insertions and deletions of elements is slow.

ArrayList supplies three constructors:
 ArrayList()creates an empty array list with an initial capacity(storage space) of 10 elements. Once this capacity is reached, a larger array is allocated, elements from the current array are copied into the larger array, and the larger array becomes the new current array. This process repeats as additional elements are added to the array list.

 ArrayList(Collection<? extends E> c)creates an array list containing c.s elements in the order in which they are returned by c.s iterator.  NullPointerExceptionis thrown when ccontains the null reference.

 ArrayList(int initialCapacity)creates an empty array list with an initial 
capacity of initialCapacityelements. IllegalArgumentExceptionis thrown 
when initialCapacityis negative.

......................LinkedList, slow to traverse, fast to delete and insert, just updating the link 
A nodeis a fixed sequence of value and link memory locations. Unlike an array, where each slot stores a single value of the same primitive type or reference supertype, a node can store multiple values of different types. It can also store links (references to other nodes).

LinkedListsupplies two constructors:
 LinkedList()creates an empty linked list.

 LinkedList(Collection<? extends E> c)creates a linked list containing c.s elements in the order in which they are returned by c.s iterator.  NullPointerExceptionis thrown when ccontains the null reference.

......................set
A set is a collection that contains no duplicate elements. 

...........TreeSet
The TreeSetclass provides a set implementation that is based on a tree data structure. As a result, elements are stored in sorted order. 

import java.util.Set;
import java.util.TreeSet;
public class TreeSetDemo
{
	public static void main(String[] args)
	{
		Set<String> ss = new TreeSet<String>();
		String[] fruits = {"apples", "pears", "grapes", "bananas", "kiwis"};
		for (String fruit: fruits)
			ss.add(fruit); //automatically sorted
		dump("ss:", ss);
	}
	static void dump(String title, Set<String> ss)
	{
		System.out.print(title + " ");
		for (String s: ss)
			System.out.print(s + " ");
		System.out.println();
	}
}
ss: apples bananas grapes kiwis pears
...........HashSet, basically, key and value pairs
The HashSetclass provides a set implementation that is backed by a hashtable data structure (implemented as a HashMapinstance, discussed later, which provides a quick way to determine if an element has already been stored in this structure). Although this class provides no ordering guarantees for its elements, HashSetis much faster than TreeSet. Furthermore, HashSetpermits the null reference to be stored in its instances.
Suppose you want to add instances of your classes to a hashset. As with String, your classes must override equals()and hashCode(); otherwise, duplicate class instances can be stored in the hashset.  
import java.util.HashSet;
import java.util.Set;
public class CustomClassAndHashSet
{
	public static void main(String[] args)
	{
		Set<Planet> sp = new HashSet<Planet>();
		sp.add(new Planet("Mercury"));
		sp.add(new Planet("Venus"));
		sp.add(new Planet("Earth"));
		sp.add(new Planet("Mars"));
		sp.add(new Planet("Jupiter"));
		sp.add(new Planet("Saturn"));
		sp.add(new Planet("Uranus"));
		sp.add(new Planet("Neptune"));
		sp.add(new Planet("Fomalhaut b"));
		Planet p1 = new Planet("51 Pegasi b");
		sp.add(p1);
		Planet p2 = new Planet("51 Pegasi b");
		sp.add(p2);
		System.out.println(p1.equals(p2));
		System.out.println(sp);
	}
}
class Planet
{
	private String name;
	Planet(String name) {
		this.name = name;
	}
	@Override
	public boolean equals(Object o)
	{
		if (!(o instanceof Planet))
			return false;
		Planet p = (Planet) o;
		return p.name.equals(name);
	}
	String getName() {
		return name;
	}
	@Override
	public int hashCode() { // with this and the equals, duplicate item can not be added in
		return name.hashCode();
	}
	@Override
	public String toString() {
		return name;
	}
}
...........LinkedHashSet
LinkedHashSet is a subclass of HashSetthat uses a linked list to store its elements. As a result, LinkedHashSet.s iterator returns elements in the order in which they were inserted. For example, if Listing 9-4 had specified Set<String> ss = new LinkedHashSet<String>();, the application.s output would have been ss: apples pears grapes bananas kiwis null. Also, LinkedHashSetoffers slower performance than HashSetand faster performance than TreeSet.
...........EnumSet
An int-based bitset cannot contain more than 32 members because int has a size of 32 bits.  Similarly, a long-based bitset cannot contain more than 64 members because long has a size of 64 bits.

This bitset is formed by bitwise inclusive ORing the traditional enumerated type.s integer constants together via the bitwise inclusive OR operator (|): you could also use +. Each constant must be a unique power of two (starting with one) because otherwise it.s impossible to distinguish between the members of this bitset.
import java.util.EnumSet;
import java.util.Iterator;
import java.util.Set;
enum Weekday
{
	SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY
}
public class EnumSetDemo
{
	public static void main(String[] args)
	{
		Set<Weekday> daysOff = EnumSet.of(Weekday.SUNDAY, Weekday.MONDAY);
		Iterator<Weekday> iter = daysOff.iterator(); 
		while (iter.hasNext()) //to go through the set
			System.out.println(iter.next());
	}
}
......................Sorted Sets
TreeSet is an example of a sorted set, which is a set that maintains its elements in ascending order, sorted according to their natural ordering or according to a comparator that is supplied when the sorted set is created. Sorted sets are described by the SortedSetinterface.

SortedSet, whose generic type is SortedSet<E>, extends Set. With two exceptions, the methods it inherits from Setbehave identically on sorted sets as on other sets:

The  Iterator instance returned from iterator()traverses the sorted set in ascending element order.

The array returned by   toArray()contains the sorted set.s elements in order.

Although not guaranteed, the toString()methods of SortedSetimplementations in the Collections Framework (e.g., TreeSet) return a string containing all of the sorted set.s elements in order.

The set-based range views returned from headSet(), subSet(), and tailSet()are analogous to the list-based range view returned from List.s subList()method except that a set-based range view remains valid even when the backing sorted set is modified. As a result, a set-based range view can be used for a lengthy period of time.
In range view, normally from is inclusive, to is exclusive.

Each range view returned by headSet(), subSet(), or tailSet()is half openbecause it doesn.t include its high endpoint (headSet()and subSet()) or its low endpoint (tailSet()). For the first two methods, the high endpoint is specified by argument toElement; for the last method, the low endpoint is specified by argument fromElement.

dump("hs:", sss.headSet("n")); // to get all element before "n", for example, neck
dump("ts:", sss.tailSet("n")); //to get all element after "n"
System.out.println("Count of p-named fruits & vegetables = " + sss.subSet("p", "q").size()); // between "p" and "q", eg. plume

With Stringobjects, you accomplish this task by appending \0 to the string. 
For example, ss.subSet("carrot", "cucumber\0")includes cucumber because it is less than cucumber\0.
For example, ss.subSet("carrot\0", "cucumber")doesn.t include carrotbecause it is less than carrot\0. 


when designing classes that work with sorted sets, the class must implement Comparable when you plan to store the class.s instances in a sorted set where these elements are sorted according to their natural ordering.


import java.util.SortedSet;
import java.util.TreeSet;
public class CustomClassAndSortedSet
{
	public static void main(String[] args)
	{
		SortedSet<Employee> sse = new TreeSet<Employee>();
		sse.add(new Employee("Sally Doe"));
		sse.add(new Employee("Bob Doe"));
		Employee e1 = new Employee("John Doe");
		Employee e2 = new Employee("John Doe");
		sse.add(e1);
		sse.add(e2);
		System.out.println(sse);
		System.out.println(e1.equals(e2)); // need the overriding equals method
	}
}
class Employee implements Comparable<Employee> // implement Comparable is needed to work as sortedSet
{
	private String name;
	Employee(String name)
	{
		this.name = name;
	}
	@Override
	public int compareTo(Employee e) // to use as sortedSet
	{
		return name.compareTo(e.name);
	}
	@Override
	public boolean equals(Object o) // need to implement to make the equals works
	{
		if (!(o instanceof Employee))
			return false;
		Employee e = (Employee) o;
		return e.name.equals(name);
	}
	@Override
	public String toString()
	{
		return name;
	}
}
[Bob Doe, John Doe, Sally Doe]
true
...................... Navigable Sets
TreeSetis an example of a navigable set, which is a sorted set that can be iterated over in descending order as well as ascending order and which can report closest matches for given search targets. Navigable sets are described by the NavigableSetinterface, whose generic type is NavigableSet<E>, which extends SortedSet
sorted and with methods to find all kind of nodes in it.
......................Queues
FIFO
LIFO
Priority queue: sorted before insert
Elements are inserted according to their natural ordering or according to a comparator that is supplied to the queue implementation.

The offer() method is generally preferable to add()when using a capacity-restricted queue because offer()doesn.t throw IllegalStateException.
...........PriorityQueue
The PriorityQueue class provides an implementation of a priority queue, which is a queue that orders its elements according to their natural ordering or by a comparator provided when the queue is instantiated. Priority queues don.t permit null elements and don.t permit insertion of non-Comparableobjects when relying on natural ordering.

The default is min -> max. To reverse it:
import java.util.Comparator;
import java.util.PriorityQueue;
import java.util.Queue;
public class PriorityQueueDemo
{
	final static int NELEM = 15; // number of elements
	public static void main(String[] args)
	{
		Comparator<Integer> cmp;
		cmp = new Comparator<Integer>() //define a new Comparator
				{
					@Override
					public int compare(Integer e1, Integer e2)
					{
						return e2 - e1;
					}
				};
		Queue<Integer> qi = new PriorityQueue<Integer>(NELEM, cmp); //use the new Comparator  
		for (int i = 0; i < NELEM; i++)
			qi.add((int) (Math.random() * 100));
		while (!qi.isEmpty())
			System.out.print(qi.poll() + " ");
		System.out.println();
	}
}
97 72 70 70 67 64 56 43 36 22 9 5 3 2 1
...........Deques
A deque(pronounced deck) is a double-ended queue in which element insertion or removal occurs at its heador tail. Deques can be used as queues or stacks.
...........ArrayDeque
The ArrayDeque class provides a resizable-array implementation of the Deque interface. It prohibits null elements from being added to a deque, and its iterator()method returns fail-fast iterators.
import java.util.ArrayDeque;
import java.util.Deque;
public class ArrayDequeDemo
{
	public static void main(String[] args)
	{
		Deque<String> stack = new ArrayDeque<String>();
		String[] weekdays = { "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" };
		for (String weekday: weekdays)
			stack.push(weekday); // push in the head
		while (stack.peek() != null)
			System.out.println(stack.pop());// pop from the head, so, LIFO
	}
}
Saturday
Friday
Thursday
Wednesday
Tuesday
Monday
Sunday
...................... maps
A mapis a group of key/value pairs (also known as entries).

enum Color
{
	RED(255, 0, 0),
	GREEN(0, 255, 0),
	BLUE(0, 0, 255);
	private int r, g, b;
	private Color(int r, int g, int b)
	{
		this.r = r;
		this.g = g;
		this.b = b;
	}
	@Override
	public String toString()
	{
		return "r = " + r + ", g = " + g + ", b = " + b;
	}
}
Map<String, Color> colorMap = . . .; // . . . represents the creation of a Map implementation
colorMap.put("red", Color.RED);
colorMap.put("blue", Color.BLUE);
colorMap.put("green", Color.GREEN);
colorMap.put("RED", Color.RED);
for (String colorKey: colorMap.keySet())
	System.out.println(colorKey);
Collection<Color> colorValues = colorMap.values();
for (Iterator<Color> it = colorValues.iterator(); it.hasNext();)
	System.out.println(it.next());

red
blue
green
RED
r = 255, g = 0, b = 0
r = 0, g = 0, b = 255
r = 0, g = 255, b = 0
r = 255, g = 0, b = 0

for (Map.Entry<String, Color> colorEntry: colorMap.entrySet())
	System.out.println(colorEntry.getKey() + ": " + colorEntry.getValue());

red: r = 255, g = 0, b = 0
blue: r = 0, g = 0, b = 255
green: r = 0, g = 255, b = 0
RED: r = 255, g = 0, b = 0
...........TreeMap
The TreeMapclass provides a map implementation that is based on a red-black tree. As a result, entries are stored in "sorted order of their keys". However, accessing these entries is somewhat slower than with the other Mapimplementations (which are not sorted) because links must be traversed. Sorted based on key.

The self-balancing is provided by painting each node with one of two colors (these are typically called 'red' and 'black', hence the name of the trees) in such a way that the resulting painted tree satisfies certain properties that don't allow it to become significantly unbalanced. When the tree is modified, the new tree is subsequently rearranged and repainted to restore the coloring properties. 

The balancing of the tree is not perfect but it is good enough to allow it to guarantee searching in O(log n) time, where n is the total number of elements in the tree. The insertion, and deletion operations, along with the tree rearrangement and recoloring are also performed in O(log n) time.

import java.util.Map;
import java.util.TreeMap;
public class TreeMapDemo
{
	public static void main(String[] args)
	{
		Map<String, Integer> msi = new TreeMap<String, Integer>();
		String[] fruits = {"apples", "pears", "grapes", "bananas", "kiwis"};
		int[] quantities = {10, 15, 8, 17, 30};
		for (int i = 0; i < fruits.length; i++)
			msi.put(fruits[i], quantities[i]);
		for (Map.Entry<String, Integer> entry: msi.entrySet())
			System.out.println(entry.getKey() + ": " + entry.getValue());
	}
}
apples: 10
bananas: 17
grapes: 8
kiwis: 30
pears: 15
........... HashMap, trying to use key's hashcode to identify the value location?
The HashMapclass provides a map implementation that is based on a hashtable data structure.  This implementation supports all Mapoperations and permits null keys and null values. It makes no guarantees on the order in which entries are stored.
A hashtable maps keys to integer values with the help of a hash function. 
A hash codeidentifies one of the hashtable.s array elements, which is known as a bucket or slot. Bucket is a place to store the value.

A perfect hash function hashes each key to a unique integer value. However, this ideal is very difficult to meet. In practice, some keys will hash to the same integer value.  This nonunique mapping is referred to as a collision.

To address collisions, most hashtables associate a linked list of entries with a bucket. Instead of containing a value, the bucket contains the address of the first node in the linked list, and each node contains one of the colliding entries.

The bucket does not contain the final value, but contain the head address of a linked list, which contain the key:value pairs in the nodes. 

The number of buckets is known as the hashtable.s "capacity". The ratio of the number of stored entries divided by the number of buckets is known as the hashtable.s "load factor".  n/k where n is the number of entries and k is the number of buckets.

As the load factor approaches 1, the probability of collisions and the cost of handling them (by searching lengthy linked lists) increase.

As the load factor approaches 0, the hashtable.s size in terms of number of  buckets increases with little improvement in search cost.

For many hashtables, a load factor of 0.75 is close to optimal. This value is the   default for HashMap.s hashtable implementation. entries a bit less than number of buckets.

//Using a Hashmap to Count Command-Line Arguments
import java.util.HashMap;
import java.util.Map;
public class HashMapDemo
{
	public static void main(String[] args)
	{
		Map<String, Integer> argMap = new HashMap<String, Integer>();
		for (String arg: args)
		{
			Integer count = argMap.get(arg); // if does not exist, count = null
			argMap.put(arg, (count == null) ? 1 : count + 1);
		}
		System.out.println(argMap);
		System.out.println("Number of distinct arguments = " + argMap.size());
	}
}
........... LinkedHashMap
LinkedHashMap is a subclass of HashMapthat uses a linked list to store its entries. As a result, LinkedHashMap.s iterator returns entries in the order in which they were inserted. 
...........IdentityHashMap
The IdentityHashMap class provides a Mapimplementation that uses reference equality (==) instead of object equality (equals()) when comparing keys and values. 

IdentityHashMap obtains hash codes via System.s int identityHashCode(Object x)class method instead of via each key.s hashCode()method. identityHashCode()returns the same hash code for x as returned by Object.s hashCode()method, whether or not x.s class overrides hashCode(). The hash code for the null reference is zero.

These characteristics give IdentityHashMapa performance advantage over other Map implementations. Also, IdentityHashMapsupports mutable keys(objects used as keys and whose hash codes change when their field values change while in the map).


//Contrasting IdentityHashMap with HashMapin a Mutable Key Context
import java.util.IdentityHashMap;
import java.util.HashMap;
import java.util.Map;
public class IdentityHashMapDemo
{
	public static void main(String[] args)
	{
		Map<Employee, String> map1 = new IdentityHashMap<Employee, String>();
		Map<Employee, String> map2 = new HashMap<Employee, String>();
		Employee e1 = new Employee("John Doe", 28);
		map1.put(e1, "SALES");
		System.out.println(map1);
		Employee e2 = new Employee("Jane Doe", 26);
		map2.put(e2, "MGMT");
		System.out.println(map2);
		System.out.println("map1 contains key e1 = " + map1.containsKey(e1));
		System.out.println("map2 contains key e2 = " + map2.containsKey(e2));
		e1.setAge(29); //e1 updated, IdentityHasMap still considers it as key, since used only reference
		e2.setAge(27); // HashMap still use the old e2 as key 
		System.out.println(map1);
		System.out.println(map2);
		System.out.println("map1 contains key e1 = " + map1.containsKey(e1));
		System.out.println("map2 contains key e2 = " + map2.containsKey(e2));
	}
}
class Employee
{
	private String name;
	private int age;
	Employee(String name, int age) {
		this.name = name;
		this.age = age;
	}
	@Override
	public boolean equals(Object o) {
		if (!(o instanceof Employee))
			return false;
		Employee e = (Employee) o;
		return e.name.equals(name) && e.age == age;
	}
	@Override
	public int hashCode() { //hashCode implementation for int
		int hashCode = 19;
		hashCode = hashCode * 31 + name.hashCode();
		hashCode = hashCode * 31 + age;
		return hashCode;
	}
	void setAge(int age) {
		this.age = age;
	}
	void setName(String name) {
		this.name = name;
	}
	@Override
	public String toString() {
		return name + " " + age;
	}
}
{John Doe 28=SALES}
{Jane Doe 26=MGMT}
map1 contains key e1 = true
map2 contains key e2 = true
{John Doe 29=SALES}
{Jane Doe 27=MGMT}
map1 contains key e1 = true
map2 contains key e2 = false


IdentityHashMap.s documentation states that .a typical use of this class is topology-preserving object graph transformations, such as serialization or deep copying.. (I discuss serialization in Chapter 11.) It also states that .another typical use of this class is to maintain proxy objects.. Also, stackoverflow.s .Use Cases for Identity HashMap. topic (http://stackoverflow.com/questions/838528/ use-cases-for-identity-hashmap)) mentions that it is much faster to use IdentityHashMap than HashMap when the keys are java.lang.Classobjects.
...........EnumMap
The EnumMapclass provides a Mapimplementation whose keys are the members of the same enum. Null keys are not permitted; any attempt to store a null key results in a thrown NullPointerException. Because an enum map is represented internally as an array, an enum map approaches an array in terms of performance.
import java.util.EnumMap;
import java.util.Map;
enum Coin
{
	PENNY, NICKEL, DIME, QUARTER
}
public class EnumMapDemo
{
	public static void main(String[] args)
	{
		Map<Coin, Integer> map = new EnumMap<Coin, Integer>(Coin.class);
		map.put(Coin.PENNY, 1);
		map.put(Coin.NICKEL, 5);
		map.put(Coin.DIME, 10);
		map.put(Coin.QUARTER, 25);
		System.out.println(map);
		Map<Coin,Integer> mapCopy = new EnumMap<Coin, Integer>(map);
		System.out.println(mapCopy);
	}
}
{PENNY=1, NICKEL=5, DIME=10, QUARTER=25}
{PENNY=1, NICKEL=5, DIME=10, QUARTER=25}

//A Sorted Map of Office Supply Names and Quantities
import java.util.Comparator;
import java.util.SortedMap;
import java.util.TreeMap;
public class SortedMapDemo
{
	public static void main(String[] args)
	{
		SortedMap<String, Integer> smsi = new TreeMap<String, Integer>();
		String[] officeSupplies =
		{
			"pen", "pencil", "legal pad", "CD", "paper"
		};
		int[] quantities =
		{
			20, 30, 5, 10, 20
		};
		for (int i = 0; i < officeSupplies.length; i++)
			smsi.put(officeSupplies[i], quantities[i]);
		System.out.println(smsi);
		System.out.println(smsi.headMap("pencil"));
		System.out.println(smsi.headMap("paper"));
		SortedMap<String, Integer> smsiCopy;
		Comparator<String> cmp;
		cmp = new Comparator<String>()//create a new Comparator to change the order
		{
			@Override
			public int compare(String key1, String key2)
			{
				return key2.compareTo(key1); // descending order
			}
		};
		smsiCopy = new TreeMap<String, Integer>(cmp);
		smsiCopy.putAll(smsi);
		System.out.println(smsiCopy);
	}
}
{CD=10, legal pad=5, paper=20, pen=20, pencil=30}
{CD=10, legal pad=5, paper=20, pen=20}
{CD=10, legal pad=5}
{pencil=30, pen=20, paper=20, legal pad=5, CD=10}
...........Navigable Maps
TreeMap is an example of a navigable map, which is a sorted map that can be iterated over in descending order as well as ascending order and which can report closest matches for given search targets. Navigable maps are described by the NavigableMap interface, whose generic type is NavigableMap<K,V>, which extends SortedMap
......................the Arrays and Collections Utility APIs
arrays keep all the data in a contiguous chunk of memory (unlike Lists). List interface provides more flexibility.

static <T> List<T> asList(T. . . a)returns a fixed-size list backed by array a.  (Changes to the returned list .write through. to the array.) For example, List<String> birds = Arrays.asList("Robin", "Oriole", "Bluejay"); converts the three-element array of Strings (recall that a variable sequence of arguments is implemented as an array) to a Listwhose reference is assigned to birds.

static int binarySearch(int[] a, int key)searches array afor entry key using the binary search algorithm (explained following this list). The array must be sorted before calling this method; otherwise, the results are undefined.  This method returns the index of the search key, if it is contained in the array; otherwise (-(insertion point) - 1) is returned.

static void fill(char[] a, char ch)stores chin each element of the specified character array.

static void sort(long[] a)sorts the elements in the long integer array a into ascending numerical order,

static <T> void sort(T[] a, Comparator<? super T> c)sorts the elements in array ausing comparator c to order them.

...........binary search

There are two common algorithms for searching an array for a specific element.  "Linear search" searches the array element by element from index 0 to the index of the searched-for element or the end of the array. On average, half of the elements must be searched; larger arrays take longer to search. However, the arrays don.t need to be sorted.

In contrast, binary searchsearches ordered array a.s nitems for element ein a much faster amount of time. It works by recursively performing the following steps:
1.  Set low index to 0.
2.  Set high index to n- 1.
3.  If low index > high index, then Print .Unable to find . e. End.
4.  Set middle index to (low index + high index) / 2.
5.  If e> a[middle index], then set low index to middle index + 1. Go to 3.
6.  If e< a[middle index], then set high index to middle index - 1. Go to 3.
7.  Print .Found . e.at index . middle index.

Time complexity O(log(n)) ?

The algorithm is similar to optimally looking for a name in a phone book.
Applying a linear search to 4,000,000,000 elements results in approximately 2,000,000,000 comparisons (on average), which takes time. In contrast, applying binary search to 4,000,000,000 elements performs a maximum of 32 comparisons.

...........Collection methods
static <T> List<T> singletonList(T o)returns an immutable list containing only object o. For example, 
list.removeAll(Collections.singletonList(null)); 
removes all null elements from list.

static <T> Set<T> synchronizedSet(Set<T> s)returns a synchronized (thread-safe) set backed by the specified set s, for example, Set<String> ss = Collections.synchronizedSet(new HashSet<String>());. To guarantee serial access, it.s critical that all access to the backing set (s) is accomplished through the returned set.

You might be wondering about the purpose for the various .empty. class methods in the Collections class. For example, static final <T> List<T> emptyList()returns an immutable empty list, as in List<String> ls = Collections.emptyList();. These methods are present because they offer a useful alternative to returning null (and avoiding potential NullPointerExceptions) in certain contexts.

//Empty and Nonempty Lists of Birds
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
class Birds
{
	private List<String> birds;
	Birds()
	{
		birds = Collections.emptyList();//to prevent NullPointerException in toString() method
	}
	Birds(String. . . birdNames)
	{
		birds = new ArrayList<String>();
		for (String birdName: birdNames)
			birds.add(birdName);
	}
	@Override
	public String toString()
	{
		return birds.toString(); 
	}
}
class EmptyListDemo
{
	public static void main(String[] args)
	{
		Birds birds = new Birds();
		System.out.println(birds);
		birds = new Birds("Swallow", "Robin", "Bluejay", "Oriole");
		System.out.println(birds);
	}
}
[]
[Swallow, Robin, Bluejay, Oriole]
......................BitSet
BitSet is a concrete class that describes a variable-length set of bits.  This class.s ability to represent bitsets of arbitrary length contrasts with the previously described integer-based, fixed-length bitset that is limited to a maximum number of members: 32 members for an int-based bitset or 64 members for a long-based bitset.

//Working with Variable-Length Bitsets
import java.util.BitSet;
public class BitSetDemo
{
	public static void main(String[] args)
	{
		BitSet bs1 = new BitSet();
		bs1.set(4, true);
		bs1.set(5, true);
		bs1.set(9, true);
		bs1.set(10, true);
		BitSet bsTemp = (BitSet) bs1.clone();//create a new one not just a reference
		dumpBitset(" ", bs1);
		BitSet bs2 = new BitSet();
		bs2.set(4, true);
		bs2.set(6, true);
		bs2.set(7, true);
		bs2.set(9, true);
		dumpBitset(" ", bs2);
		bs1.and(bs2);
		dumpSeparator(Math.min(bs1.size(), 16));
		dumpBitset("AND (&) ", bs1);
		System.out.println();
		bs1 = bsTemp;
		dumpBitset(" ", bs1);
		dumpBitset(" ", bs2);
		bsTemp = (BitSet) bs1.clone();
		bs1.or(bs2);
		dumpSeparator(Math.min(bs1.size(), 16));
		dumpBitset("OR (|) ", bs1);
		System.out.println();
		bs1 = bsTemp;
		dumpBitset(" ", bs1);
		dumpBitset(" ", bs2);
		bsTemp = (BitSet) bs1.clone();
		bs1.xor(bs2);
		dumpSeparator(Math.min(bs1.size(), 16));
		dumpBitset("XOR (^) ", bs1);
	}
	static void dumpBitset(String preamble, BitSet bs)
	{
		System.out.print(preamble);
		int size = Math.min(bs.size(), 16);//to make it fix lenth, if less, fill with 0
		for (int i = 0; i < size; i++)
		System.out.print(bs.get(i) ? "1" : "0");
		System.out.print(" size(" + bs.size() + "), length(" + bs.length() + ")");
		System.out.println();
	}
	static void dumpSeparator(int len)//to print the -----
	{
		System.out.print(" ");
		for (int i = 0; i < len; i++)
			System.out.print("-");
		System.out.println();
	}
}
		0000110001100000 size(64), length(11)
		0000101101000000 size(64), length(10)
----------------
AND (&) 0000100001000000 size(64), length(10)
		0000110001100000 size(64), length(11)
		0000101101000000 size(64), length(10)
----------------
OR (|)  0000111101100000 size(64), length(11)
		0000110001100000 size(64), length(11)
		0000101101000000 size(64), length(10)
----------------
XOR (^) 0000011100100000 size(64), length(11)

......................Concurrency Utilities
These utilities leverage the low-level Threads API (see Chapter 8) in their implementations and provide higher-level building blocks (such as locking idioms) to make it easier to create multithreaded applications. They are organized into executor, synchronizer, concurrent collection, lock, and atomic variable categories.

A taskis an object whose class implements the java.lang.Runnable interface (a runnable task) or the java.util.concurrent.Callable interface (a callable task).
...........Executors
The concurrency-oriented utilities provide executors as a high-level alternative to low-level Threads API expressions for executing runnable tasks. An executoris an object whose class directly or indirectly implements the java.util.concurrent.Executorinterface, which decouples task submission from task-execution mechanics.
Executor declares a solitary void execute(Runnable runnable)method that executes the runnable task named runnableat some point in the future. 

RejectedExecutionException can be thrown when an executor is shutting down and doesn.t want to accept new tasks. Also, this exception can be thrown when the executor doesn.t have enough room to store the task (perhaps the executor uses a bounded blocking queue to store tasks and the queue is full.

Executor executor = ...; // ... represents some executor creation
executor.execute(new RunnableTask());

"Limitation"
1. Executor focuses exclusively on Runnable. Because Runnable.s run()method doesn.t return a value, there is no convenient way for a runnable task to return a value to its caller. Hard to get a retrun value.

2. Executor doesn.t provide a way to track the progress of executing runnable tasks, cancel an executing runnable task, or determine when the runnable task finishes execution. //once running, off the hook

3. Executor cannot execute a collection of runnable tasks.

4. Executordoesn.t provide a way for an application to shut down an executor (much less to properly shut down an executor).

These limitations are addressed by the java.util.concurrent.ExecutorService interface, which extends Executorand whose implementation is typically a thread pool.

"Callable tasks", which are analogous to runnable tasks. Unlike Runnable, whose void run()method cannot throw checked exceptions, Callable<V>declares a V call() method that returns a value and which can throw checked exceptions because call()is declared with a throws Exceptionclause.

The java.util.concurrent.ScheduledExecutorService interface extends ExecutorService and describes an executor that lets you schedule tasks to run once or to execute periodically after a given delay.

Thread pools are used to eliminate the overhead from having to create a new thread for each submitted task. Thread creation is not cheap, and having to create many threads could severely impact an application.s performance.
.............Synchronizers 
Four commonly used synchronizers are countdown latches, cyclic barriers, exchangers, and semaphores:

A "countdown latch" lets one or more threads wait at a .gate. until another thread opens this gate, at which point these other threads can continue.
Consider the CountDownLatch class. Each of its instances is initialized to a nonzero count. A thread calls one of CountDownLatch.s await() methods to block until the count reaches zero. Another thread calls CountDownLatch.s countDown()method to decrement the count. Once the count reaches zero, the waiting threads are allowed to continue.
After waiting threads are released, subsequent calls to await()return immediately. Also, because the count cannot be reset, a CountDownLatch instance can be used only once.  When repeated use is a requirement, use the CyclicBarrier class instead.

A  "cyclic barrier" lets a group of threads wait for each other to reach a common barrier point.  CyclicBarrierinstances are useful in applications involving fixed size parties of threads that must occasionally wait for each other. CyclicBarriersupports an optional Runnable known as a barrier action, which runs once per barrier point after the last thread in the party arrives but before any threads are released. This barrier action is useful for updating shared state before any of the parties continue.

An  "exchanger" lets a pair of threads exchange objects at a synchronization point. Each thread presents some object on entry to Exchanger.s exchange()method, matches with a partner thread, and receives its partner.s object on return.  Exchangers may be useful in applications such as genetic algorithms(see http://en.wikipedia.org/wiki/Genetic_algorithm) and pipeline designs.

A  "semaphore" maintains a set of permits for restricting the number of threads that can access a limited resource.  Each call to one of Semaphore.s acquire() methods blocks if necessary until a permit is available and then takes it.  Each call to release()returns a permit, potentially releasing a blocking acquirer.  However, no actual permit objects are used; the Semaphoreinstance only keeps a count of the number of available permits and acts accordingly. Semaphores are often used to restrict the number of threads that can access some (physical or logical) resource.

//Using a Countdown Latch to Trigger a Coordinated Start
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
public class CountDownLatchDemo
{
	final static int NTHREADS = 3;
	public static void main(String[] args)
	{
		final CountDownLatch startSignal = new CountDownLatch(1); //to control child
		final CountDownLatch doneSignal = new CountDownLatch(NTHREADS);//to control main thread
		Runnable r = new Runnable()
		{
			@Override
			public void run()
			{
				try
				{
					report("entered run()");
					startSignal.await(); //3 children wait for the same latch.
					report("doing work");
					Thread.sleep((int) (Math.random() * 1000));
					doneSignal.countDown(); // reduce count on which
					// main thread is waiting, reach 0 when all children finish
				}
				catch (InterruptedException ie)
				{
					System.err.println(ie);
				}
			}
			void report(String s)
			{
				System.out.println(System.currentTimeMillis() + ": " +
				Thread.currentThread() + ": " + s);
			}
		};
		ExecutorService executor = Executors.newFixedThreadPool(NTHREADS);
		for (int i = 0; i < NTHREADS; i++)
			executor.execute(r);
		try
		{
			System.out.println("main thread doing something");
			Thread.sleep(1000); 
			startSignal.countDown(); // let all threads proceed
			System.out.println("main thread doing something else");
			doneSignal.await(); //main wait for all children threads to finish
			executor.shutdownNow();
		}
		catch (InterruptedException ie)
		{
			System.err.println(ie);
		}
	}
}
main thread doing something
1353265795934: Thread[pool-1-thread-3,5,main]: entered run()
1353265795934: Thread[pool-1-thread-2,5,main]: entered run()
1353265795934: Thread[pool-1-thread-1,5,main]: entered run()
main thread doing something else
1353265796948: Thread[pool-1-thread-1,5,main]: doing work
1353265796948: Thread[pool-1-thread-2,5,main]: doing work
1353265796948: Thread[pool-1-thread-3,5,main]: doing work

...................... Concurrent Collections
"BlockingDeque" is a subinterface of BlockingQueue and java.util.Dequethat also supports blocking operations that wait for the deque to become nonempty before retrieving an element and wait for space to become available in the deque before storing an element. The LinkedBlockingDeque class implements this interface.

"BlockingQueue" is a subinterface of java.util.Queue that also supports blocking operations that wait for the queue to become nonempty before retrieving an element and wait for space to become available in the queue before storing an element. 

"ConcurrentMap" is a subinterface of java.util.Mapthat declares additional atomic putIfAbsent(), remove(), and replace() methods. 

"ConcurrentNavigableMap" is a subinterface of ConcurrentMap and java.util.  NavigableMap.

"ConcurrentLinkedQueue" is an unbounded, thread-safe FIFO implementation of the Queueinterface.

"ConcurrentSkipListSet" is a scalable concurrent NavigableSetimplementation.

"CopyOnWriteArrayList" is a thread-safe variant of java.util.ArrayListin which all mutative(nonimmutable) operations (add, set, and so on) are implemented by making a fresh copy of the underlying array.

"CopyOnWriteArraySet" is a java.util.Setimplementation that uses an internal CopyOnWriteArrayListinstance for all its operations.

//Listing 10-3.The Blocking Queue Equivalent of Listing 8-14.s PCApplication
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
public class PC
{
	public static void main(String[] args)
	{
		final BlockingQueue<Character> bq; //BlockingQueue makes sure no 
										   //take/remove when no items avaialbe
		bq = new ArrayBlockingQueue<Character>(26);
		final ExecutorService executor = Executors.newFixedThreadPool(2);
		Runnable producer;
		producer = new Runnable()
		{
			@Override
			public void run()
			{
				for (char ch = 'A'; ch <= 'Z'; ch++)
				{
					try
					{
						bq.put(ch);
						System.out.println(ch + " produced by producer.");
					}
					catch (InterruptedException ie)
					{
						assert false;
					}
				}
			}
		};
		executor.execute(producer);
		Runnable consumer;
		consumer = new Runnable()
		{
			@Override
			public void run()
			{
				char ch = '\0';
				do
				{
					try
					{
						ch = bq.take();
						System.out.println(ch + " consumed by consumer.");
					}
					catch (InterruptedException ie)
					{
						assert false;
					}
				}
				while (ch != 'Z');
				executor.shutdownNow();
			}
		};
		executor.execute(consumer);
	}
}
Y consumed by consumer.//output still can be out of order
Y produced by producer.
Z consumed by consumer.
Z produced by producer.
//It uses BlockingQueue.s put()and take()methods, respectively, to put an object on the blocking queue and to remove an object from the blocking queue. put()blocks when there is no room to put an object; take()blocks when the queue is empty.
......................lock
This package.s most basic lock interface is Lock, which provides more extensive locking operations than can be achieved via the synchronizedreserved word. Lockalso supports a wait/notification mechanism through associated Conditionobjects.
The biggest advantage of Lock objects over the implicit locks that are obtained when threads enter critical sections (controlled via the synchronized reserved word) is their ability to back out of an attempt to acquire a lock. For example, the tryLock()method backs out when the lock is not available immediately or before a timeout expires (if specified). Also, the lockInterruptibly() method backs out when another thread sends an interrupt before the lock is acquired.
"ReentrantLock" implements Lock, describing a reentrant mutual exclusion Lock implementation with the same basic behavior and semantics as the implicit monitor lock accessed via synchronized but with extended capabilities.

//Listing 10-4 uses Lock.s lock()and unlock() methods to obtain and release a lock. When a thread calls lock()and the lock is unavailable, the thread is disabled (and cannot be scheduled) until the lock becomes available.  
//This listing also uses BlockingQueue.s offer() method instead of put()to store an object in the blocking queue and its poll()method instead of take()to retrieve an object from the queue. These alternative methods are used because they don.t block.

//Listing 10-4. Achieving Synchronization in Terms of Locks
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
public class PC
{
	public static void main(String[] args)
	{
		final Lock lock = new ReentrantLock();
		final BlockingQueue<Character> bq;
		bq = new ArrayBlockingQueue<Character>(26);
		final ExecutorService executor = Executors.newFixedThreadPool(2);
		Runnable producer;
		producer = new Runnable()
				{
					@Override
					public void run()
					{
						for (char ch = 'A'; ch <= 'Z'; ch++)
						{
							try
							{
								lock.lock();
								try
								{
									while (!bq.offer(ch)) //if not able to put in queue, unlock, sleep & try again
									{
										lock.unlock();
										Thread.sleep(50);
										lock.lock();
									}
									System.out.println(ch + " produced by producer.");//print right after insert
																					  //the consumer is still disabled
								}
								catch (InterruptedException ie)
								{
									assert false;
								}
							}
							finally
							{
								lock.unlock();//unlock before insert another ch
							}
						}
					}
				};
		executor.execute(producer);
		Runnable consumer;
		consumer = new Runnable()
		{
			@Override
			public void run()
			{
				char ch = '\0';
				do
				{
					try
					{
						lock.lock();
						try
						{
							Character c;
							while ((c = bq.poll()) == null)//if not able to poll, unlock,sleep then try again
							{
								lock.unlock();
								Thread.sleep(50);
								lock.lock();
							}
							ch = c; // unboxing behind the scenes
							System.out.println(ch + " consumed by consumer.");
						}
						catch (InterruptedException ie)
						{
							assert false;
						}
					}
					finally
					{
						lock.unlock();//unlock after consume 
					}
				}
				while (ch != 'Z');
				executor.shutdownNow();
			}
		};
		executor.execute(consumer);
	}
}
If I had used put()and take(), this application would have deadlocked in the following scenario:
1.  The consumer thread acquires the lock via its lock.lock()call.
2.  The producer thread attempts to acquire the lock via its lock.lock()call and is disabled because the consumer thread has already acquired the lock.
3.  The consumer thread calls take()to obtain the next java.lang.Character object from the queue.
4.  Because the queue is empty, the consumer thread must wait.
5.  The consumer thread doesn.t give up the lock that the producer thread requires before waiting, so the producer thread also continues to wait.
......................Atomic Variables
The java.util.concurrent.atomic package provides Atomic-prefixed classes (such as AtomicLong) that support lock-free, thread-safe operations on single variables. Each class declares methods such as get()and set()to read and write this variable without the need for external synchronization.
//Listing 10-5.  Returning Unique Identifiers in a Thread-Safe Manner via synchronized
class ID
{
	private static long nextID = 0;
	static synchronized long getNextID()
	{
		return nextID++;
	}
}
//Listing 10-6.  Returning Unique IDs in a Thread-Safe Manner via AtomicLong
import java.util.concurrent.atomic.AtomicLong;
class ID
{
	private static AtomicLong nextID = new AtomicLong(0);
	static long getNextID()
	{
		return nextID.getAndIncrement();
	}
}
......................the Date Class

......................the Formatter Class

......................the Scanner Class
......................the ZIP and JAR APIs
Use the "GZIPOutputStream" class to create a GZIP archive and write files to this archive in the GZIP format.

ZipOutputStream zos = new ZipOutputStream(new FileOutputStream("archive.zip"));

//Listing 10-11.  Creating a ZIP Archive and Storing Specified Files in That Archive
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;
public class ZipCreate
{
	public static void main(String[] args) throws IOException
	{
		if (args.length < 2)
		{
			System.err.println("usage: java ZipCreate ZIPfile infile1 "+ "infile2 ...");
			return;
		}
		ZipOutputStream zos = null;
		try
		{
			zos = new ZipOutputStream(new FileOutputStream(args[0]));//main outpu stream
			byte[] buf = new byte[1024];
			for (String filename: args)
			{
				if (filename.equals(args[0])) //skip first arg, it is the zip file name
					continue;
				FileInputStream fis = null;
				try
				{
					fis = new FileInputStream(filename); //singal file handle
					zos.putNextEntry(new ZipEntry(filename));
					int len;
					while ((len = fis.read(buf)) > 0)
						zos.write(buf, 0, len);
				}
				catch (IOException ioe)
				{
					System.err.println("I/O error: " + ioe.getMessage());
				}
				finally
				{
					if (fis != null)
						try
						{
							fis.close(); //close current file handle
						}
						catch (IOException ioe)
						{
							assert false; // shouldn't happen in this context
						}
				}
				zos.closeEntry(); //close the current entry
			}
		}
		catch (IOException ioe)
		{
			System.err.println("I/O error: " + ioe.getMessage());
		}
		finally
		{
			if (zos != null)
				try
				{
					zos.close();//after loop throgh all files, close main output stream
				}
				catch (IOException ioe)
				{
					assert false; // shouldn't happen in this context
				}
		}
	}
}
you can use its void setLevel(int level) method to set the compression level for successive entries. Specify an integer argument from 0 through 9, where 0 indicates no compression and 9 indicates best compression.better compression slows down performance. (Google reports these limits as .1 and 8.) Alternatively, specify one of the Deflatorclass.s BEST_COMPRESSION, BEST_SPEED, DEFAULT_COMPRESSION(to which setLevel()defaults), and other constants as an argument.

...........Reading Files from a ZIP Archive
ZipInputStream zis = new ZipInputStream(new FileInputStream("archive.zip"));
Listing 10-12.  Accessing a ZIP Archive and Extracting Specified Files from
That Archive
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;
public class ZipAccess
{
	public static void main(String[] args) throws IOException
	{
		if (args.length != 1)
		{
			System.err.println("usage: java ZipAccess zipfile");
			return;
		}
		ZipInputStream zis = null; 
		try
		{
			zis = new ZipInputStream(new FileInputStream(args[0]));
			byte[] buffer = new byte[4096];
			ZipEntry ze;
			while ((ze = zis.getNextEntry()) != null)
			{
				System.out.println("Extracting: " + ze);
				FileOutputStream fos = null;
				try
				{
					fos = new FileOutputStream(ze.getName()); //current file entry
					int numBytes;
					while ((numBytes = zis.read(buffer, 0, buffer.length)) != -1)
						fos.write(buffer, 0, numBytes);
				}
				catch (IOException ioe)
				{
					System.err.println("I/O error: " + ioe.getMessage());
				}
				finally
				{
					if (fos != null)
						try
						{
							fos.close();
						}
						catch (IOException ioe)
						{
							assert false; // shouldn't happen in this context
						}
				}
				zis.closeEntry();
			}
		}
		catch (IOException ioe)
		{
			System.err.println("I/O error: " + ioe.getMessage());
		}
		finally
		{
			if (zis != null)
				try
				{
					zis.close();
				}
				catch (IOException ioe)
				{
					assert false; // shouldn't happen in this context
				}
		}
	}
}
...........ZIPFILE versus ZIPINPUTSTREAM 
ZipFile allows random access to ZIP entries via its ZipEntry getEntry(String name) method. Given a ZipEntryinstance, you can call ZipEntry.s InputStream getInputStream(ZipEntry entry)method to obtain an input stream for reading the entry.s content. ZipInputStreamsupports sequential access to ZIP entries.

ZipFile internally caches ZIP entries for improved performance. ZipInputStreamdoesn.t cache entries.
......................JAR API
A "manifest" is a special file named MANIFEST.MF that stores information about the contents of the JAR file. This file is located in the JAR file.s META-INF directory. For example, the manifest would look as follows for an executable hello.jarJAR file containing a Helloapplication class:

Manifest-Version: 1.0
Main-Class: Hello

The first line signifies the version of the manifest and must be present. The second line identifies the application class that is to run when the JAR file is executed.  
You must insert an empty line after Main-Class: Hello. Otherwise, you will receive a .no main manifest attribute, in hello.jar. error message when trying to run the application.  

The Manifestclass is first instantiated (via its noargument constructor) to describe the soon-to-becreated manifest. Its getMainAttributes()method is then called to return an Attributesinstance for accessing existing manifest attributes or creating new manifest attributes (such as Main-Class).
"Attributes" is essentially a map and provides Object put(Object key, Object value)for storing an attribute name/value pair. The value passed to keymust be an Attributes.Nameconstant such as Attributes.Name.MANIFEST_VERSIONor Attributes.Name.MAIN_CLASS.

//Listing 10-13.  Creating a Runnable JAR File
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.jar.Attributes;
import java.util.jar.JarEntry;
import java.util.jar.JarOutputStream;
import java.util.jar.Manifest;
public class MakeRunnableJAR
{
	public static void main(String[] args) throws IOException
	{
		if (args.length < 2)
		{
			System.err.println("usage: java MakeRunnableJAR JARfile " + "classfile1 classfile2 ...");
			return;
		}
		JarOutputStream jos = null;
		try
		{
			Manifest mf = new Manifest(); //new mf
			Attributes attr = mf.getMainAttributes();//to get an instance of the Attribute of mf
			attr.put(Attributes.Name.MANIFEST_VERSION, "1.0");//a map, with key and value
			attr.put(Attributes.Name.MAIN_CLASS, args[1].substring(0, args[1].indexOf('.')));//classfile1 before .
			jos = new JarOutputStream(new FileOutputStream(args[0]), mf); // new write handle
			byte[] buf = new byte[1024];
			for (String filename: args)
			{
				if (filename.equals(args[0]))
					continue;
				FileInputStream fis = null;
				try
				{
					fis = new FileInputStream(filename);
					jos.putNextEntry(new JarEntry(filename));
					int len;
					while ((len = fis.read(buf)) > 0)
						jos.write(buf, 0, len);
				}
				catch (IOException ioe)
				{
					System.err.println("I/O error: " + ioe.getMessage());
				}
				finally
				{
					if (fis != null)
						try
						{
							fis.close();
						}
						catch (IOException ioe)
						{
							assert false; // shouldn't happen in this context
						}
				}
				jos.closeEntry();
			}
		}
		catch (IOException ioe)
		{
			System.err.println("I/O error: " + ioe.getMessage());
		}
		finally
		{
			if (jos != null)
				try
				{
					jos.close();
				}
				catch (IOException ioe)
				{
				assert false; // shouldn't happen in this context
				}
		}
	}
}

java MakeRunnableJAR hello.jar Hello.class

java -jar hello.jar
.................................Classic IO

//Listing 11-2.  Obtaining Abstract Pathname Information
import java.io.File;
import java.io.IOException;
public class PathnameInfo
{
	public static void main(final String[] args) throws IOException
	{
		if (args.length != 1)
		{
			System.err.println("usage: java PathnameInfo pathname");
			return;
		}
		File file = new File(args[0]);
		System.out.println("Absolute path = " + file.getAbsolutePath());
		System.out.println("Canonical path = " + file.getCanonicalPath()); //shortest uniq or absolute path
		System.out.println("Name = " + file.getName());
		System.out.println("Parent = " + file.getParent());
		System.out.println("Path = " + file.getPath());
		System.out.println("Is absolute = " + file.isAbsolute());
	}
}

//java PathnameInfo c:\reports\2012\..\2011\February
// output
Absolute path = c:\reports\2012\..\2011\February
Canonical path = C:\reports\2011\February // does not include 2012
Name = February
Parent = c:\reports\2012\..\2011
Path = c:\reports\2012\..\2011\February
Is absolute = true

//Listing 11-4.  Listing Specific Names
import java.io.File;
import java.io.FilenameFilter;
public class Dir
	{
	public static void main(final String[] args)
	{
		if (args.length != 2)
		{
			System.err.println("usage: java Dir dirpath ext");
			return;
		}
		File file = new File(args[0]);
		FilenameFilter fnf = new FilenameFilter() //defining the filter
				{
					@Override
					public boolean accept(File dir, String name)//override accept method for current criteria 
					{
						return name.endsWith(args[1]);
					}
				};
		String[] names = file.list(fnf);//filtered file list
		for (String name: names)
			System.out.println(name);
	}
}
......................RandomAccessFile API, r&w
r, rw, rwd, rws
"rwd"informs the constructor to create and open a new file when it doesn.t exist for reading and writing or open an existing file for reading and writing.  Furthermore, each update to the file.s content must be written synchronously to the underlying storage device.

"rws"informs the constructor to create and open a new file when it doesn.t exist for reading and writing or open an existing file for reading and writing.  Furthermore, each update to the file.s content or metadata must be written synchronously to the underlying storage device.
The "rwd" and "rws" modes ensure than any writes to a file located on a local storage device are written to the device, which guarantees that critical data isn.t lost when the operating system crashes. No guarantee is made when the file doesn.t reside on a local device.

//A handle is an identifier that Java passes to the underlying platform to identify, in this case, a specific open file when it requires that the underlying platform perform a file operation.

RandomAccessFile raf = new RandomAccessFile("employee.dat", "r");

RandomAccessFile raf = new RandomAccessFile("employee.dat", "rw");
FileDescriptor fd = raf.getFD();
// Perform a critical write operation.
raf.write(. . .);
// Synchronize with underlying disk by flushing platform's output buffers to  disk.
fd.sync();
// Perform non-critical write operation where synchronization isn't necessary.
raf.write(. . .);
// Do other work.
// Close file, emptying output buffers to disk.
raf.close();
......................Streams
A streamis an ordered sequence of bytes of arbitrary length.
...........ByteArrayOutputStream and ByteArrayInputStream
// for image processing
String pathname = . . . ; // Assume a legitimate pathname to an image.
Bitmap bm = BitmapFactory.decodeFile(pathname);
ByteArrayOutputStream baos = new ByteArrayOutputStream();
// BitMap.s boolean compress(Bitmap.CompressFormat format, int quality, OutputStream stream)
if (bm.compress(Bitmap.CompressFormat.PNG, 100, baos))
{
	byte[] imageBytes = baos.toByteArray();
	// Do something with imageBytes.
	bm = BitMapFactory.decodeStream(new ByteArrayInputStream(imageBytes));
}

...........FileOutputStream and FileInputStream
...........PipedOutputStream and PipedInputStream
The PipedOutputStream class lets a sending thread write a stream of bytes to an instance of the PipedInputStream class, which a receiving thread uses to subsequently read those bytes.
Listing 11-9.  Piping Randomly Generated Bytes from a Sender Thread to a
Receiver Thread
import java.io.IOException;
import java.io.PipedInputStream;
import java.io.PipedOutputStream;
public class PipedStreamsDemo
{
	public static void main(String[] args) throws IOException
	{
		final PipedOutputStream pos = new PipedOutputStream();//the pipe streams are in main thread 
		final PipedInputStream pis = new PipedInputStream(pos);//so shared by both sender and receiver
		Runnable senderTask = new Runnable()
		{
			final static int LIMIT = 10;
			@Override
			public void run()
			{
				try
				{
					for (int i = 0 ; i < LIMIT; i++)
						pos.write((byte) (Math.random() * 256));
				}
				catch (IOException ioe)
				{
					ioe.printStackTrace();
				}
				finally
				{
					try
					{
						pos.close(); //necessary, note below
					}
					catch (IOException ioe)
					{
						ioe.printStackTrace();
					}
				}
			}
		};
		Runnable receiverTask = new Runnable()
		{
			@Override
			public void run()
			{
				try
				{
					int b;
					while ((b = pis.read()) != .1)
						System.out.println(b);
				}
				catch (IOException ioe)
				{
					ioe.printStackTrace();
				}
				finally
				{
					try
					{
						pis.close();
					}
					catch (IOException ioe)
					{
						ioe.printStackTrace();
					}
				}
			}
		};
		Thread sender = new Thread(senderTask);
		Thread receiver = new Thread(receiverTask);
		sender.start();
		receiver.start();
	}
}
//The sender task.s run()method explicitly closes its pipe stream when it finishes sending the data. If it didn.t do this, an IOExceptioninstance with a "write end dead"  message would be thrown when the receiver thread invoked read()for the final time (which would otherwise return -1 to indicate end of stream). 
...........FilterOutputStream and FilterInputStream
A filter output streamtakes the data passed to its write() methods (the input stream), filters it, and writes the filtered data to an underlying output stream, which might be another filter output stream or a destination output stream such as a file output stream.
A filter input streamtakes the data obtained from its underlying input stream.which might be another filter input stream or a source input stream such as a file input stream.filters it, and makes this data available via its read()methods (the output stream).

//Using these for simple encription/decription 
//Listing 11-10.  Scrambling a Stream of Bytes
import java.io.FilterOutputStream;
import java.io.IOException;
import java.io.OutputStream;
public class ScrambledOutputStream extends FilterOutputStream
{
	private int[] map;
	public ScrambledOutputStream(OutputStream out, int[] map)
		{
			super(out);
			if (map == null)
				throw new NullPointerException("map is null");
			if (map.length != 256)
				throw new IllegalArgumentException("map.length != 256");
			this.map = map;
		}
		@Override
		public void write(int b) throws IOException
		{
			out.write(map[b]); //to write the maped char, not the oringal one "b"
	}
}
//Listing 11-11.  Scrambling a File.s Bytes
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.Random;
public class Scramble
{
	public static void main(String[] args)
	{
		if (args.length != 2)
		{
			System.err.println("usage: java Scramble srcpath destpath");
			return;
		}
		FileInputStream fis = null;
		ScrambledOutputStream sos = null;
		try
		{
			fis = new FileInputStream(args[0]);
			FileOutputStream fos = new FileOutputStream(args[1]);
			sos = new ScrambledOutputStream(fos, makeMap());//speicfy the file and map used, makeMap() only called once
			int b;
			while ((b = fis.read()) != -1)
				sos.write(b);
		}
		catch (IOException ioe)
		{
			ioe.printStackTrace();
		}
		finally
		{
			if (fis != null)
				try
				{
					fis.close();
				}
				catch (IOException ioe)
				{
					ioe.printStackTrace();
				}
			if (sos != null)
				try
				{
					sos.close();
				}
				catch (IOException ioe)
				{
					ioe.printStackTrace();
				}
		}
	}
	static int[] makeMap() //to change the current ch to a random one 
	{
		int[] map = new int[256];
		for (int i = 0; i < map.length; i++)
			map[i] = i;
		// Shuffle map.
		Random r = new Random(0);//with seed 0, the following random number always the same sequence
		for (int i = 0; i < map.length; i++) //to have a complete random map for all 256 chars
		{
			int n = r.nextInt(map.length);//256 random number used, 256 numbers all show up exactly once?
			int temp = map[i];
			map[i] = map[n];
			map[n] = temp;
		}
		return map;
	}
}
//Listing 11-12.  Unscrambling a Stream of Bytes
import java.io.FilterInputStream;
import java.io.InputStream;
import java.io.IOException;
public class ScrambledInputStream extends FilterInputStream
{
	private int[] map;
	public ScrambledInputStream(InputStream in, int[] map)
	{
		super(in);
		if (map == null)
			throw new NullPointerException("map is null");
		if (map.length != 256)
			throw new IllegalArgumentException("map.length != 256");
		this.map = map;
	}
	@Override
	public int read() throws IOException
	{
		int value = in.read();
		return (value == -1) ? -1 : map[value];
	}
	@Override
	public int read(byte[] b, int off, int len) throws IOException//not used in the main below
	{
		int nBytes = in.read(b, off, len);
		if (nBytes <= 0)
			return nBytes;
		for (int i = 0; i < nBytes; i++) //map nBytes a time, instead of one byte
			b[off + i] = (byte) map[off + i];//this line seems to be wrong
			b[off + i] = (byte) map[b[off + i]];// should be this
		return nBytes;
	}
}
//Listing 11-13.  Unscrambling a File.s Bytes
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.Random;
public class Unscramble
{
	public static void main(String[] args)
	{
		if (args.length != 2)
		{
			System.err.println("usage: java Unscramble srcpath destpath");
			return;
		}
		ScrambledInputStream sis = null;
		FileOutputStream fos = null;
		try
		{
			FileInputStream fis = new FileInputStream(args[0]);
			sis = new ScrambledInputStream(fis, makeMap());//using the new makeMap() below
			fos = new FileOutputStream(args[1]);
			int b;
			while ((b = sis.read()) != -1)
				fos.write(b);
		}
		catch (IOException ioe)
		{
			ioe.printStackTrace();
		}
		finally
		{
			if (sis != null)
				try
				{
					sis.close();
				}
				catch (IOException ioe)
				{
					ioe.printStackTrace();
				}
			if (fos != null)
				try
				{
					fos.close();
				}
				catch (IOException ioe)
				{
					ioe.printStackTrace();
				}
		}
	}
	static int[] makeMap()
	{
		int[] map = new int[256];
		for (int i = 0; i < map.length; i++)
			map[i] = i;
		// Shuffle map.
		Random r = new Random(0);
		for (int i = 0; i < map.length; i++) //also with 0 as seed, to generate the same sequence of random number
		{
			int n = r.nextInt(map.length);
			int temp = map[i];
			map[i] = map[n];
			map[n] = temp;
		}
		int[] temp = new int[256];
		for (int i = 0; i < temp.length; i++)//switch the ch back to its location
			temp[map[i]] = i;
			return temp;
	}
}
...........BufferedOutputStream and BufferedInputStream
FileOutputStreamand FileInputStreamhave a performance problem. Each file output stream write()method call and file input stream read()method call results in a call to one of the underlying platform.s native methods, and these native calls slow down I/O.
A "native method" is an underlying platform API function that Java connects to an application via the Java Native Interface (JNI). Java supplies reserved word nativeto identify a native method. For example, the RandomAccessFileclass declares a private native void open(String name, int mode)method. When a RandomAccessFileconstructor calls this method, Java asks the underlying platform (via the JNI) to open the specified file in the specified mode on Java.s behalf.

The concrete BufferedOutputStreamand BufferedInputStreamfilter stream classes improve performance by minimizing underlying output stream write()and underlying input stream read() method calls. 

A "concrete class" in java is one which implements the functionalities of an abstract class. Suppose we have class animal, dog and puppy, class animal is the idea of abstract class while classes dog and puppy are the idea of concrete classes because they extend animal and implement its functionalities.
A concre class is implemented from an abstract class.


FileOutputStream fos = new FileOutputStream("employee.dat");
BufferedOutputStream bos = new BufferedOutputStream(fos); // Chain bos to fos.
bos.write(0); // Write to employee.dat through the buffer.
// Additional write() method calls.
bos.close(); // This method call internally calls fos's close() method.

FileInputStream fis = new FileInputStream("employee.dat");
BufferedInputStream bis = new BufferedInputStream(fis); // Chain bis to fis.
int ch = bis.read(); // Read employee.dat through the buffer.
// Additional read() method calls.
bis.close(); // This method call internally calls fis's close() method.

...........DataOutputStream and DataInputStream
FileOutputStream and FileInputStream are useful for writing and reading bytes and arrays of bytes. However, they provide no support for writing and reading primitive type values (e.g., integers) and strings.

Java provides the concrete DataOutputStream and DataInputStream filter stream classes. Each class overcomes this limitation by providing methods to write or read primitive type values and strings in a platform-independent way

"Big-endian" and "little-endian" are terms that describe the order in which a sequence of bytes are stored in computer memory. Big-endian is an order in which the "big end" (most significant value in the sequence) is stored first (at the lowest storage address). Little-endian is an order in which the "little end" (least significant value in the sequence) is stored first. For example, in a big-endian computer, the two bytes required for the hexadecimal number 4F52 would be stored as 4F52 in storage (if 4F is stored at storage address 1000, for example, 52 will be at address 1001). In a little-endian system, it would be stored as 524F (52 at address 1000, 4F at 1001).

...........Object Serialization and Deserialization
Java provides the DataOutputStream and DataInputStream classes to stream primitive type values and String objects. However, you cannot use these classes to stream non-Stringobjects. Instead, you must use object serialization and deserialization to stream objects of arbitrary types.

Object "serialization" is a virtual machine mechanism for serializing an object state into a stream of bytes. Its "deserialization" counterpart is a virtual machine mechanism for deserializing this state from a byte stream.

...........Default Serialization and Deserialization
"Serializable" is an empty marker interface (there are no methods to implement) that a class implements to tell the virtual machine that it.s okay to serialize the class.s objects. When the serialization mechanism encounters an object whose class doesn.t implement Serializable, it throws an instance of the java.io.NotSerializableException class (an indirect subclass of IOException).

writeObject() doesn't serialize the contents of staticfields, and field marked with "transient" reserved word.
public transient char[] password;
//Listing 11-15.  Implementing Serializable
import java.io.Serializable;
public class Employee implements Serializable
{
	private String name;
	private int age;
	public Employee(String name, int age)
	{
		this.name = name;
		this.age = age;
	}
	public String getName() { return name; }
	public int getAge() { return age; }
}
//Listing 11-16.  Serializing and Deserializing an EmployeeObject
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
public class SerializationDemo
{
	final static String FILENAME = "employee.dat";
	public static void main(String[] args)
	{
		ObjectOutputStream oos = null;
		ObjectInputStream ois = null;
		try
		{
			FileOutputStream fos = new FileOutputStream(FILENAME);
			oos = new ObjectOutputStream(fos);
			Employee emp = new Employee("John Doe", 36);
			oos.writeObject(emp);
			oos.close();
			oos = null;
			FileInputStream fis = new FileInputStream(FILENAME);
			ois = new ObjectInputStream(fis);
			emp = (Employee) ois.readObject(); // (Employee) cast is necessary.
			ois.close();
			System.out.println(emp.getName());
			System.out.println(emp.getAge());
		}
		catch (ClassNotFoundException cnfe)
		{
			System.err.println(cnfe.getMessage());
		}
		catch (IOException ioe)
		{
			System.err.println(ioe.getMessage());
		}
		finally
		{
			if (oos != null)
				try
				{
					oos.close();
				}
				catch (IOException ioe)
				{
					assert false; // shouldn't happen in this context
				}
			if (ois != null)
				try
				{
					ois.close();
				}
				catch (IOException ioe)
				{
					assert false; // shouldn't happen in this context
				}
		}
	}
}
John Doe
36

If a clase has changed after serialization, when deserializing the readObject() will throw InvalidClassException.

You can avoid the thrown InvalidClassException instance by adding a 

static final long serialVersionUID = long integer value;

declaration to the class. The long integer valuemust be unique and is known as a stream unique identifier (SUID).  During deserialization, the virtual machine will compare the deserialized object.s SUID to its class.s SUID. If they match, readObject()will not throw InvalidClassException when it encounters a compatible class change(e.g., adding an instance field). However, it will still throw this exception when it encounters an incompatible class change(e.g., changing an instance field.s name or type).  

Whenever you change a class in some fashion, you must calculate a new SUID and assign it to serialVersionUID.

To generate the SUID:
serialver Employee
Employee: static final long serialVersionUID = 1517331364702470316L;
...........Custom Serialization and Deserialization
The deserialization mechanism throws InvalidClassException with a .no valid constructor. message when it doesn.t detect a public noargument constructor. 
//Listing 11-18.  Solving Problematic Deserialization
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;
class Employee
{
	private String name;
	Employee(String name)
	{
		this.name = name;
	}
	@Override
	public String toString()
	{
		return name;
	}
}
class SerEmployee implements Serializable//a wraper class, since Employee is not Serializable
{
	private Employee emp;
	private String name;
	SerEmployee(String name)
	{
		this.name = name;
		emp = new Employee(name);
	}
	private void writeObject(ObjectOutputStream oos) throws IOException
	{
		oos.writeUTF(name);
	}//proivde customeized readObject since Employee has no noargument constructor
	private void readObject(ObjectInputStream ois) throws ClassNotFoundException, IOException
	{
		name = ois.readUTF();
		emp = new Employee(name);
	}
	@Override
	public String toString()
	{
		return name;
	}
}
public class SerializationDemo
{
	public static void main(String[] args)
	{
		ObjectOutputStream oos = null;
		ObjectInputStream ois = null;
		try
		{
			oos = new ObjectOutputStream(new FileOutputStream("employee.
			SerEmployee se = new SerEmployee("John Doe");
			System.out.println(se);
			oos.writeObject(se);
			oos.close();
			oos = null;
			System.out.println("se object written to file");
			ois = new ObjectInputStream(new FileInputStream("employee.da
			se = (SerEmployee) ois.readObject();
			System.out.println("se object read from file");
			System.out.println(se);
		}
		catch (ClassNotFoundException cnfe)
		{
			cnfe.printStackTrace();
		}
		catch (IOException ioe)
		{
			ioe.printStackTrace();
		}
		finally
		{
			if (oos != null)
				try
				{
					oos.close();
				}
				catch (IOException ioe)
				{
					assert false; // shouldn't happen in this context
				}
			if (ois != null)
				try
				{
					ois.close();
				}
				catch (IOException ioe)
				{
					assert false; // shouldn't happen in this context
				}
		}
	}
}
//SerEmployee.s writeObject()and readObject()methods rely on DataOutputand DataInput methods: they don.t need to call writeObject()and readObject()to perform their tasks.
//ObjectOutputStream.s defaultWriteObject()method outputs the object.s normal state. Your writeObject()method first calls this method to output that state and then outputs additional data items via ObjectOutputStreammethods such as writeUTF().

//ObjectInputStream.s defaultReadObject()method inputs the object.s normal state. Your readObject()method first calls this method to input that state and then inputs additional data items via ObjectInputStreammethods such as readUTF().

...........Externalization
Unlike default/custom serialization/deserialization, "externalization" offers complete control over the serialization and deserialization tasks.
means that you have to implement the serialization and deserialization yourself with the 2 functions.
If a class implements Externalizable, its writeExternal()method is responsible for saving all field values that are to be saved. Also, its readExternal()method is responsible for restoring all saved field values and in the order they were saved.


//Listing 11-19.  Refactoring Listing 11-15.s EmployeeClass to Support Externalization
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
public class Employee implements Externalizable
{
	private String name;
	private int age;
	publicEmployee()//noargument constructor is necessary for externalization
	{
		System.out.println("Employee() called");
	}
	public Employee(String name, int age)
	{
		this.name = name;
		this.age = age;
	}
	public String getName() { return name; }
	public int getAge() { return age; }
	@Override
	public void writeExternal(ObjectOutput out) throws IOException
	{
		System.out.println("writeExternal() called");
		out.writeUTF(name);
		out.writeInt(age);
	}
	@Override
	public void readExternal(ObjectInput in)
	throws IOException, ClassNotFoundException
	{
		System.out.println("readExternal() called");
		name = in.readUTF();
		age = in.readInt();
	}
}
Suppose you compiled Listing 11-16.s SerializationDemo.javasource code and Listing 11-19.s Employee.javasource code in the same directory. Now suppose you executed "java SerializationDemo". In response, you would observe the following output:

writeExternal() called
Employee() called
readExternal() called
John Doe
36
...........PrintStream
.................................Writers and Readers
Java.s stream classes are good for streaming sequences of bytes, but they.re not good for streaming sequences of characters because bytes and characters are two different things: a byte represents an 8-bit data item and a character represents a 16-bit data item. Also, Java.s charand Stringtypes naturally handle characters instead of bytes.

Java.s writer and reader classes, which were designed to support character I/O (they work with charinstead of byte). Furthermore, the writer and reader classes take character encodings into account.

...........OutputStreamWriter and InputStreamReader
The concrete OutputStreamWriter class (a Writersubclass) is a bridge between an incoming sequence of characters and an outgoing stream of bytes. Characters written to this writer are encoded into bytes according to the default or specified character encoding.

Note The default character encoding is accessible via the file.encoding system property.

Note  OutputStreamWriter depends on the abstract java.nio.charset.Charset and java.nio.charset.CharsetEncoder classes to perform character encoding.

FileOutputStream fos = new FileOutputStream("polish.txt");
OutputStreamWriter osw = new OutputStreamWriter(fos, "8859_2");
char ch = '\u0323'; // Accented N.
osw.write(ch);


Note  InputStreamReader depends on the abstract Charsetand java.nio.charset.  CharsetDecoderclasses to perform character decoding.

FileInputStream fis = new FileInputStream("polish.txt");
InputStreamReader isr = new InputStreamReader(fis, "8859_2");
char ch = isr.read(ch);

Note  OutputStreamWriter and InputStreamReader declare a String getEncoding() method that returns the name of the character encoding in use. If the encoding has a historical name, that name is returned; otherwise, the encoding.s canonical name is returned

...........FileWriter and FileReader
FileWriteris a convenience class for writing characters to files. It subclasses OutputStreamWriter, and its constructors call OutputStreamWriter(OutputStream). An instance of this class is equivalent 

to the following code fragment:
FileOutputStream fos = new FileOutputStream(pathname);
OutputStreamWriter osw;
osw = new OutputStreamWriter(fos, System.getProperty("file.encoding"));

//Listing 11-20.  Logging Messages to an Actual File
package logging;
import java.io.FileWriter;
import java.io.IOException;
class File implements Logger
{
	private final static String LINE_SEPARATOR = System.getProperty("line.separator");
	private String dstName;
	private FileWriter fw;
	File(String dstName)
	{
		this.dstName = dstName;
	}
	public boolean connect()
	{
		if (dstName == null)
			return false;
			try
			{
				fw = new FileWriter(dstName);
			}
			catch (IOException ioe)
			{
				return false;
			}
		return true;
	}
	public boolean disconnect()
	{
		if (fw == null)
			return false;
		try
		{
			fw.close();
		}
		catch (IOException ioe)
		{
			return false;
		}
		return true;
	}
	public boolean log(String msg)
	{
		if (fw == null)
			return false;
		try
		{
			fw.write(msg + LINE_SEPARATOR);
		}
		catch (IOException ioe)
		{
			return false;
		}
		return true;
	}
}
FileReaderis a convenience class for reading characters from files. It subclasses InputStreamReader, and its constructors call InputStreamReader(InputStream).  An instance of this class is equivalent to the following code fragment:

FileInputStream fis = new FileInputStream(pathname);
InputStreamReader isr;
isr = new InputStreamReader(fis, System.getProperty("file.encoding"));
//Listing 11-21.  Finding All Files That Contain Content Matching a Search String
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
public class FindAll
{
	public static void main(String[] args)
	{
		if (args.length != 2)
		{
			System.err.println("usage: java FindAll start search-string");
			return;
		}
		if (!findAll(new File(args[0]), args[1]))
			System.err.println("not a directory");
	}
	static boolean findAll(File file, String srchText)
	{
		File[] files = file.listFiles();
		if (files == null)
			return false;
		for (int i = 0; i < files.length; i++)
			if (files[i].isDirectory())
				findAll(files[i], srchText);
			else
				if (find(files[i].getPath(), srchText))
					System.out.println(files[i].getPath());
		return true;
	}
	static boolean find(String filename, String srchText)
	{
		BufferedReader br = null;
		try
		{
			br = new BufferedReader(new FileReader(filename));//wrap a file reader in a bufferedReader
			int ch;
			outer_loop:
			do
			{
				if ((ch = br.read()) == -1)
					return false;
				if (ch == srchText.charAt(0)) // this might not work for "aab" in aaab
				{								//unless the inner loop read will not count as current poistion
					for (int i = 1; i < srchText.length(); i++)
					{
						if ((ch = br.read()) == -1)
							return false;
						if (ch != srchText.charAt(i))
							continue outer_loop;
					}
					return true;
				}
			}
			while (true);
		}
		catch (IOException ioe)
		{
			System.err.println("I/O error: " + ioe.getMessage());
		}
		finally
		{
			if (br != null)
				try
				{
					br.close();
				}
				catch (IOException ioe)
				{
					assert false; // shouldn't happen in this context
				}
		}
		return false;
	}
}
.................................networks
Android apps must have permission to access the network. Permission can be obtained by including <uses-permission android:name="android.permission.INTERNET" />in the manifest file.
...........socket
...........Socket Options
SocketOptionsalso declares the following methods for setting and getting these options:
 void setOption(int optID, Object value)
 Object getOption(int optID)
...........Socket and ServerSocket
Socket socket = new Socket("localhost", 9999);
InputStream is = socket.getInputStream();
OutputStream os = socket.getOutputStream();
// Do some work with the socket.
socket.close();


ServerSocket ss = new ServerSocket(9999);
while (true)
{
	final Socket s = ss.accept();
	new Thread(new Runnable()
		{
			@Override
			public void run()
			{
				// obtain socket input/output streams and communicate with socket
				try { s.close(); } catch (IOException ioe) {}
			}
		}).start();
}

//Listing 12-1.  Echoing Data to and Receiving It Back from a Server
import java.io.BufferedReader;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.IOException;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.net.Socket;
import java.net.UnknownHostException;
public class EchoClient
{
	public static void main(String[] args)
	{
		if (args.length != 1)
		{
			System.err.println("usage : java EchoClient message");
			System.err.println("example: java EchoClient \"This is a test.\"");
			return;
		}
		try
		{
			Socket socket = new Socket("localhost", 9999);
			OutputStream os = socket.getOutputStream();
			OutputStreamWriter osw = new OutputStreamWriter(os);
			PrintWriter pw = new PrintWriter(osw);
			pw.println(args[0]);
			pw.flush();
			InputStream is = socket.getInputStream();
			InputStreamReader isr = new InputStreamReader(is);
			BufferedReader br = new BufferedReader(isr);
			System.out.println(br.readLine());
			}
		catch (UnknownHostException uhe)
		{
			System.err.println("unknown host: " + uhe.getMessage());
		}
		catch (IOException ioe)
		{
			System.err.println("I/O error: " + ioe.getMessage());
		}
	}
}
//Listing 12-2.  Receiving Data from and Echoing It Back to a Client
import java.io.BufferedReader;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.IOException;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.net.ServerSocket;
import java.net.Socket;
public class EchoServer
{
	public static void main(String[] args) throws IOException
	{
		System.out.println("Starting echo server. . .");
		ServerSocket ss = new ServerSocket(9999);
		while (true)//single thread???
		{
			Socket s = ss.accept();
			try
			{
				InputStream is = s.getInputStream();
				InputStreamReader isr = new InputStreamReader(is);
				BufferedReader br = new BufferedReader(isr);
				String msg = br.readLine();
				System.out.println(msg);
				OutputStream os = s.getOutputStream();
				OutputStreamWriter osw = new OutputStreamWriter(os);
				PrintWriter pw = new PrintWriter(osw);
				pw.println(msg);
				pw.flush();
			}
			catch (IOException ioe)
			{
				System.err.println("I/O error: " + ioe.getMessage());
			}
			finally
			{
				try
				{
					s.close();
				}
				catch (IOException ioe)
				{
					assert false; // shouldn't happen in this context
				}
			}
		}
	}
}
...........DatagramSocket and MulticastSocket, for UDP traffic
The DatagramSocket and MulticastSocket classes let you perform UDP-based communications between a pair of hosts (DatagramSocket) or between many hosts (MulticastSocket). With either class, you communicate one-way messages via datagram packets, which are arrays of bytes associated with instances of the DatagramPacket class.

byte[] buffer = new byte[100];
DatagramPacket dgp = new DatagramPacket(buffer, buffer.length);

//Listing 12-3. Receiving Datagram Packets from and Echoing Them Back to Clients
import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.SocketException;
public class DGServer
{
	final static int PORT = 10000;
	public static void main(String[] args) throws SocketException
	{
		System.out.println("Server is starting");
		DatagramSocket dgs = new DatagramSocket(PORT);
		try
		{
			System.out.println("Send buffer size = " + dgs.getSendBufferSize());
			System.out.println("Receive buffer size = " + dgs.getReceiveBufferSize());
			byte[] data = new byte[100];
			DatagramPacket dgp = new DatagramPacket(data, data.length);
			while (true)
			{
				dgs.receive(dgp);//receive and send back 100 byte a time
				System.out.println(new String(data));
				dgs.send(dgp);
			}
		}
		catch (IOException ioe)
		{
			System.err.println("I/O error: " + ioe.getMessage());
		}
	}
}
//Listing 12-4. Sending a Datagram Packet to and Receiving It Back from a Server
import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.SocketException;
public class DGClient
{
	final static int PORT = 10000;
	final static String ADDR = "localhost";
	public static void main(String[] args) throws SocketException
	{
		System.out.println("client is starting");
		DatagramSocket dgs = new DatagramSocket();
		try
		{
			byte[] buffer;
			buffer = "Send me a datagram".getBytes();
			InetAddress ia = InetAddress.getByName(ADDR);
			DatagramPacket dgp = new DatagramPacket(buffer, buffer.length, ia,
			PORT);
			dgs.send(dgp);
			byte[] buffer2 = new byte[100];
			dgp = new DatagramPacket(buffer2, buffer.length, ia, PORT);
			dgs.receive(dgp);
			System.out.println(new String(dgp.getData()));
			}
		catch (IOException ioe)
		{
			System.err.println("I/O error: " + ioe.getMessage());
		}
	}
}
......................Accessing Networks via URLs
A Uniform Resource Name (URN)is a character string that names a resource and doesn.t provide a way to access that resource (the resource might not be available). For example, urn:isbn:9781430231561identifies an Apress book named Learn Java for Android Developmentand that.s all.  
URNs and URLs are examples of Uniform Resource Identifiers (URIs), which are character strings for identifying names (URNs) and resources (URLs). Every URN and URL is also a URI.
...........URL and URLConnection
when the resource is stored in a JAR file, as demonstrated here:
jar:file:///C:./rt.jar!/java/util/Timer.class
The ! is to separate the file paths within the jar file.
//Listing 12-7. Listing the Contents of the Resource Identified via a URL Command-Line Argument
import java.io.InputStream;
import java.io.IOException;
import java.net.MalformedURLException;
import java.net.URL;
public class ListResource
{
	public static void main(String[] args)
	{
		if (args.length != 1)
		{
			System.err.println("usage: java ListResource url");
			return;
		}
		try
		{
			URL url = new URL(args[0]);
			InputStream is = url.openStream();
			try
			{
				int ch;
				while ((ch = is.read()) != .1)
					System.out.print((char) ch);
			}
			catch (IOException ioe)
			{
				is.close();
			}
		}
		catch (MalformedURLException murle)
		{
			System.err.println("invalid URL");
		}
		catch (IOException ioe)
		{
			System.err.println("I/O error: " + ioe.getMessage());
		}
	}
}

URLConnection urlc = url.openConnection();
urlc.setDoOutput(true);
OutputStream os = urlc.getOutputStream();

...........URLEncoder and URLDecoder
//Listing 12-8. Encoding and Decoding an Encoded String
import java.io.UnsupportedEncodingException;
import java.net.URLDecoder;
import java.net.URLEncoder;
public class ED
{
	public static void main(String[] args) throws UnsupportedEncodingException
	{
		String encodedData = URLEncoder.encode("string übar", "UTF-8");
		System.out.println(encodedData);
		System.out.println(URLDecoder.decode(encodedData, "UTF-8"));
	}
}
string+%C3%BC%40foo-bar
string übar
........... Accessing Network Interfaces and Interface Addresses
//Listing 12-9. Enumerating All Network Interfaces
import java.net.NetworkInterface;
import java.net.SocketException;
import java.util.Collections;
import java.util.Enumeration;
public class NetInfo
{
	public static void main(String[] args) throws SocketException
	{
		Enumeration<NetworkInterface> eni;
		eni = NetworkInterface.getNetworkInterfaces();
		for (NetworkInterface ni: Collections.list(eni))
		{
			System.out.println("Name = " + ni.getName());
			System.out.println("Display Name = " + ni.getDisplayName());
			System.out.println("Loopback = " + ni.isLoopback());
			System.out.println("Up and running = " + ni.isUp());
			System.out.println("MTU = " + ni.getMTU());
			System.out.println("Supports multicast = " + ni.supportsMulticast());
			System.out.println("Sub-interfaces");
			Enumeration<NetworkInterface> eni2;
			eni2 = ni.getSubInterfaces();
			for (NetworkInterface ni2: Collections.list(eni2))
				System.out.println(" " + ni2);
				System.out.println();
		}
	}
}
Name = lo
Display Name = Software Loopback Interface 1
Loopback = true
Up and running = true
MTU = .1
Supports multicast = true
Sub-interfaces

Name = net0
Display Name = WAN Miniport (SSTP)
Loopback = false
Up and running = false
MTU = .1
Supports multicast = true
Sub-interfaces

//Listing 12-10. Enumerating All Network Interfaces and Interface Addresses
import java.net.InterfaceAddress;
import java.net.NetworkInterface;
import java.net.SocketException;
import java.util.Collections;
import java.util.Enumeration;
import java.util.Iterator;
import java.util.List;
public class NetInfo
{
	public static void main(String[] args) throws SocketException
	{
		Enumeration<NetworkInterface> eni;
		eni = NetworkInterface.getNetworkInterfaces();
		for (NetworkInterface ni: Collections.list(eni))
		{
			System.out.println("Name = " + ni.getName());
			List<InterfaceAddress> ias = ni.getInterfaceAddresses();
			Iterator<InterfaceAddress> iter = ias.iterator();
			while (iter.hasNext())
				System.out.println(iter.next());
				System.out.println();
		}
	}
}
...........Managing Cookies
//Listing 12-11. Listing All Cookies for a Specific Domain
import java.io.IOException;
import java.net.CookieHandler;
import java.net.CookieManager;
import java.net.CookiePolicy;
import java.net.HttpCookie;
import java.net.URL;
import java.util.List;
public class ListAllCookies
{
	public static void main(String[] args) throws IOException
	{
		if (args.length != 1)
		{
			System.err.println("usage: java ListAllCookies url");
			return;
		}
		CookieManager cm = new CookieManager();
		cm.setCookiePolicy(CookiePolicy.ACCEPT_ALL);
		CookieHandler.setDefault(cm);
		new URL(args[0]).openConnection().getContent();
		List<HttpCookie> cookies = cm.getCookieStore().getCookies();
		for (HttpCookie cookie: cookies)
		{
			System.out.println("Name = " + cookie.getName());
			System.out.println("Value = " + cookie.getValue());
			System.out.println("Lifetime (seconds) = " + cookie.getMaxAge());
			System.out.println("Path = " + cookie.getPath());
			System.out.println();
		}
	}
}

java ListAllCookies http://java.net:

Name = SESSe2db433431725a35762565c526a602d3
Value = 29va73kqorof3k2tmchn1fka11
Lifetime (seconds) = 3971
Path = /

......................New I/O
...........Working with Buffers
NIO is based on buffers. A bufferis an object that stores a fixed amount of data to be sent to or received from an I/O service(a means for performing input/output). It sits between an application and a channelthat writes the buffered data to the service or reads the data from the service and deposits it into the buffer.

Buffers are not thread safe. You must employ synchronization when you want to access a buffer from multiple threads.
//Listing 13-1. Demonstrating a Byte-Oriented Buffer
import java.nio.Buffer;
import java.nio.ByteBuffer;
public class BufferDemo
{
	public static void main(String[] args)
	{
		Buffer buffer = ByteBuffer.allocate(7);
		System.out.println("Capacity: " + buffer.capacity());
		System.out.println("Limit: " + buffer.limit());
		System.out.println("Position: " + buffer.position());
		System.out.println("Remaining: " + buffer.remaining());
		System.out.println("Changing buffer limit to 5");
		buffer.limit(5);
		System.out.println("Limit: " + buffer.limit());
		System.out.println("Position: " + buffer.position());
		System.out.println("Remaining: " + buffer.remaining());
		System.out.println("Changing buffer position to 3");
		buffer.position(3);
		System.out.println("Position: " + buffer.position());
		System.out.println("Remaining: " + buffer.remaining());
		System.out.println(buffer);
	}
}
Capacity: 7
Limit: 7
Position: 0
Remaining: 7
Changing buffer limit to 5
Limit: 5
Position: 0
Remaining: 5
Changing buffer position to 3
Position: 3
Remaining: 2
java.nio.HeapByteBuffer[pos=3 lim=5 cap=7]

...........Buffer Creation
ByteBuffers (and other primitive type buffers) created via allocate()or wrap()are nondirect byte buffers.
Nondirect byte buffers have backing arrays, and you can access these backing arrays via the array()method (which happens to be declared as byte[] array()in the ByteArrayclass) as long as hasArray()returns true. 
//Listing 13-2. Creating Byte-Oriented Buffers via Allocation and Wrapping
import java.nio.ByteBuffer;
public class BufferDemo
{
	public static void main(String[] args)
	{
		ByteBuffer buffer1 = ByteBuffer.allocate(10);
		if (buffer1.hasArray())
		{
			System.out.println("buffer1 array: " + buffer1.array());
			System.out.println("Buffer1 array offset: " + buffer1.arrayOffset());
			System.out.println("Capacity: " + buffer1.capacity());
			System.out.println("Limit: " + buffer1.limit());
			System.out.println("Position: " + buffer1.position());
			System.out.println("Remaining: " + buffer1.remaining());
			System.out.println();
		}
		byte[] bytes = new byte[200];
		ByteBuffer buffer2 = ByteBuffer.wrap(bytes);
		buffer2 = ByteBuffer.wrap(bytes, 10, 50);//array,position,limit (amount)
		if (buffer2.hasArray())
		{
			System.out.println("buffer2 array: " + buffer2.array());
			System.out.println("Buffer2 array offset: " + buffer2.arrayOffset());
			System.out.println("Capacity: " + buffer2.capacity());
			System.out.println("Limit: " + buffer2.limit());
			System.out.println("Position: " + buffer2.position());
			System.out.println("Remaining: " + buffer2.remaining());
		}
	}
}
buffer1 array: [B@15e565bd //byte buffer always has back array.
Buffer1 array offset: 0
Capacity: 10
Limit: 10
Position: 0
Remaining: 10

buffer2 array: [B@77a6686
Buffer2 array offset: 0
Capacity: 200
Limit: 60 //position + limit, this is the limit at
Position: 10
Remaining: 50

As well as managing data elements stored in external arrays (via the wrap()methods), buffers can manage data stored in other buffers. When you create a buffer that manages another buffer.s data, the created buffer is known as a "view buffer". Changes made in either buffer are reflected in the other.
"view buffer" is the same as the original buffer, same data, capacity, direct, read-only or not, but has its only position, limit, and mark.

ByteBuffer buffer = ByteBuffer.allocate(10);
ByteBuffer bufferView = buffer.duplicate();

"View buffers" are also created by calling one of ByteBuffer.s asxBuffer()methods. For example, LongBuffer asLongBuffer()returns a view buffer that conceptualizes the byte buffer as a buffer of long integers.

"Read-only view buffers" can be created by calling a method such as ByteBuffer asReadOnlyBuffer().
...........Writing and Reading Buffers
//Listing 13-3. Writing Bytes to and Reading Them From a Buffer
import java.nio.ByteBuffer;
public class BufferDemo
{
	public static void main(String[] args)
	{
		ByteBuffer buffer = ByteBuffer.allocate(7);
		System.out.println("Capacity = " + buffer.capacity());
		System.out.println("Limit = " + buffer.limit());
		System.out.println("Position = " + buffer.position());
		System.out.println("Remaining = " + buffer.remaining());
		buffer.put((byte) 10).put((byte) 20).put((byte) 30);
		System.out.println("Capacity = " + buffer.capacity());
		System.out.println("Limit = " + buffer.limit());
		System.out.println("Position = " + buffer.position());
		System.out.println("Remaining = " + buffer.remaining());
		for (int i = 0; i < buffer.position(); i++)
			System.out.println(buffer.get(i));//all same type of elements
	}
}
Capacity = 7
Limit = 7
Position = 0
Remaining = 7
Capacity = 7
Limit = 7
Position = 3
Remaining = 4
10
20
30
...........Flipping Buffers
"flip()" :  set current position as limist and put position to 0.
rewind()is similar to flip()but ignores the limit. Also, calling flip()twice doesn.t return you to the original state. Instead, the buffer has a zero size.

//Listing 13-4. Writing Characters to and Reading Them From a Character Buffer
import java.nio.CharBuffer;
public class BufferDemo
{
	public static void main(String[] args)
	{
		String[] poem =
		{
			"Roses are red",
			"Violets are blue",
			"Sugar is sweet",
			"And so are you."
		};
		CharBuffer buffer = CharBuffer.allocate(50);
		for (int i = 0; i < poem.length; i++)//one per line
		{
			// Fill the buffer.
			for (int j = 0; j < poem[i].length(); j++)// one per char, including \n
				buffer.put(poem[i].charAt(j));
			// Flip the buffer so that its contents can be read.
			buffer.flip();
			// Drain the buffer.
			while (buffer.hasRemaining())
				System.out.print(buffer.get());
			// Empty the buffer to prevent BufferOverflowException.
			buffer.clear();
			System.out.println();
		}
	}
}
Roses are red
Violets are blue
Sugar is sweet
And so are you.
...........Marking Buffers
Don.t confuse reset()with clear(). The clear()method marks a buffer as empty, whereas reset()changes the buffer.s current position to the previously set mark, or throws InvalidMarkExceptionwhen there.s no previously set mark.

//Listing 13-5. Marking the Current Buffer Position and Resetting the Current
//Position to the Marked Position
import java.nio.ByteBuffer;
public class BufferDemo
{
	public static void main(String[] args)
	{
		ByteBuffer buffer = ByteBuffer.allocate(7);
		buffer.put((byte) 10).put((byte) 20).put((byte) 30).put((byte) 40);
		buffer.limit(4);
		buffer.position(1).mark().position(3);//mark 1, then put position at 3
		System.out.println(buffer.get());//get position 3
		System.out.println();
		buffer.reset();//put offset to mark, 1
		while (buffer.hasRemaining())
			System.out.println(buffer.get());//print all out
	}
}
40
20
30
40
...........Buffer Subclass Operations
buf.clear(); // Prepare buffer for use
while (in.read(buf) != .1)
{
	buf.flip(); // Prepare buffer for draining.
	out.write(buf); // Write the buffer.
	buf.compact(); // Do this in case of a partial write.
	//The buffer's current position is then set to n + 1, and its limit is set to its capacity.
}

The "compact()" method call moves unwritten buffer data to the beginning of the buffer so that the next read() method call appends read data to the buffer.s data instead of overwriting that data when compact() isn't specified.

//To compare
System.out.println(bytBuf1.equals(bytBuf2));
System.out.println(bytBuf1.compareTo(bytBuf2));

The "equals()" contract for ByteBufferstates that 2 byte buffers are equal if and only if they have the same element type; they have the same number of remaining elements; and the two sequences of remaining elements, considered independently of their starting positions, are individually equal. This contract is the same for the other Buffersubclasses.

The "compareTo()" method for ByteBufferstates that 2 byte buffers are compared for order by comparing their sequences of remaining elements lexicographically, without regard to the starting position of each sequence within its corresponding buffer. 
...........Byte Ordering
For example, consider 32-bit long integer 0x10203040. This value.s 4 bytes could be stored in memory (from low address to high address) as 10, 20, 30, 40; this arrangement is known as "big-endian" order(the most significant byte, the .big. end, is stored at the lowest address).  Alternatively, these bytes could be stored as 40, 30, 20, 10; this arrangement is known as "little-endian" order(the least significant byte, the .little. end, is stored at the lowest address).
...........Direct Byte Buffers
A "direct byte buffer" is a byte buffer that interacts with channels and native code to perform I/O.  The direct byte buffer attempts to store byte elements in a memory area that a channel uses to perform direct(raw) access via native code that tells the operating system to drain or fill the memory area directly.
Direct byte buffers are the most efficient means for performing I/O on the virtual machine.

Although optimal for I/O, a direct byte buffer can be expensive to create because memory extraneous to the virtual machine.s heap will need to be allocated by the operating system, and setting up and/or tearing down this memory might take longer than when the buffer was located within the heap.

...........Working with Channels
"Channels" partner with buffers to achieve high-performance I/O. A channelis an object that represents an open connection to a hardware device, a file, a network socket, an application component, or another entity that.s capable of performing write, read, and other I/O operations.  Channels efficiently transfer data between byte buffers and I/O service sources or destinations.

Channels are the gateways through which native I/O services are accessed.  Channels use byte buffers as the endpoints for sending and receiving data.

There often exists a one-to-one correspondence between an operating system file handle or file descriptor and a channel. When you work with channels in a file context, the channel will often be connected to an open file descriptor. 

You can determine whether or not a channel supports asynchronous closing and interruption by using the instanceofoperator in an expression such as 

channel instanceof InterruptibleChannel

When you need to learn whether or not a channel is bidirectional, it.s more convenient to specify an expression such as 

channel instanceof ByteChannel.

"WritableByteChannel newChannel(OutputStream outputStream)" returns a writable byte channel for the given outputStream.

"ReadableByteChannel newChannel(InputStream inputStream)" returns a readable byte channel for the given inputStream.

//Listing 13-6.  Copying Bytes From an Input Channel to an Output Channel
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.channels.Channels;
import java.nio.channels.ReadableByteChannel;
import java.nio.channels.WritableByteChannel;
public class ChannelDemo
{
	public static void main(String[] args)
	{
		ReadableByteChannel src = Channels.newChannel(System.in);
		WritableByteChannel dest = Channels.newChannel(System.out);
		try
		{
			copy(src, dest); // or copyAlt(src, dest);
		}
		catch (IOException ioe)
		{
			System.err.println("I/O error: " + ioe.getMessage());
		}
		finally
		{
			try
			{
				src.close();
				dest.close();
			}
			catch (IOException ioe)
			{
				ioe.printStackTrace();
			}
		}
	}
	static void copy(ReadableByteChannel src, WritableByteChannel dest) throws IOException
	{
		ByteBuffer buffer = ByteBuffer.allocateDirect(2048);
		while (src.read(buffer) != -1)
		{//less native IO call from write, but more data copy from compact()
			buffer.flip();//move position to  0
			dest.write(buffer);//may not finish writing all in buffer?
			buffer.compact();//move remaining elements to the beginning
		}
		buffer.flip();
		while (buffer.hasRemaining())//need this one to finish?
			dest.write(buffer);
	}
	static void copyAlt(ReadableByteChannel src, WritableByteChannel dest) throws IOException
	{//less data copied but maybe more native IO call by write, some write may not full capacity
		ByteBuffer buffer = ByteBuffer.allocateDirect(2048);
		while (src.read(buffer) != -1)
		{
			buffer.flip();
			while (buffer.hasRemaining())
				dest.write(buffer);
			buffer.clear();
		}
	}
}
//It's important to realize that a single write()method call may not output the entire content of a buffer. Similarly, a single read()call may not completely fill a buffer.

...........Scatter/Gather I/O
Channels provide the ability to perform a single I/O operation across multiple buffers. This capability is known as scatter/gather I/O(and is also known as vectored I/O).

Modern operating systems provide APIs that support vectored I/O to eliminate (or at least reduce) system calls or buffer copies and hence improve performance. For example, the Win32/Win64 APIs provide ReadFileScatter()and WriteFileGather()functions for this purpose.

//Listing 13-7.  Demonstrating Scatter/Gather
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.channels.Channels;
import java.nio.channels.GatheringByteChannel;
import java.nio.channels.ReadableByteChannel;
import java.nio.channels.ScatteringByteChannel;
public class ChannelDemo
{
	public static void main(String[] args) throws IOException
	{
		ScatteringByteChannel src;
		src = (ScatteringByteChannel) Channels.newChannel(new
		FileInputStream("x.dat"));
		ByteBuffer buffer1 = ByteBuffer.allocateDirect(5);
		ByteBuffer buffer2 = ByteBuffer.allocateDirect(3);
		ByteBuffer[] buffers = { buffer1, buffer2 };
		src.read(buffers);
		buffer1.flip();
		while (buffer1.hasRemaining())
			System.out.printf("%c%n", buffer1.get());
		System.out.println();
		buffer2.flip();
		while (buffer2.hasRemaining())
			System.out.printf("%c%n", buffer2.get());
		buffer1.rewind();
		buffer2.rewind();
		GatheringByteChannel dest;
		dest = (GatheringByteChannel) Channels.newChannel(new
		FileOutputStream("y.dat"));
		buffers[0] = buffer2;
		buffers[1] = buffer1;
		dest.write(buffers);
	}
}
//The %n format specifier in the System.out.printf()method calls is a portable way to specify the line terminator(a 1-or-2-character sequence designating the end of the line). 

...........File Channels
A file channel maintains a virtual pointer into the file, which is known as the file pointer, and FileChannel lets you obtain and change the file pointer value. It also lets you obtain the size of the file underlying the channel, attempt to lock the entire file or just a region of the file, perform memory-mapped file I/O, request that cached data be forced to the disk, and transfer data directly to another channel in a manner that has the potential to be optimized by the platform.

Unlike buffers, which are not thread-safe, file channels are thread-safe.
//Listing 13-8. Demonstrating a File Channel
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
public class ChannelDemo
{
	public static void main(String[] args) throws IOException
	{
		if (args.length != 1)
		{
			System.out.println("usage: java ChannelDemo newfilespec");
			return;
		}
		FileOutputStream fos = new FileOutputStream(args[0]);
		FileChannel fc = fos.getChannel();
		System.out.println("position: " + fc.position());
		System.out.println("size: " + fc.size());
		String msg = "This is a test message.";
		ByteBuffer buffer = ByteBuffer.allocateDirect(msg.length() * 2);
		buffer.asCharBuffer().put(msg);
		fc.write(buffer);
		System.out.println("position: " + fc.position());
		System.out.println("size: " + fc.size());
		fc.truncate(24L);
		fc.close();
		FileInputStream fis = new FileInputStream(args[0]);
		fc = fis.getChannel();
		System.out.println("size: " + fc.size());
		buffer.clear();
		fc.read(buffer);
		buffer.flip();
		while (buffer.hasRemaining())
			System.out.print(buffer.getChar());
		System.out.println();
		System.out.println(buffer.getChar(0));//printing the first 2 bytes of the unicode char
		System.out.println(buffer.getChar(1));//byte 1 and 2, resulting in ?  each char is 2 bytes
		System.out.println(buffer.getChar(2));
		MappedByteBuffer mbb = fc.map(FileChannel.MapMode.READ_ONLY, 0, 4);//mapped, 0 - 3 bytes
		System.out.println(mbb.getChar(0));
		System.out.println(mbb.getChar(2));// why h in capital?
		System.out.println(mbb.getChar(4));// byte 4 and 5, not mapped
		fc.close();
	}
}
position: 0
size: 0
position: 46
size: 46
size: 24
This is a te
T
?
h
T
H //why in uppercase?
Exception in thread "main" 
java.lang.IndexOutOfBoundsException
at java.nio.Buffer.checkIndex(Unknown Source)
at java.nio.DirectByteBuffer.getChar(Unknown Source)
at ChannelDemo.main(ChannelDemo.java:46)

......................Regular Expressions
//Listing 13-9. Playing With Regular Expressions
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;
public class RegExDemo
{
	public static void main(String[] args)
	{
		if (args.length != 2)
		{
			System.err.println("usage: java RegExDemo regex input");
			return;
		}
		try
		{
			System.out.println("regex = " + args[0]);
			System.out.println("input = " + args[1]);
			Pattern p = Pattern.compile(args[0]);//compile the pattern
			Matcher m = p.matcher(args[1]);//create the match object with the input
			while (m.find())
				System.out.println("Located [" + m.group() + "] starting at " + m.start() + " and ending at " + (m.end() - 1));
		}
		catch (PatternSyntaxException pse)
		{
			System.err.println("Bad regex: " + pse.getMessage());
			System.err.println("Description: " + pse.getDescription());
			System.err.println("Index: " + pse.getIndex());
			System.err.println("Incorrect pattern: " + pse.getPattern());
		}
	}
}
regex = ox
input = box
Located [ox] starting at 1 and ending at 2
...........Character Classes
match any char within []

A   simple character class:
java RegExDemo t[aiou]ck tack //match

A   negation character class:
[^abc]consists of all characters except for a, b, and c.

java RegExDemo "[^b]ox" box //no match
java RegExDemo "[^b]ox" fox //match

A   range character class:
[a-z]consists of all characters from athrough z. 
[A-Za-z]consists of all uppercase and lowercase Latin letters.

java RegExDemo [h-l]ouse house // match
java RegExDemo [h-l]ouse mouse // no match

A   union character class:
[abc[u-z]]consists of characters a, b, c, u, v, w, x, y, and z. 

java RegExDemo [[0.9][A-F][a-f]] e // match	

An    intersection character class:
[a-c&&[c-f]]consists of character c

java RegExDemo "[aeiouy&&[y]]" y // match, the pattern contain only y

A   subtraction character class:
[a-z&&[^x-z]]consists of characters a through w. 

java RegExDemo "[a-z&&[^aeiou]]" g //match, g is not removed from the class

...........Capturing Groups
A capturing groupsaves a match.s characters for later recall during pattern matching and is expressed as a character sequence surrounded by parentheses metacharacters (and ). All characters within a capturing group are treated as a unit. 
 Each nested or nonnested capturing group receives its own number, numbering starts at 1, and capturing groups are numbered from left to right.  For example, ((A) (B(C)))is assigned 1, (A)is assigned 2, (B(C))is assigned 3, and (C)is assigned 4.

The back reference causes the matcher to use the back reference.s capturing group number to recall the capturing group.s saved match and then use that match.s characters to attempt a further match. 

java RegExDemo "(Android) \1" "Android Android" //match

...........Boundary Matchers and Zero-Length Matches
\d Match any digit character. \d is equivalent to [0.9].
\D Match any nondigit character. \D is equivalent to [^\d].
\s Match any whitespace character. \s is equivalent to [\t\n\x0B\f\r ].
\S Match any nonwhitespace character. \S is equivalent to [^\s].
\w Match any word character. \w is equivalent to [a-zA-Z0-9].
\W Match any nonword character. \W is equivalent to [^\w]

^ Match beginning of line.
$ Match end of line.
\b Match word boundary.
\B Match nonword boundary.
\A Match beginning of text.
\G Match end of previous match.
\Z Match end of text except for line terminator (when present).
\z Match end of text.

...........Quantifiers
A   greedy quantifier(?, *, or +) attempts to find the longest match. 
X? to find one or no occurrences of X, 
X* to find zero or more occurrences of X, 
X+ to find one or more occurrences of X, 
X{n} to find n occurrences of X, 
X{n,} to find at least n(and possibly more) occurrences of X, 
X{n,m} to find at least n but no more than m occurrences of X.

A   reluctant quantifier(??, *?, or +?) attempts to find the shortest match.
X??  to find one or no occurrences of X, 
X*?to find zero or more occurrences of X, 
X+?to find one or more occurrences of X,
X{n}? to find noccurrences of X, 
X{n,}? to find at least n(and possibly more) occurrences of X, 
X{n,m}?  to find at least nbut no more than moccurrences of X.

A   possessive quantifier(?+, *+, or ++) is similar to a greedy quantifier except that a possessive quantifier only makes one attempt to find the longest match, whereas a greedy quantifier can make multiple attempts.  
X?+ to find one or no occurrences of X, 
X*+ to find zero or more occurrences of X, 
X++ to find one or more occurrences of X, 
X{n}+ to find noccurrences of X, 
X{n,}+ to find at least n(and possibly more) occurrences of X, 
X{n,m}+ to find at least n but no more than moccurrences of X.

"greedy quantifier"
java RegExDemo .*end "wend rend end"

regex = .*end
input = wend rend end
Located [wend rend end] starting at 0 and ending at 12

"reluctant quantifier"
java RegExDemo .*?end "wend rend end"

regex = .*?end
input = wend rend end
Located [wend] starting at 0 and ending at 3
Located [ rend] starting at 4 and ending at 8
Located [ end] starting at 9 and ending at 12

"possessive quantifier"
java RegExDemo .*+end "wend rend end"

regex = .*+end
input = wend rend end

The possessive quantifier (.*+) doesn.t detect a match because it consumes the entire input text, leaving nothing left over to match endat the end of the regex. Unlike a greedy quantifier, a possessive quantifier doesn.t back off.//Which means the * reach the end of the line, and it does not back off, so can not match end. It also means *+ can not have anthing following.

...........Practical Regular Expressions
match phone numbers in the form (ddd) ddd-ddddor ddd-dddd:

java RegExDemo "(\(\d{3}\))?\s*\d{3}-\d{4}" "(800) 555-1212"
regex = (\(\d{3}\))?\s*\d{3}-\d{4}
input = (800) 555.1212
Located [(800) 555.1212] starting at 0 and ending at 13

java RegExDemo "(\(\d{3}\))?\s*\d{3}-\d{4}" 555.1212
regex = (\(\d{3}\))?\s*\d{3}-\d{4}
input = 555.1212
Located [555.1212] starting at 0 and ending at 7

//(\(\d{3}\))? : find 0 or more in () with ()?, protected( and ), with 3 digits
//\s*\d{3}-\d{4}:one or more spaces or tabs and 3 digit, -, 4 digit
  
......................Java DB
Java DB is capable of running in an embedded environment or in a client/server environment.  In an embedded environment, where an application accesses the database engine via Java DB.s embedded driver, the database engine runs in the same virtual machine as the application. 

In a client/server environment, client applications and the database engine run in separate virtual machines. A client application accesses the network server through Java DB.s client driver. The network server, which runs in the same virtual machine as the database engine, accesses the database engine through the embedded driver.

When you install JDK 7 with the default settings, the bundled Java DB is installed into 
%JAVA_HOME%\db 
on Windows platforms or into the dbsubdirectory in the equivalent location on Unix/Linux platforms. 

Before you can run the tools and start/stop the network server, you must set the DERBY_HOME environment variable. Set this variable for Windows via set
DERBY_HOME=%JAVA_HOME%\db, 

and for Unix (Korn shell) via 

export DERBY_HOME=$JAVA_HOME/db. 

For the embedded environment, invoke    setEmbeddedCP to add derby.jar and derbytools.jar to the classpath.

For the client/server environment, invoke    setNetworkServerCP to add derbynet.jar and derbytools.jar to the classpath. In a separate command window, invoke setNetworkClientCP to add derbyclient.jar and derbytools.jar to the classpath.

...........Java DB Command-Line Tools
Consider Java DB. The URL syntax varies depending on the driver. For the embedded driver (when you want to access a local database), this syntax is as follows: 

jdbc:derby:databaseName;URLAttributes

Connection con = DriverManager.getConnection("jdbc:derby:testdb;create=true");

ient driver (when you want to access a remote database, although you can also access a local database with this driver), this syntax is as follows:

jdbc:derby://host:port/databaseName;URLAttributes

Connection con;
con = DriverManager.getConnection("jdbc:derby://xyz:8500/testdb;create=true");

Connection con1 = DriverManager.getConnection("jdbc:sqlite:sample.db");
Connection con2 = DriverManager.getConnection("jdbc:sqlite:C:/temp/sample.db");

SQLite also supports in-memory database management, which doesn.t create any database files. 
The following example shows you how to connect to an existing in-memory database:

Connection con = DriverManager.getConnection("jdbc:sqlite::memory:");

The following example shows you how to create and obtain a connection to an in-memory database:

Connection con = DriverManager.getConnection("jdbc:sqlite:");

//Listing 14-1.  Architecting a Basic JDBC Application
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
public class JDBCDemo
{
	final static String URL1 = "jdbc:derby:employee;create=true";
	final static String URL2 = "jdbc:sqlite:employee";
	public static void main(String[] args)
	{
		String url = null;
		if (args.length != 1)
		{
			System.err.println("usage 1: java JDBCDemo javadb");
			System.err.println("usage 2: java JDBCDemo sqlite");
			return;
		}
		if (args[0].equals("javadb"))
			url = URL1;
		else
			if (args[0].equals("sqlite"))
				url = URL2;
			else
			{
				System.err.println("invalid command-line argument");
				return;
			}
		Connection con = null;
		try
		{
			if (args[0].equals("sqlite"))
				Class.forName("org.sqlite.JDBC");
			con = DriverManager.getConnection(url);
			// Perform useful work. The following throw statement simulates a
			// JDBC method throwing SQLException.
			throw new SQLException("Unable to access database table", new java.io.IOException("File I/O problem"));
		}
		catch (ClassNotFoundException cnfe)
		{
			System.err.println("unable to load sqlite driver");
		}
		catch (SQLException sqlex)
		{
			while (sqlex != null)
			{
				System.err.println("SQL error : " + sqlex.getMessage());
				System.err.println("SQL state : " + sqlex.getSQLState());
				System.err.println("Error code: " + sqlex.getErrorCode());
				System.err.println("Cause: " + sqlex.getCause());
				sqlex = sqlex.getNextException();
			}
		}
		finally
		{
			if (con != null)
				try
				{
					con.close();
				}
				catch (SQLException sqle)
				{
					sqle.printStackTrace();
				}
		}
	}
}
...........Statement and ResultSet
//Listing 14-2.  Creating, Inserting Values into, Querying, and Dropping an EMPLOYEES Table
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
public class JDBCDemo
{
	final static String URL1 = "jdbc:derby:employee;create=true";
	final static String URL2 = "jdbc:sqlite:employee";
	public static void main(String[] args)
	{
		String url = null;
		if (args.length != 1)
		{
			System.err.println("usage 1: java JDBCDemo javadb");
			System.err.println("usage 2: java JDBCDemo sqlite");
			return;
		}
		if (args[0].equals("javadb"))
			url = URL1;
		else
			if (args[0].equals("sqlite"))
				url = URL2;
			else
			{
				System.err.println("invalid command-line argument");
				return;
			}
		Connection con = null;
		try
		{
			if (args[0].equals("sqlite"))
				Class.forName("org.sqlite.JDBC");
			con = DriverManager.getConnection(url);
			Statement stmt = null;
			try
			{
				stmt = con.createStatement();
				String sql = "CREATE TABLE EMPLOYEES(ID INTEGER, NAME VARCHAR(30))";
				stmt.executeUpdate(sql);
				sql = "INSERT INTO EMPLOYEES VALUES(1, 'John Doe')";
				stmt.executeUpdate(sql);
				sql = "INSERT INTO EMPLOYEES VALUES(2, 'Sally Smith')";
				stmt.executeUpdate(sql);
				ResultSet rs = stmt.executeQuery("SELECT * FROM EMPLOYEES");
				while (rs.next())
					System.out.println(rs.getInt("ID") + " " + rs.getString("NAME"));//getInt() returns the column ID.
					stmt.executeUpdate("DROP TABLE EMPLOYEES");
			}
			catch (SQLException sqlex)
			{
				while (sqlex != null)
				{
					System.err.println("SQL error : " + sqlex.getMessage());
					System.err.println("SQL state : " + sqlex.getSQLState());
					System.err.println("Error code: " + sqlex.getErrorCode());
					System.err.println("Cause: " + sqlex.getCause());
					sqlex = sqlex.getNextException();
				}
			}
			finally
			{
				if (stmt != null)
					try
					{
						stmt.close();
					}
					catch (SQLException sqle)
					{
						sqle.printStackTrace();
					}
			}
		}
		catch (ClassNotFoundException cnfe)
		{
			System.err.println("unable to load sqlite driver");
		}
		catch (SQLException sqlex)
		{
			while (sqlex != null)
			{
				System.err.println("SQL error : " + sqlex.getMessage());
				System.err.println("SQL state : " + sqlex.getSQLState());
				System.err.println("Error code: " + sqlex.getErrorCode());
				System.err.println("Cause: " + sqlex.getCause());
				sqlex = sqlex.getNextException();
			}
		}
		finally
		{
			if (con != null)
				try
				{
					con.close();
				}
				catch (SQLException sqle)
				{
					sqle.printStackTrace();
				}
		}
	}
}
1 John Doe
2 Sally Smith

Table 14-1. SQL Type/Java Type Mappings
SQL Type 		Java Type
ARRAY 			java.sql.Array
BIGINT 			long
BINARY 			byte[]
BIT 			boolean
BLOB 			java.sql.Blob
BOOLEAN		 	boolean
CHAR 			java.lang.String
CLOB 			java.sql.Clob
DATE 			java.sql.Date
DECIMAL 		java.math.BigDecimal
DOUBLE 			double
FLOAT 			double
INTEGER 		int
LONGVARBINARY 	byte[]
LONGVARCHAR 	java.lang.String
NUMERIC 		java.math.BigDecimal
REAL 			Float
REF 			java.sql.Ref
SMALLINT 		Short
STRUCT 			java.sql.Struct
TIME 			java.sql.Time
TIMESTAMP 		java.sql.Timestamp
TINYINT 		Byte
VARBINARY 		byte[]
VARCHAR 		java.lang.String

........... PreparedStatement
//Listing 14-3.  Creating, Inserting Values via a Prepared Statement into,
//Querying, and Dropping an EMPLOYEES Table

//Same script as above, only the try part:
Connection con = null;
try
{
	if (args[0].equals("sqlite"))
		Class.forName("org.sqlite.JDBC");
	con = DriverManager.getConnection(url);
	Statement stmt = null;
	try
	{
		stmt = con.createStatement();
		String sql = "CREATE TABLE EMPLOYEES(ID INTEGER, NAME VARCHAR(30))";
		stmt.executeUpdate(sql);
		PreparedStatement pstmt = null;
		try
		{
			pstmt = con.prepareStatement("INSERT INTO EMPLOYEES VALUES(?, ?)");// ? is place holder
			String[] empNames = { "John Doe", "Sally Smith" };
			for (int i = 0; i < empNames.length; i++)
			{
				pstmt.setInt(1, i+1);//place holder 1, column number start from 1, or i +1
				pstmt.setString(2, empNames[i]);//place holder 2
				pstmt.executeUpdate();
			}
			ResultSet rs = stmt.executeQuery("SELECT * FROM EMPLOYEES");
			while (rs.next())
				System.out.println(rs.getInt("ID") + " " + rs.getString("NAME"));
			stmt.executeUpdate("DROP TABLE EMPLOYEES");
		}
		catch (SQLException sqlex)
		{
			while (sqlex != null)
			{
				System.err.println("SQL error : " + sqlex.getMessage());
				System.err.println("SQL state : " + sqlex.getSQLState());
				System.err.println("Error code: " + sqlex.getErrorCode());
				System.err.println("Cause: " + sqlex.getCause());
				sqlex = sqlex.getNextException();
				}
			}
	finally
	{
		if (pstmt != null)
			try
			{
				pstmt.close();
			}
			catch (SQLException sqle)
			{
				sqle.printStackTrace();
			}
	}
}
...........CallableStatement : stored procedure
a stored procedure.s body is implemented as a public staticJava method.  Furthermore, the class in which this method is declared must be public.

SQLite does not support stored procedure.

CallableStatement cstmt = null;
try
{
	cstmt = con.prepareCall("{ call FIRE(?)}"))
	cstmt.setInt(1, 2);//set the 1st place holder in the above line to 2, 2nd row.
	cstmt.execute();
}
catch (SQLException sqle)
{
// handle the exception
}
finally
{
// close the callable statement
}


//Listing 14-4.  Firing an Employee via a Stored Procedure
import java.sql.CallableStatement;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
publicclass JDBCDemo
{
	public static void main(String[] args)
	{
		String url = "jdbc:derby:employee;create=true";
		Connection con = null;
		try
		{
			con = DriverManager.getConnection(url);
			Statement stmt = null;
			try
			{
				stmt = con.createStatement();
				String sql = "CREATE PROCEDURE FIRE(IN ID INTEGER)" +
							" PARAMETER STYLE JAVA" +
							" LANGUAGE JAVA" +
							" DYNAMIC RESULT SETS 0" +
							" EXTERNAL NAME 'JDBCDemo.fire'";
				stmt.executeUpdate(sql);
				sql = "CREATE TABLE EMPLOYEES(ID INTEGER, NAME VARCHAR(30), " + "FIRED BOOLEAN)";
				stmt.executeUpdate(sql);
				sql = "INSERT INTO EMPLOYEES VALUES(1, 'John Doe', false)";
				stmt.executeUpdate(sql);
				sql = "INSERT INTO EMPLOYEES VALUES(2, 'Sally Smith', false)";
				stmt.executeUpdate(sql);
				dump(stmt.executeQuery("SELECT * FROM EMPLOYEES"));
				CallableStatement cstmt = null;
				try
				{
					cstmt = con.prepareCall("{ call FIRE(?)}");
					cstmt.setInt(1, 2);
					cstmt.execute();
					dump(stmt.executeQuery("SELECT * FROM EMPLOYEES"));
					stmt.executeUpdate("DROP TABLE EMPLOYEES");
					stmt.executeUpdate("DROP PROCEDURE FIRE");
				}
				catch (SQLException sqlex)
				{
					while (sqlex != null)
					{
						System.err.println("SQL error : " + sqlex.getMessage());
						System.err.println("SQL state : " + sqlex.getSQLState());
						System.err.println("Error code: " + sqlex.getErrorCode());
						System.err.println("Cause: " + sqlex.getCause());
						sqlex = sqlex.getNextException();
					}
				}
				finally
				{
					if (cstmt != null)
						try
						{
							cstmt.close();
						}
						catch (SQLException sqle)
						{
							sqle.printStackTrace();
						}
				}
			}
			catch (SQLException sqlex)
			{
				while (sqlex != null)
				{
					System.err.println("SQL error : " + sqlex.getMessage());
					System.err.println("SQL state : " + sqlex.getSQLState());
					System.err.println("Error code: " + sqlex.getErrorCode());
					System.err.println("Cause: " + sqlex.getCause());
					sqlex = sqlex.getNextException();
				}
			}
			finally
			{
				if (stmt != null)
					try
					{
						stmt.close();
					}
					catch (SQLException sqle)
					{
						sqle.printStackTrace();
					}
			}
		}
		catch (SQLException sqlex)
		{
			while (sqlex != null)
			{
				System.err.println("SQL error : " + sqlex.getMessage());
				System.err.println("SQL state : " + sqlex.getSQLState());
				System.err.println("Error code: " + sqlex.getErrorCode());
				System.err.println("Cause: " + sqlex.getCause());
				sqlex = sqlex.getNextException();
			}
		}
		finally
		{
			if (con != null)
				try
				{
					con.close();
				}
				catch (SQLException sqle)
				{
					sqle.printStackTrace();
				}
		}
	}
	static void dump(ResultSet rs) throws SQLException
	{
		StringBuilder sb = new StringBuilder();
		while (rs.next())
		{
			sb.append(rs.getInt("ID"));
			sb.append(' ');
			sb.append(rs.getString("NAME"));
			sb.append(' ');
			sb.append(rs.getBoolean("FIRED"));
			System.out.println(sb);
			sb.setLength(0);
		}
		System.out.println();
	}
	public staticvoid fire(int id) throws SQLException
	{
		Connection con = DriverManager.getConnection("jdbc:default:connection");//access the current connection
		String sql = "UPDATE EMPLOYEES SET FIRED=TRUE WHERE ID=" + id;
		Statement stmt = null;
		try
		{
			stmt = con.createStatement();
			stmt.executeUpdate(sql);
		}
		finally
		{
			if (stmt != null)
				try
				{
					stmt.close();
				}
				catch (SQLException sqle)
				{
					sqle.printStackTrace();
				}
		}
	}
}
1 John Doe false
2 Sally Smith false
1 John Doe false
2 Sally Smith true
...................... Metadata
//Listing 14-5.  Obtaining Metadata from an Employee Data Source
import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
public class JDBCDemo
{
	public static void main(String[] args)
	{
		String url = "jdbc:derby:employee;create=true";
		Connection con = null;
		try
		{
			con = DriverManager.getConnection(url);
			dump(con.getMetaData());
		}
		catch (SQLException sqlex)
		{
			while (sqlex != null)
			{
				System.err.println("SQL error : " + sqlex.getMessage());
				System.err.println("SQL state : " + sqlex.getSQLState());
				System.err.println("Error code: " + sqlex.getErrorCode());
				System.err.println("Cause: " + sqlex.getCause());
				sqlex = sqlex.getNextException();
			}
		}
		finally
		{
			if (con != null)
				try
				{
					con.close();
				}
				catch (SQLException sqle)
				{
					sqle.printStackTrace();
				}
		}
	}
	static void dump(DatabaseMetaData dbmd) throws SQLException
	{
		System.out.println("DB Major Version = " + dbmd.getDatabaseMajorVersion());
		System.out.println("DB Minor Version = " + dbmd.getDatabaseMinorVersion());
		System.out.println("DB Product = " + dbmd.getDatabaseProductName());
		System.out.println("Driver Name = " + dbmd.getDriverName());
		System.out.println("Numeric function names for escape clause = " + dbmd.getNumericFunctions());
		System.out.println("String function names for escape clause = " + dbmd.getStringFunctions());
		System.out.println("System function names for escape clause = " + dbmd.getSystemFunctions());
		System.out.println("Time/date function names for escape clause = " + dbmd.getTimeDateFunctions());
		System.out.println("Catalog term: " + dbmd.getCatalogTerm());
		System.out.println("Schema term: " + dbmd.getSchemaTerm());
		System.out.println();
		System.out.println("Catalogs");
		System.out.println("--------");
		ResultSet rsCat = dbmd.getCatalogs();
		while (rsCat.next())
			System.out.println(rsCat.getString("TABLE_CAT"));
			System.out.println();
			System.out.println("Schemas");
			System.out.println("-------");
			ResultSet rsSchem = dbmd.getSchemas();
		while (rsSchem.next())
			System.out.println(rsSchem.getString("TABLE_SCHEM"));
			System.out.println();
			System.out.println("Schema/Table");
			System.out.println("------------");
			rsSchem = dbmd.getSchemas();
		while (rsSchem.next())
		{
			String schem = rsSchem.getString("TABLE_SCHEM");
			ResultSet rsTab = dbmd.getTables(null, schem, "%", null);
			while (rsTab.next())
				System.out.println(schem + " " + rsTab.getString("TABLE_NAME"));
		}
	}
}

//Listing 14-6.  Determining the Existence of EmployeeBefore Creating This Table
//only the interesting part
try
{
	stmt = con.createStatement();
	String sql;
	if (!isExist(con, "EMPLOYEES"))
	{
		System.out.println("EMPLOYEES doesn't exist");
		sql = "CREATE TABLE EMPLOYEES(ID INTEGER, NAME VARCHAR(30))";
		stmt.executeUpdate(sql);
	}
	else
		System.out.println("EMPLOYEES already exists");
		sql = "INSERT INTO EMPLOYEES VALUES(1, 'John Doe')";
		stmt.executeUpdate(sql);
		sql = "INSERT INTO EMPLOYEES VALUES(2, 'Sally Smith')";
		stmt.executeUpdate(sql);
		ResultSet rs = stmt.executeQuery("SELECT * FROM EMPLOYEES");
	while (rs.next())
		System.out.println(rs.getInt("ID") + " " + rs.getString("NAME"));
	stmt.executeUpdate("DROP TABLE EMPLOYEES");
	}
	catch (SQLException sqlex)
	{
		while (sqlex != null)
		{
			System.err.println("SQL error : " + sqlex.getMessage());
			System.err.println("SQL state : " + sqlex.getSQLState());
			System.err.println("Error code: " + sqlex.getErrorCode());
			System.err.println("Cause: " + sqlex.getCause());
			sqlex = sqlex.getNextException();
		}
	}
	finally
	{
		if (stmt != null)
			try
			{
				stmt.close();
			}
			catch (SQLException sqle)
			{
				sqle.printStackTrace();
			}
	}
}
 ...
 ...
static boolean isExist(Connection con, String tableName) throws SQLException
{
	DatabaseMetaData dbmd = con.getMetaData();
	ResultSet rs = dbmd.getTables(null, "APP", tableName, null);
	return rs.next();
}

//When the specified table exists, a ResultSetobject containing one row is returned, and ResultSet.s next()method returns true. Otherwise, the result set contains no rows and next()returns false.
Caution  isExist()assumes the default APPschema, which might not be the case when usernames are involved (each user.s database objects are stored in a schema corresponding to the user.s name).

#################################
For eclipse
ctrl + shift + O: to automatically add imports
ctrl + shift + J: to add javadoc comment
Ctrl+spacebar : auto-complete
append a class with "." to see its methods or fields.
double click on a script file tab to enlarge the tab.
Ctrl + Alt + R: to rename file, class ...
Ctrl + shift + F : to formate selected code, or the entire code if no selection

Rename

#################################

......................Application context
retrieve the application context for the current process :

Context context = getApplicationContext();

Because the Activity class is derived from the Context class, you can use the this object instead of retrieving the application context explicitly when you.re writing code inside your Activity class.

You might be tempted to just use your Activity context in all cases. Doing so can lead to memory leaks,though. 

...........Application resources
retrieve application resources by using the getResources() method of the application context. The most straightforward way to retrieve a resource is by using its unique resource identifier, as defined in the automatically generated R.java class.

String greeting = getResources().getString(R.string.hello);

..........Application Preferences
retrieve shared application preferences by using the getSharedPreferences() method of the application context.
use the SharedPreferencesclass to save simple application data, such as configuration set-tings.

SharedPreferences settings = getSharedPreferences("GamePrefs", MODE_PRIVATE);
SharedPreferences.Editor prefEditor = settings.edit();
prefEditor.putString("UserName", "Spunky");
prefEditor.putBoolean("HasCredits", true);
prefEditor.commit();

To retrieve preference settings, you simply retrieve SharedPreferencesand read the values back out:

SharedPreferences settings = getSharedPreferences("GamePrefs", MODE_PRIVATE);
String userName = settings.getString("UserName", "Chippy Jr" (Default).);

SharedPreferences settings = getSharedPreferences(GAME_PREFERENCES, MODE_PRIVATE);
SharedPreferences.Editor prefEditor = settings.edit();
prefEditor.putString("UserName", "JaneDoe");
prefEditor.putInt("UserAge", 22);
prefEditor.commit();

SharedPreferences settings = getSharedPreferences(GAME_PREFERENCES, MODE_PRIVATE);
if(settings.contains("UserName") == true) {
	// We have a user name
	String user = settings.getString("UserName", "Default");
}
You can al so use the shared pref erences edi tor to cl ear al l pref erences, usi ng the clear()method, and to remove specific preferences by name, using the remove() method.


...........Accessing Other Application Functionality Using Contexts
.LaunchActivityinstances
.Retrieve assets packaged with the application
.Request a system-level service provider (for example, location service)
.Manage private application files, directories, and databases
.Inspect and enforce application permissions

......................Working with Activities
...........Launching Activities
1. .Designating a launch activity in the manifest file

2. .Launching an activity using the application context 
The most common way to launch an activityis to use the startActivity()method of the application context. This method takes one parameter, called an Intent.

startActivity(new Intent(getApplicationContext(), MenuActivity.class));

Because the MenuActivityclass is defined within this application.s package, it must be registered as an activity within the Android manifest file. 

3. .Launching a child activity from a parent activity for a result

When an activity needs a result , it can be launched using the Activity.startActivityForResult() method.  The result is returned in the Intent parameter of the calling activity.s onActivityResult()method.

........... Using Activity Callbacks

TABLE 3.1 Key Callback Methods of Android Activities
Callback Method 	Description 					Recommendations
--------------------------------------------------------------------
onCreate() 			Called when an activity starts 	Initializes static activity data. 
					or restarts. 					Binds to data or resources
													required. Sets layout with
													setContentView().

onResume() 			Called when an activity  		Acquires exclusive resources. 
					becomes the foreground  		Starts any audio,video,or 
					activity. 						animations.

onPause() 			Called when an activity  		Saves uncommitted data. 
					leaves the foreground. 			Deactivates or releases exclusive
													resources. Stops any audio,
													video,or animations.

onDestroy() 		Called when an application is 	Cleans up any static activity data. 
					shutting down. 					Releases any resources acquired.

...........Saving Activity State
An activity can have private preferences.much like shared application preferences.  You can access these preferences by using the "getPreferences()" method of the activity. This mechanism is useful for saving state information.

...........Shutting Down Activities
To shut down anactivity, you make a call to the finish()method. There are sever-al different versions of this method to use, depending whether the activity is shut-ting itself down or shutting down another activity.

......................Working with Intents
An Intentobject encapsulates a task request used by the Android operating system.
When the startActivity() method is called with the Intent parameter, the Android system matches the Intent action with the appropriate activity on the Android system. That activity is then launched.
The Android system handles all intent resolution.
...........Passing Information with Intents
Intents can be used to pass data between activities. You can use an intent in this way by including additional data, called "extras", within the intent.
To package extra pieces of data alongwith an intent, you use the putExtra() method with the appropriate type of object you wantto include. 

Intent intent = new Intent(getApplicationContext(), HelpActivity.class);
intent.putExtra("com.androidbook.chippy.LEVEL", 23);
startActivity(intent);

When the HelpActivity class launches, the getIntent() method can be used to retrieve the intent. Then the extra information can be extracted 

Intent callingIntent = getIntent();
int helpLevel = callingIntent.getIntExtra("com.androidbook.chippy.LEVEL", 1);

...........Using Intents to Launch Other Applications
.Launching the built-in web browser and supplying a URL address
.Launching the web browser and supplying a search string
.Launching the built-in Dialer application and supplying a phone number
.Launching the built-in Maps application and supplying a location
.Launching Google Street View and supplying a location
.Launching the built-in Camera application in still or video mode
.Launching a ringtone picker
.Recording a sound
exmale:
Uri address = Uri.parse("http://www.perlgurl.org");
Intent surf = new Intent(Intent.ACTION_VIEW, address);
startActivity(surf);

For this example, the browser.s activity then starts and comes into foreground, caus-ing the original calling activity to pause in the background.  When the user finishes with the browser and clicks the Back button, the original activity resumes.

...........Working with Dialogs

TABLE 3.2 Important Dialog Methods of the Activity Class
Method 						Purpose
Activity.showDialog() 		Shows a dialog,creating it if necessary.

Activity.onCreateDialog() 	Is a callback when a dialog is being created for
							the first time and added to the activity dialog
							pool.

Activity.onPrepareDialog() 	Is a callback for updating a dialog on-the-fly.
							Dialogs are created once and can be used many
							times by an activity. This callback enables the
							dialog to be updated just before it is shown for
							each showDialog()call.

Activity.dismissDialog() 	Dismisses a dialog and returns to the activity.
							The dialog is still available to be used again by
							calling showDialog() again.

Activity.removeDialog() 	Removes the dialog completely from the activity
							dialog pool.

There are quite a few types of ready-made dialog types available for use in addition to the basic dialog. These are AlertDialog, CharacterPickerDialog, DatePickerDialog, ProgressDialog, and TimePickerDialog.

......................Working with Fragments
A fragment is simply a block of UI, with its own life cycle, that can be reused within different activities. Fragments allow developers to create highly modular user interfacecomponents that can change dramatically based on screen sizes, orientation, and other aspects of the dis-play that might be relevant to the design.

TABLE 3.3 Key Fragment Lifecycle Callbacks
Method 			Purpose
onCreateView() 	Called when the fragment needs to create its view
onStart() 		Called when the fragment is made visible to the user
onPause() 		Similar to Activity.onPause()
onStop() 		Called when the fragment is no longer visible
onDestroy() 	Final fragment cleanup

Although the lifecycle of a fragment is similar to that of an activity, a fragment only exists within an activity. A common example of fragment usage is to change the UI flow between portrait and landscape modes.
......................Logging Application Information
TABLE 3.4 Commonly Used Log Methods
Method 		Purpose
Log.e() 	Logs errors
Log.w() 	Logs warnings
Log.i() 	Logs informational messages
Log.d() 	Logs debug messages
Log.v() 	Logs verbose messages
Log.wtf() 	Logs messages for events that should not happen (like during a
			failed assert)

The first parameter of each Log method is a string called a tag.
One common Android programming practice is to define a global static string to represent the overall application or the specific activity within the application such that log filters can be created to limit the log output to specific data.

import android.util.Log
private static final String TAG= "MyApp";

Log.i(TAG, "In onCreate() callback method");

The tag can be used in Eclipse to filter out error messages.

can add standard methods like onStart(), onResume(), onStop() ... by right click on the java code in Eclipse.

......................resources

.Resource filenames must be lowercase.
.Resource filenames may contain letters, numbers, underscores, and periods only.
.Resource filenames (and XML name attributes) must be unique.

When resources are compiled, their name dictates their variable name. For example, a graphics file saved within the /drawable directory as mypic.jpg is referenced as "@drawable/mypic". It is important to name resource names intelligently and be aware of character limitations that are stricter than file system names. (For exam-ple, dashes cannot be used in image filenames.)

Application resources can be accessed programmatically using the generated class file called R.java. 

For example, to retrieve a string named hello defined in the strings.xml resource file, use the following method call:

String greeting = getResources().getString(R.string.hello);


To reference an application resource from another compiled resource, such as a lay-out file, use the following format:

@[resource type]/[resource name]
@string/hello

...........system resources
Try to use more system resources to keep application small and efficient.
System resources are stored within the "android.R" package. 

String confirm = Resources.getSystem().getString(android.R.string.ok);

To reference a system resource from another compiled resource, such as a layout resource file, use the following format:
@android:[resource type]/[resource name]
@android:string/ok

Here is an example of a string resource file:

<?xmlversion="1.0"encoding="utf-8"?>
<resources>
	<stringname="app_name">Name this App</string>
	<stringname="hello">Hello</string>
</resources>

TABLE  4.1 String Resource Formatting Examples
String Resource Value 	Will Be Displayed As

Hello,World 			Hello,World
"Hello,World" 			Hello,World
Mother\'s Maiden Name: 	Mother's Maiden Name:
He said,\"No.\" 		He said,"No."

The simplest way is to use the getString()method within your Activityclass:

String greeting = getResources().getString(R.string.hello);

...........Working with Colors
in /res/values/colors.xml
TABLE  4.2 Color Formats Supported in Android
Format 		Description 			Example
#RGB 		12-bit color 			#00F (blue)
#ARGB 		12-bit color with alpha #800F (blue,alpha 50%)
#RRGGBB		24-bit color 			#FF00FF (magenta)
#AARRGGBB 	24-bit color with alpha #80FF00FF (magenta,alpha 50%)

<?xmlversion="1.0"encoding="utf-8"?>
<resources>
	<colorname="background_color">#006400</color>
	<colorname="app_text_color">#FFE4C4</color>
</resources>

int textColor = getResources().getColor(R.color.app_text_color);
...........Working with Dimensions
in /res/values/dimens.xml
<?xmlversion="1.0"encoding="utf-8"?>
<resources>
	<dimenname="thumbDim">100px</dimen>
</resources>

float thumbnailDim = getResources().getDimension(R.dimen.thumbDim);

TABLE  4.3 Dimension Unit Measurements Supported in Android
Type of Measurement 		Description 					Unit String
Pixels 						Actual screen pixels 			px
Inches 						Physical measurement 			in
Millimeters 				Physical measurement 			mm
Points 						Common font measurement 		pt
Density-independent pixels 	Pixels relative to 160dpi  		dp
Scale-independent pixels 	Best for scalable font display 	sp

...........Working with Drawable Resources

...........Working with Images
TABLE  4.4 Image Formats Supported in Android
Supported Image Format 		Description Required 		Extension

Portable Network Graphics 	Preferred format (lossless) .png (PNG)
Nine-Patch Stretchable  	Preferred format (lossless) .9.png (PNG)
Images

Joint Photographic Experts  Acceptable format (lossy) 	.jpg (JPEG/JPG)
Group

Graphics Interchange  		Discouraged but supported  	.gif (GIF)
Format (lossless)

Image resources are encapsulated in theclass BitmapDrawable. To access a graphic resource file called /res/drawable/logo.pngwithin an Activityclass, use the getDrawable()method, as follows:

BitmapDrawable logoBitmap = (BitmapDrawable)getResources().getDrawable(R.drawable.logo);

The following Activityclass code sets and loads the logo.pngdrawable resource into an ImageViewcontrol named LogoImageView, which must be defined in advance:

ImageView logoView = (ImageView)findViewById(R.id.LogoImageView);

logoView.setImageResource(R.drawable.logo);

...........Working with Other Types of Drawables
In addition to graphics files, you can also create specially formatted XML files to describe other Drawable subclasses, such as ShapeDrawable. You can use the ShapeDrawable class to define different shapes, such as rectangles and ovals.  See the Android documentation for the android.graphics.drawablepackage for further information.

...........Working with Layouts
Most time in XML define where to put, and use color, deminsion ...
could also be generated dynamicly in activitys.
<?xmlversion=.1.0.encoding=.utf-8.?>
<LinearLayout
	xmlns:android="http://schemas.android.com/apk/res/android"
	android:orientation="vertical"
	android:layout_width="fill_parent"
	android:layout_height="fill_parent">
		<TextView
		android:layout_width="fill_parent"
		android:layout_height="wrap_content"
		android:text="@string/hello"/>
</LinearLayout>

"LinearLayout" is a view group that aligns all children in a single direction, vertically or horizontally. 

"RelativeLayout" is a view group that displays child views in relative positions. The position of each view can be specified as relative to sibling elements (such as to the left-of or below another view) or in positions relative to the parent RelativeLayout area (such as aligned to the bottom, left of center).  

"ListView" is a view group that displays a list of scrollable items. The list items are automatically inserted to the list using an Adapter that pulls content from a source such as an array or database query and converts each item result into a view that's placed into the list.

"GridView" is a ViewGroup that displays items in a two-dimensional, scrollable grid. The grid items are automatically inserted to the layout using a ListAdapter.  


Use the "Outline pane and the Properties pane" to define the color, font ...

...........Using Layout Resources Programmatically
Here's how you would retrieve a TextView object named TextView01 that has been defined in the layout resource file:
The id can be fine in the outline pange.

TextView txt = (TextView)findViewById(R.id.TextView01)

...........working with files
Additional xml files should be stored in /res/xml.

TABLE  4.5 XML Utility Packages 
Package 			Description
android.sax.* 		Framework to write standard SAX handlers
android.util.Xml.* 	XML utilities,including the XMLPullParser
org.xml.sax.* 		Core SAX functionality (see www.saxproject.org)
javax.xml.* 		SAX and limited DOM,Level 2 core support
org.w3c.dom 		Interfaces for DOM, Level 2 core
org.xmlpull.* 		XmlPullParser and XMLSerializer interfaces (see www.xmlpull.org)

To access an XML resource file called "/res/xml/default_values.xml" programmatically from within your Activityclass, you can use the getXml()method of the Resourcesclass, like this:

XmlResourceParser defaultDataConfig = getResources().getXml(R.xml.default_values);

After you have accessed the XML parser object, you can parse your XML, extract the appropriate data elements, and do with it whatever you wish.

...........Working with Raw Files

 All raw resource files, audio, videos...,  should be included in the /res/rawresource directory. 

For example, the following code creates an InputStreamobject to access to the resource file /res/raw/file1.txt:

InputStream iFile = getResources().openRawResource(R.raw.file1);

...........asset
There are times when you might want to include files within your application but not have them compiled into application resources. Android provides a special project directory called /assets for this purpose.
Any files included in this directory are included as binary resources,along with the application installation package,and are not compiled into the application.  
Uncompiled files,called application assets,are not accessible through the getResources() method. Instead,you must use AssetManager to access files included in the /assets directory.

...........Other Types of Resources
.Primitives (boolean values, integers)
.Arrays (string arrays, integer arrays, typed arrays)
.Menus
.Animation sequences
.Shape drawables
.Styles and themes
.Custom layout controls

......................Android Manifest File
.Install and upgrade the application package
.Display application details to users
.Launch application activities
.Manage application permissions
.Handle a number of other advanced application configurations, including acting as a service provider or content provider

<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.androidbook.droid1"
    android:versionCode="1"
    android:versionName="1.0" >

The version name is the traditional versioning information, used to keep track of application builds.

The version code enables the Android platform to programmatically upgrade and downgrade an application. 

Recall that Android applications comprise a numberof different activities.  Every activity must be registered within the Android manifest file by its class name before it can be run on the device.

the following XML excerpt defines an activity class called DroidActivity:
<activity
	android:name=".DroidActivity"/>

...........To define an activity: 

1. Open the Droid1 project in Eclipse.
2. Right-click /src/com.androidbook.droid1 and choose New, Class. The New Java Class window opens.
3. Name your new class DroidActivity2.
4. Click the Browse button next to the Superclass field and set the superclass to android.app.Activity.
5. Click the Finish button. You see the new class in your project.
6. Make a copy of the main.xml layout file in the /res/layout resource directory for your new activity and name it second.xml.
7. Open the DroidActivity2 class. Right-click within the class and choose Source, Override/Implement Methods. 
8. Check the box next to the onCreate(Bundle)method. This method is added to your class.
9. Within the onCreate() method, set the layout to load for the new activity by adding and calling the setContentView(R.layout.second) method. Save the class file. This is the layout created on step 6.
10. Open the Android manifest file and click the Application tab of the resource editor.
11. In the Application Nodes section of the Application tab, click the Add button and choose the Activity element. Make sure you are adding a top-level activi ty. The attributes for the activity are shown in the right side of the screen.
12. Click the Browse button next to the activity Name field. Choose the new activity you created, DroidActivity2.

Always need to use setContentView(R.layout.second); in onCreate(Bundle) method to specify the layout to use.
...........Designating the Launch Activity
You can use an Intent filter to designate an activity as the "primary entry point" of the application. The Intentfilter forlaunching an activity by default must be configured using an <intent-filter>tag with the "MAIN" action type and the "LAUNCHER" category. In the Droid1 project, the Android project wizard set DroidActivityas the primary launching point of the application:
<activity
	android:name=".DroidActivity"
	android:label=.@string/app_name.>
	<intent-filter>
		<action
			android:name="android.intent.action.MAIN"/>
		<category
			android:name="android.intent.category.LAUNCHER"/>
	</intent-filter>
</activity>
This <intent-filter> tag instructs the Android system to direct all application launch requests to the DroidActivity activity. It make the activity the primary entry point.

...........Managing Application Permissions
Each Android application exists in its own virtual machine and operates within its own Linux user account (see Figure 5.6).
Applications that want access to shared or privileged resources on the handset must declare those specific permissions in the Android manifest file.
......................Animation
.Animated GIF images.Animated GIFs are self-contained graphics files with multiple frames. 

.Frame-by-frame animation.The Android SDK provides a similar mecha-nism for frame-by-frame animation in which the developer supplies the individual graphic frames and transitions between them (see the AnimationDrawable class).

.Tweened animation.Tweened animation is a simple and flexible method of defining specific animation operations that can then be applied to any view or layout.

.OpenGL ES.Android.s OpenGL ES API provides advanced three-dimensional drawing, animation, lighting, and texturing capabilities.


With "tweened" animation, you create an animation sequence, either programmati-cally or by creating animation resources in the /res/animdirectory. Each anima-tion sequence needs its own XML file, but the same animation may be applied to any number of Viewcontrols within your application. You can also take advantage of built-in animation resources as well, provided in the android.R.animclass.

<?xml version="1.0"   encoding="utf-8"?>
<set xmlns:android="http://schemas.android.com/apk/res/android"
    android:shareInterpolator="false" >

    <alpha
        android:duration="2500"
        android:fromAlpha="0.0"
        android:toAlpha="1.0" >
    </alpha>

</set>

<?xml version="1.0"  encoding="utf-8"?>
<set xmlns:android="http://schemas.android.com/apk/res/android"
    android:shareInterpolator="false" >

    <rotate
        android:duration="2000"
        android:fromDegrees="0"
        android:pivotX="50%"
        android:pivotY="50%"
        android:toDegrees="360" />

    <alpha
        android:duration="2000"
        android:fromAlpha="0.0"
        android:toAlpha="1.0" >
    </alpha>

    <scale
        android:duration="2000"
        android:fromXScale=".1"
        android:fromYScale=".1"
        android:pivotX="50%"
        android:pivotY="50%"
        android:toXScale="1.0"
        android:toYScale="1.0" />

</set>

//Animation sequences must be applied and managed programmatically within your Activity class.in this case, the QuizSplashActivity class. 

The R.java is in /gen/....
Remove all the possible error from xml file, run "Project" -> clean.

...................... accessing raw files
you can access private application files and directories by using the following Contextclass methods: fileList(), getFilesDir(), getDir(), openFileInput(), openFileOutput(), deleteFile(), and getFileStreamPath().

The Android platform has a number of mechanisms forworking with XML data, including support for the following:
.SAX (Simple API for XML)
.XML Pull Parser
.Limited DOM Level 2 core support
