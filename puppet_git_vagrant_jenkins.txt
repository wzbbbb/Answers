fpm : package builder
http://www.tuxz.net/blog/archives/2012/09/08/how_to_easily_build_native_packages_of_everything/
https://github.com/jordansissel/fpm

mrepo(yam)
reprepo
pulp
.................................
package { "vim": 
	ensure => present, 
} 

type { title: 
	attribute => value, 
} 

save as test.pp, then:
puppet apply test.pp

...........
factor
......................
Installing on Red Hat Enterprise Linux and Fedora
# yum install ruby ruby-libs ruby-shadow

Next, to get the latest releases of Puppet, you will need to add the EPEL repository (see sidebar) to your host and then install packages from that repository. You can add the EPEL repository by adding the epel-releaseRPM (.rpm package manager). 
# rpm -Uvh http://download.fedora.redhat.com/pub/epel/5/i386/epel-release-5-3.noarch.rpm 

rpm -Uvh http://dl.fedoraproject.org/pub/epel/5/x86_64/epel-release-5-4.noarch.rpm

On the master,
# yum install puppet puppet-server facter
On the agent,
# yum install puppet facter 

puppetd --version

If puppet is not avaialbe in yum, run the following to add the puppet repository for yum, then run yum install

http://docs.puppetlabs.com/guides/puppetlabs_package_repositories.html

CentOS5:
i386
$ sudo rpm -ivh http://yum.puppetlabs.com/el/5/products/i386/puppetlabs-release-5-7.noarch.rpm

x86_64
$ sudo rpm -ivh http://yum.puppetlabs.com/el/5/products/x86_64/puppetlabs-release-5-7.noarch.rpm

Enterprise Linux 6:
i386
$ sudo rpm -ivh http://yum.puppetlabs.com/el/6/products/i386/puppetlabs-release-6-7.noarch.rpm

x86_64
$ sudo rpm -ivh http://yum.puppetlabs.com/el/6/products/x86_64/puppetlabs-release-6-7.noarch.rpm
.................................
config file
/etc/puppetlabs/puppet/puppet.conf

If not exist:
# puppetmasterd --genconfig > puppet.conf 
.................................
github
git config --global user.name 'zwa'
git config --global user.email 'zwa@orsyp.com'

To add /etc/puppetlabs to git repository.
root@cookbook:/etc/puppet# git init
Initialized empty Git repository in /etc/puppet/.git/
root@cookbook:/etc/puppet# git add manifests/ modules/
root@cookbook:/etc/puppet# git commit -m "initial commit"
[master (root-commit) c7a24cf] initial commit
 59 files changed, 1790 insertions(+), 0 deletions(-)
 create mode 100644 manifests/site.pp
 create mode 100644 manifests/utils.pp
 ...

git commit -a # to commit everything
env GIT_SSL_NO_VERIFY=true  git push -u origin master

git clone ssh://root@192.168.115.41//home/SD/sources sd.git

To stop tracking files 
git rm --cached *~				----
......................
To create a bare repository: --
git init --bare

To set global variables: ---
git config
config file: ---
.gitconfig
or
/etc/gitconfig
example:  ----
# configure the user which will be used by git
# Of course you should use your name
git config --global user.name "Example Surname"
# Same for the email address
git config --global user.email "your.email@gmail.com" 

# set default so that only the current branch is pushed 
git config --global push.default simple
# alternatively configure Git to push all matching branches
# git config --global push.default matching 

# set default so that you avoid unnecessary commits
git config --global branch.autosetuprebase always 

git config --global color.ui true
git config --global color.status auto
git config --global color.branch auto 

# setup vim as default editor for Git (Linux)
git config --global core.editor vim 

# setup kdiff3 as default merge tool (Linux)
git config --global merge.tool kdiff3

To check config ---
git config --list 
for global ----
git config --global --list 

Creating a .gitignore file for your repository ---
# ignore all bin directories
# matches "bin" in any subfolder
bin/
# ignore all target directories
target/
# ignore all files ending with ~
*~ 

triggering Jenkins builds from a git hook ---
http://kohsuke.org/2011/12/01/polling-must-die-triggering-jenkins-builds-from-a-git-hook/

curl http://yourserver/jenkins/git/notifyCommit?url=<URL of the Git repository>
.................................
Here’s a notify resource that depends on a file resource:

    file {'/tmp/test1':
      ensure  => present,
      content => "Hi.",
    }

    notify {'/tmp/test1 has already been synced.':
      require => File['/tmp/test1'],
    }

.................................
    file { '/etc/ssh/sshd_config':
      ensure => file,
      mode   => '0600',
      source => 'puppet:///modules/ssh/sshd_config',
    }
    service { 'sshd':
      ensure    => running,
      enable    => true,
      subscribe => File['/etc/ssh/sshd_config'],    
    }

In this example, the sshd service will be restarted if Puppet has to edit its
config file.
This "source" 'puppet:///modules/ssh/sshd_config' is a local file on puppet master.


Protocol 	3 slashes 	“modules”/ 	Name of module/ 	Name of file
puppet: 	/// 		modules/ 	ntp/ 				ntp.conf.el

Note that the final segment of the URL starts inside the files/ directory of the module. If there are any extra subdirectories, they work like you’d expect, so you could have something like

puppet:///modules/ntp/config_files/linux/ntp.conf.el.

.................................
creat a file:

    # /root/examples/file-1.pp

    file {'testfile':
      path    => '/tmp/testfile',
      ensure  => present,
      mode    => 0640,
      content => "I'm a test file.",
    }
.................................

    # /root/examples/file-2.pp

    file {'/tmp/test1':
      ensure  => file,
      content => "Hi.\n",
    }

    file {'/tmp/test2':
      ensure => directory,
      mode   => 0644,
    }

    file {'/tmp/test3':
      ensure => link,
      target => '/tmp/test1',
    }

    user {'katie':
      ensure => absent,
    }

    notify {"I'm notifying you.":}
    notify {"So am I!":}

.................................
puppet resource service

puppet describe -l — List all of the resource types available on the system.
puppet describe -s <TYPE> — Print short information about a type, without describing every attribute
puppet describe <TYPE> — Print long information, similar to what appears in the type reference.

user  puppet@example.com  
password  learningpuppet 
https://<IP ADDRESS>;  
facter ipaddress 

"$::ipaddress"

puppet resource user root

# puppet resource user katie ensure=present shell="/bin/zsh" home="/home/katie" managehome=true

notice: /User[katie]/ensure: created

user { 'katie':
  ensure => 'present',
  home   => '/home/katie',
  shell  => '/bin/zsh'
}
.................................  ensure
As a normal file (ensure => file)
As a directory (ensure => directory)
As a symlink (ensure => link)
As any of the above (ensure => present)
As nothing (ensure => absent)

.................................before, require, notify, and subscribe metaparameters.
file {'/tmp/test1':
      ensure  => present,
      content => "Hi.",
    }

    notify {'/tmp/test1 has already been synced.':
      require => File['/tmp/test1'],
    }

Type['title']
File['/tmp/test1'] is a resource reference. 

......................Before and Require

"before" and "require" make simple dependency relationships, where one resource must be synced before another. "before" is used in the earlier resource, and lists resources that depend on it; "require" is used in the later resource, and lists the resources that it depends on.

These two metaparameters are just different ways of writing the same relationship — our example above could just as easily be written like this:

    file {'/tmp/test1':
      ensure  => present,
      content => "Hi.",
      before  => Notify['/tmp/test1 has already been synced.'],
    }

    notify {'/tmp/test1 has already been synced.':}

......................Notify and Subscribe
A few resource types (service, exec, and mount) can be “refreshed” — that is, told to react to changes in their environment.

The "notify" and "subscribe" metaparameters make dependency relationships the way before and require do, but they also make notification relationships. Not only will the earlier resource in the pair get synced first, but if Puppet makes any changes to that resource, it will send a refresh event to the later resource, which will react accordingly.

    file { '/etc/ssh/sshd_config':
      ensure => file,
      mode   => 600,
      source => 'puppet:///modules/ssh/sshd_config',
    }
    service { 'sshd':
      ensure    => running,
      enable    => true,
      subscribe => File['/etc/ssh/sshd_config'],
    }

In this example, the sshd service will be restarted if Puppet has to edit its config file.
......................
    file {'/tmp/test1':
      ensure  => present,
      content => "Hi.",
    }

    notify {'after':
      message => '/tmp/test1 has already been synced.',
    }

    File['/tmp/test1'] -> Notify['after']

Is the same as:

    file {'/tmp/test1':
      ensure  => present,
      content => "Hi.",
    }
    ->
    notify {'after':
      message => '/tmp/test1 has already been synced.',
    }
info: Log a message on the server at level info.
debug: Log a message on the server at level debug.

node default {
  notice("try to run this script with -v and -d to see difference between log levels")
  notice("function documentation is available here: http://docs.puppetlabs.com/references/latest/function.html")
  notice("--------------------------------------------------------------------------")

  debug("this is debug. visible only with -d or --debug")
  info("this is info. visible only with -v or --verbose or -d or --debug")
  alert("this is alert. always visible")
  crit("this is crit. always visible")
  emerg("this is emerg. always visible")
  err("this is err. always visible")
  warning("and this is warning. always visible")
  notice("this is notice. always visible")
  #fail will break execution
  fail("this is fail. always visible. fail will break execution process")

}
.................................
.................................
common service config:

    # /root/examples/break_ssh.pp
    file { '/etc/ssh/sshd_config':
      ensure => file,
      mode   => 600,
      source => '/root/examples/sshd_config',
    }
    service { 'sshd':
      ensure     => running,
      enable     => true,
      subscribe  => File['/etc/ssh/sshd_config'],
    }

.................................
.................................
common package config:

    package { 'openssh-server':
      ensure => present,
      before => File['/etc/ssh/sshd_config'],
    }
    file { '/etc/ssh/sshd_config':
      ensure => file,
      mode   => 600,
      source => '/root/examples/sshd_config',
    }
    service { 'sshd':
      ensure     => running,
      enable     => true,
      subscribe  => File['/etc/ssh/sshd_config'],
    }

...................... variable

Fully qualified variables look like $scope::variable. Top scope variables are
the same, but their scope is nameless. (For example: $::top_scope_variable.)

    $longthing = "Imagine I have something really long in here. Like an SSH
key, let's say."

    file {'authorized_keys':
      path    => '/root/.ssh/authorized_keys',
      content => $longthing,
    }


    file {'motd':
      ensure  => file,
      path    => '/etc/motd',
      mode    => 0644,
      content => "This Learning Puppet VM's IP address is ${ipaddress}. It
thinks its
    hostname is ${fqdn}, but you might not be able to reach it there
    from your host machine. It is running ${operatingsystem}
${operatingsystemrelease} and
    Puppet ${puppetversion}.
    Web console login:
      URL: https://${ipaddress_eth0}
      User: puppet@example.com
      Password: learningpuppet
    ",
    }

...................... if
if condition {
  block of code
}
elsif condition {
  block of code
}
else {
  block of code
}

    if str2bool("$is_virtual") {
      service {'ntpd':
        ensure => stopped,
        enable => false,
      }
    }
    else {
      service { 'ntpd':
        name       => 'ntpd',
        ensure     => running,
        enable     => true,
        hasrestart => true,
        require => Package['ntp'],
      }
    }

...................... case
    case $operatingsystem {
      centos: { $apache = "httpd" }
      # Note that these matches are case-insensitive.
      redhat: { $apache = "httpd" }
      debian: { $apache = "apache2" }
      ubuntu: { $apache = "apache2" }
      default: { fail("Unrecognized operating system for webserver") }
    }
    package {'apache':
      name   => $apache,
      ensure => latest,
    }

or

    case $operatingsystem {
      centos, redhat: { $apache = "httpd" }
      debian, ubuntu: { $apache = "apache2" }
      default: { fail("Unrecognized operating system for webserver") }
    }

    case $ipaddress_eth0 {
      /^127[\d.]+$/: {
        notify {'misconfig':
          message => "Possible network misconfiguration: IP address of $0",
        }
      }
    }
String matching is case-insensitive, like the == comparison operator. Regular
expressions are denoted with the slash-quoting used by Perl and Ruby; they’re
case-sensitive by default, but you can use the (?i) and (?-i) switches to turn
case-insensitivity on and off inside the pattern. Regex matches also assign
captured subpatterns to $1, $2, etc. inside the associated code block, with $0
containing the whole matching string. See the regular expressions section of
the Puppet reference manual’s data types page for more details.

......................Selectors

    $apache = $operatingsystem ? {
      centos                => 'httpd',
      redhat                => 'httpd',
      /(?i)(ubuntu|debian)/ => 'apache2',
      default               => undef,
    }
...................... classes
Classes are named blocks of Puppet code, which can be created in one place and
invoked elsewhere.

Defining a class makes it available by name, but doesn’t automatically
evaluate the code inside it.
Declaring a class evaluates the code in the class, and applies all of its
resources.

    class ntp {
      case $operatingsystem {
        centos, redhat: {
          $service_name = 'ntpd'
          $conf_file    = 'ntp.conf.el'
        }
        debian, ubuntu: {
          $service_name = 'ntp'
          $conf_file    = 'ntp.conf.debian'
        }
      }

      package { 'ntp':
        ensure => installed,
      }
      file { 'ntp.conf':
        path    => '/etc/ntp.conf',
        ensure  => file,
        require => Package['ntp'],
        source  => "/root/examples/answers/${conf_file}"       ----
      }
      service { 'ntp':
        name      => $service_name,
        ensure    => running,
        enable    => true,
        subscribe => File['ntp.conf'],
      }
    }

    include ntp

The "include" here trigger puppet to apply the class

class postfix {
  package {'postfix':
    ensure => 'installed' ,
    require=> Exec['apt-update'],
    before => File['/etc/postfix/main.cf'],
  }
  file { '/etc/postfix/main.cf':
    ensure => file,
    mode   => '0644',
    content=> "$::postfix_config_content", # global variable specified in enc
  }
  service { 'postfix':
    ensure     => running,
    require    => Package['postfix'],
    enable     => true,
    subscribe  => File['/etc/postfix/main.cf'],
  }

}

.....................Modules.

The Modulepath is defined in: /etc/puppetlabs/puppet/puppet.conf


[main]
    vardir = /var/opt/lib/pe-puppet
    logdir = /var/log/pe-puppet
    rundir = /var/run/pe-puppet
    modulepath = /etc/puppetlabs/puppet/modules:/opt/puppet/share/puppet/modules
    user = pe-puppet
    group = pe-puppet
    archive_files = true
    archive_file_server = learn.localdomain

[master]
    ... etc.


You can also get the value of the modulepath by running puppet master --configprint modulepath. 
The --configprint option lets you get the value of
any Puppet setting; by using the master subcommand, we’re making sure we get
the value the puppet master will use.


...........Module Structure -

A module is a directory. 
The module’s name must be the name of the directory.
It contains a manifests directory, which can contain any number of .pp files.
The manifests directory should always contain an init.pp file. It contains a
single class definition.

This file must contain a single class definition. The class’s name must be the
same as the module’s name.

put it in the site.pp
include ntp    ----

Then:
 puppet agent --test   ----

example:
  # /etc/puppetlabs/puppet/manifests/site.pp
    include ntp
    include apache
    include mysql
    include mongodb
    include build_essential

........... Resource-Like Class Declarations --
class {'ntp':}
can be declared only once

we’ll use the special puppet:/// URL format to tell Puppet where the files
are: could be a local directory under "modules"

    # ...
      file { 'ntp.conf':
        path    => '/etc/ntp.conf',
        ensure  => file,
        require => Package['ntp'],
        source  => "puppet:///modules/ntp/${conf_file}",
      }
    }

puppet:///modules/test_module/testfile.txt

…will resolve to the following absolute path:

/etc/puppet/modules/test_module/files/testfile.txt

...................... The Puppet Module Subcommand

sudo puppet module install puppetlabs-mysql   ----

sudo puppet module list  ----

...................... template 

The template function expects file paths to be in a specific format:

<MODULE NAME>/<FILENAME INSIDE TEMPLATES DIRECTORY>

    file {'/etc/foo.conf':
      ensure  => file,
      require => Package['foo'],
      content => template('foo/foo.conf.erb'),
    }

..........Variables in Templates  ---

Facts, global variables, and local variables from the current scope are
available to a template as Ruby instance variables — instead of Puppet’s $
prefix, they have an @ prefix. (e.g. @fqdn, @memoryfree, @operatingsystem,
etc.)

Variables from other scopes can be accessed with the scope.lookupvar method,
which takes a long variable name without the $ prefix. (For example,
scope.lookupvar('apache::user').)

inbedded ruby code
...........Non-Printing Tags ----
<% tag containing Ruby code %>


........... Printing an Expression ----

    <%= sectionheader %>
      environment = <%= gitrevision[0,5] %>

........... Comments ----
 <%# This comment will be ignored. %>


...........Suppressing Line Breaks and Leading Space ----
    <%- document += thisline -%>

    # /etc/puppetlabs/puppet/modules/ntp/manifests/init.pp

    class ntp {
      case $operatingsystem {
        centos, redhat: {
          $service_name    = 'ntpd'
          $conf_file   = 'ntp.conf.el'
          $default_servers = [ "0.centos.pool.ntp.org",
                               "1.centos.pool.ntp.org",
                               "2.centos.pool.ntp.org", ]
        }
        debian, ubuntu: {
          $service_name    = 'ntp'
          $conf_file   = 'ntp.conf.debian'
          $default_servers = [ "0.debian.pool.ntp.org iburst",
                               "1.debian.pool.ntp.org iburst",
                               "2.debian.pool.ntp.org iburst",
                               "3.debian.pool.ntp.org iburst", ]
        }
      }

      $servers_real = $default_servers

      package { 'ntp':
        ensure => installed,
      }

      service { 'ntp':
        name      => $service_name,
        ensure    => running,
        enable    => true,
        subscribe => File['ntp.conf'],
      }

      file { 'ntp.conf':
        path    => '/etc/ntp.conf',
        ensure  => file,
        require => Package['ntp'],
        content => template("ntp/${conf_file}.erb"),
      }
    }


The template:
    <%# /etc/puppetlabs/puppet/modules/ntp/templates/ntp %>

    # Managed by Class['ntp']
    <% @servers_real.each do |this_server| -%>
    server <%= this_server %>
    <% end -%>

    # ...

Using a non-printing Ruby tag to start a loop. We reference the $servers_real
Puppet variable by the name @servers_real, then call Ruby’s each method on it.
Everything between do |server| -%> and the <% end -%> tag will be repeated for
each item in the $servers_real array, with the value of that array item being
assigned to the temporary this_server variable.
Within the loop, we print the literal word server, followed by the value of
the current array item.
This snippet will produce something like the following:

# Managed by Class['ntp']
server 0.centos.pool.ntp.org
server 1.centos.pool.ntp.org
server 2.centos.pool.ntp.org

.................................

    <% if @is_virtual == "true" -%>
    # Keep ntpd from panicking in the event of a large clock skew
    # when a VM guest is suspended and resumed.
    tinker panic 0

    <% end -%>


    <% if @is_virtual == "false" -%>
    # Undisciplined Local Clock. This is a fake driver intended for backup
    # and when no outside source of synchronized time is available.
    server 127.127.1.0 # local clock
    fudge 127.127.1.0 stratum 10

    <% end -%>


.................................
for puppet test run or  dry-run use : --noop
puppet apply prepack.pp --noop

.................................
  package {'nfs-utils':
    ensure => '1.2.2-7.el6',
    notify => Service ['rpcgssd'],
    require => Exec ['downgrade-nfs-utils'], 
	}
  exec {'downgrade-nfs-utils': 
    command => 'yum -y downgrade nfs-utils-1.2.2-7.el6', 
    path    => ['/sbin', '/bin', '/usr/sbin', '/usr/bin'], 
    unless  => 'rpm -qa | grep nfs-utils-1.2.2-7', 
  }
                      
................................. install rpm from controlled source
http://silviud.blogspot.ca/2012/10/puppet-install-rpms-via-http-sources.html

rpm -ivh http://example.com/package.rpm

class examplerpm ( $src ) {

  package { 'package':
     provider => 'rpm',
     ensure => installed,
     #source => "${examplerpm::rpm}"
     source => "${examplerpm::src}"
 }
}

class { 'examplerpm':
  src => 'https://example.com/package.rpm',
}

puppet apply --debug --no-daemonize test.pp

puppet help module

puppet module uninstall puppetlabs/nginx # not good

puppet module install jfryman/nginx

############################################
To build GW with puppet:
puppet module install jfryman/nginx
/
save this as nginx.pp
.................................
class { 'nginx': }
#}
nginx::resource::upstream { 'proxy':
     ensure  => present,
     members => [ 'casplda02:443', ],
}
nginx::resource::vhost { "$::ipaddress_eth0":
    ensure => present,
    proxy  => 'https://proxy',
    proxy_set_header => [ 'Customer-Id 88989',
                          'User-Agent SD_TRAFFIC',
                        ]
}
nginx::resource::vhost { "$::ipaddress_eth1":
    ensure => present,
    proxy  => 'https://proxy',
    proxy_set_header => [ 'Customer-Id 88989',
                          'User-Agent SD_TRAFFIC',
                        ]
}
.................................
then, run:
puppet apply nginx.pp


...........gw5.sh
curl -s 192.168.115.41/download/gw5.sh|bash

#For CentOS 5 i386
#!/bin/bash
yum -y -q install ruby ruby-libs ruby-shadow #-y: to always answer 'y'
rpm -ivh
http://yum.puppetlabs.com/el/5/products/i386/puppetlabs-release-5-7.noarch.rpm
# to build puppet repository
yum -y -q install puppet facter # -q to install quietly
puppet module install jfryman/nginx
curl -s -O 192.168.115.41/download/nginx.pp  # -s: silent mode
puppet apply nginx.pp
/sbin/service iptables stop
curl -s -O 192.168.115.41/download/nginx.logrotate #enable logrotate
cp ./nginx.logrotate /etc/logrotate.d/nginx


...........gw6.sh
curl -s 192.168.115.41/download/gw6.sh|bash

#!/bin/bash
yum -y -q install ruby ruby-libs ruby-shadow
yum install curl
rpm -Uvh
http://dl.fedoraproject.org/pub/epel/6/x86_64/epel-release-6-8.noarch.rpm #use
the new repo
yum -y -q install puppet facter
puppet module install jfryman/nginx
curl -s -O 192.168.115.41/download/nginx.pp
puppet apply nginx.pp
/sbin/service iptables stop
curl -s -O 192.168.115.41/download/nginx.logrotate #enable logrotate
cp ./nginx.logrotate /etc/logrotate.d/nginx

...........gw6_ssl.sh
curl -s 192.168.115.41/download/gw6_ssl.sh |bash /dev/stdin '192.168.114.242' '@2a@10@iQhay0Bvrzdciex3oARlIuOSkX4AN8NCTWycsLqlHGHC5\/pVFPOCi' 

#!/bin/bash
#set -x -v
yum -y -q install ruby ruby-libs ruby-shadow
yum install curl
rpm -Uvh
http://dl.fedoraproject.org/pub/epel/6/x86_64/epel-release-6-8.noarch.rpm #use
the new repo
yum -y -q install puppet facter
puppet module install jfryman/nginx
curl -s -O 192.168.115.41/download/nginx_ssl.pp_template
#download and store certificate
curl -s -O 192.168.115.41/download/server.key
curl -s -O 192.168.115.41/download/server.crt
mkdir /root/sd
mv ./server.* /root/sd
#updating puppet script
IP=$1
CID=$2
pp='nginx_ssl.pp'
templ='nginx_ssl.pp_template'
sed "s/$::ipaddress_eth1/$IP/" $templ|sed "s/8888/$CID/" >$pp
puppet apply nginx_ssl.pp
#stoping firewall
/sbin/service iptables stop
#enable logrotate
curl -s -O 192.168.115.41/download/nginx.logrotate
cp ./nginx.logrotate /etc/logrotate.d/nginx
#enable heartbeat
curl -s -O 192.168.115.41/download/heartbeat_ssl.sh
chmod +x ./heartbeat_ssl.sh
echo '10 * * * * root ~root/heartbeat_ssl.sh' >> /etc/crontab
#prepare version control
echo '0'>   ~/gw.version
touch ~/ready_for_upgrade

......................nginx.logrotate
/var/log/nginx/*log {
    missingok
    notifempty
    sharedscripts
    nomail
    rotate 3
    size=5M
    daily
    postrotate
        /usr/local/nginx/sbin/nginx -s reload
    endscript
}

#################################  -
vagrant -
################################# -

To prepare current directory to a vagrant directory, create Vagrantfile config file, also add the first CentOS box

$ vagrant init precise32 http://files.vagrantup.com/precise32.box
or 
$ vagrant init centos65-x86_64-20131205 https://github.com/2creatives/vagrant-centos/releases/download/v6.5.1/centos65-x86_64-20131205.box ----

To fire it up
$ vagrant up ----

To add more box into the config file.
vagrant box add centos65-x86_64-20131205 https://github.com/2creatives/vagrant-centos/releases/download/v6.5.1/centos65-x86_64-20131205.box ----

vagrant box add play d:\download\centos65-x86_64-20131205.box

vagrant box remove precise64 virtualbox  ----

then login as:
127.0.0.1:2222  ----
root:vagrant


If the guest machine is already running from a previous step, run 
vagrant reload --provision  ----
which will quickly restart your virtual machine, skipping the initial import step. 

vagrant suspend  ----
vagrant resume  ----
will save the current running state of the machine and stop it.

vagrant destroy # can only clean a particular VM----
vagrant destroy testvm11----
vagrant halt ----

vagrant package --output test.box

................................. multi-VM -
In a single VM environment, vagrant up starts that VM. In a multi-VM environment vagrant up starts every VM. If a name is specified to the command such as "vagrant up web" then it will start only that specific VM.

This pattern follows for every other command as well, although some don’t implement the “every VM” functionality when it doesn’t make sense, such as "vagrant ssh", which requires that a VM name be specified if it’s in a multi-VM environment.

................................. package to install on Vagrant CentOS 6.5
yum -y install vim
yum -y install compat-glibc.x86_64
yum -y install libidn.i686
yum -y install telnet
yum -y install libgcc.i686

yum install tomcat6 tomcat6-webapps tomcat6-admin-webapps
service tomcat6 start

...........Vagrantfile -
To use DHCP: ---
Vagrant.configure("2") do |config|
  config.vm.network "public_network"
end

To config bootstrap: ---
Vagrant.configure("2") do |config|
  config.vm.box = "precise32"
  config.vm.provision :shell, :path => "bootstrap.sh"
end
Using Multi-VM             ---
Vagrant::Config.run do |config|
  config.vm.define :web do |web_config|
    web_config.vm.box = "web"
    web_config.vm.forward_port 80, 8080
  end
  config.vm.define :db do |db_config|
    db_config.vm.box = "db"
    db_config.vm.forward_port 3306, 3306
  end
  config.vm.define :test do |test_config|
    test_config.vm.box = "test"
    test_config.vm.network "public_network"
  end
end

To use puppet provistion ---
Vagrant::Config.run do |config|
	config.vm.box = "lucid32"
	config.vm.box_url = "http://files.vagrantup.com/lucid32.box"
	config.vm.network :hostonly, "33.33.33.10"
	config.vm.provision :puppet do |puppet|
	puppet.manifests_path = "manifests"
	puppet.manifest_file = "webserver.pp"
end
...................... Puppet Manifest used above ----
# to fix missing puppet group in lucid32 box
group { "puppet":
	ensure => present,
}
# to update outdated package list
exec { "refresh-packages":
	command => "/usr/bin/apt-get update",
	before => Package["apache2"],
}
package { "apache2":
	ensure => installed,
}
service { "apache2":
	ensure => running,
	require => Package["apache2"],
}
file { "/var/www/index.html":
	ensure => file,
	content => "<html><body><h1>Vagrant and Puppet rocks!</h1></body></html>",
	require => Service["apache2"],
}

......................sample file: -
In d:/vagrant
# -*- mode: ruby -*-
# vi: set ft=ruby :

# Vagrantfile API/syntax version. Don't touch unless you know what you're
# doing!
VAGRANTFILE_API_VERSION = "2"

Vagrant.configure(VAGRANTFILE_API_VERSION) do |config|
  # All Vagrant configuration is done here. The most common configuration
  # options are documented and commented below. For a complete reference,
  # please see the online documentation at vagrantup.com.

  # Every Vagrant virtual environment requires a box to build off of.
    #config.vm.box = "centos65-x86_64-20131205"
    config.vm.box = "base"
    # The url from where the 'config.vm.box' box will be fetched if it
    # doesn't already exist on the user's system.
    #config.vm.box_url =
"https://github.com/2creatives/vagrant-centos/releases/download/v6.5.1/centos65-x86_64-20131205.box"

  config.vm.define :test do |test_config|
    test_config.vm.box = "test"
    test_config.vm.network "private_network",  ip: "192.168.200.100",
    virtualbox__intnet: "mynetwork"
    test_config.vm.network "forwarded_port", guest: 8080, host: 8080 
    test_config.vm.network "forwarded_port", guest: 22, host: 2020 
    test_config.vm.provision :shell, :path => "bootstrap.sh"
  end
  config.vm.define :testvm1 do |testvm1_config|
    testvm1_config.vm.box = "testvm1"
    #testvm1_config.vm.network "private_network",  ip: "192.168.200.101",
    #virtualbox__intnet: "mynetwork"
    #testvm1_config.vm.network "forwarded_port", guest: 8080, host: 8081 
    #testvm1_config.vm.network "forwarded_port", guest: 22, host: 2021 
    #testvm1_config.vm.provision :shell, :path => "bootstrap1.sh"
    #testvm1_config.vm.synced_folder "d:/VMmount", "/VMmount"
  end
  config.vm.define :testvm2 do |testvm2_config|
    testvm2_config.vm.box = "testvm2"
    #testvm2_config.vm.network "private_network",  ip: "192.168.200.102",
    #virtualbox__intnet: "mynetwork"
    testvm2_config.vm.network "forwarded_port", guest: 22, host: 2022 , id:
"ssh", auto_correct: true
    #testvm2_config.vm.provision :shell, :path => "bootstrap2.sh"
    #testvm2_config.vm.synced_folder "d:/VMmount", "/VMmount"
  end
  config.vm.define :testvm3 do |testvm3_config|
    testvm3_config.vm.box = "testvm3"
    #testvm3_config.vm.network "private_network",  ip: "192.168.200.103",
    #virtualbox__intnet: "mynetwork"
    testvm3_config.vm.network "forwarded_port", guest: 22, host: 2023 
    #testvm3_config.vm.provision :shell, :path => "bootstrap3.sh"
    #testvm3_config.vm.synced_folder "d:/VMmount", "/VMmount"
  end
    config.vm.define :testvm11 do |testvm11_config|
    testvm11_config.vm.box = "testvm11"
    testvm11_config.vm.network "private_network",  ip: "192.168.200.101",
    virtualbox__intnet: "mynetwork"
    testvm11_config.vm.network "forwarded_port", guest: 8080, host: 8081 
    testvm11_config.vm.network "forwarded_port", guest: 22, host: 2021 
    testvm11_config.vm.provision :shell, :path => "bootstrap1.sh"
    testvm11_config.vm.synced_folder  "d:/VMmount" , "/VMmount"
  end
#config.vm.provider "virtualbox" do |v|
#  v.memory = 1024
#end
end
.................................
# -*- mode: ruby -*-
# vi: set ft=ruby :

# Vagrantfile API/syntax version. Don't touch unless you know what you're
# doing!
VAGRANTFILE_API_VERSION = "2"

Vagrant.configure(VAGRANTFILE_API_VERSION) do |config|
  # All Vagrant configuration is done here. The most common configuration
  # options are documented and commented below. For a complete reference,
  # please see the online documentation at vagrantup.com.

  # Every Vagrant virtual environment requires a box to build off of.
    config.vm.box = "base"
    # The url from where the 'config.vm.box' box will be fetched if it
    # doesn't already exist on the user's system.

  config.vm.define :testvm11 do |testvm11_config|
    testvm11_config.vm.box = "testvm11"
    testvm11_config.vm.network "private_network",  ip: "192.168.200.101",
    virtualbox__intnet: "mynetwork"
    testvm11_config.vm.network "forwarded_port", guest: 8080, host: 8081 
    testvm11_config.vm.network "forwarded_port", guest: 22, host: 2021 
    testvm11_config.vm.provision :shell, :path => "bootstrap1.sh"
    testvm11_config.vm.synced_folder  "d:/VMmount" , "/VMmount"
  end
  config.vm.define :testvm12 do |testvm12_config|
    testvm12_config.vm.box = "testvm12"
    testvm12_config.vm.network "private_network",  ip: "192.168.200.102",
    virtualbox__intnet: "mynetwork"
    testvm12_config.vm.network "forwarded_port", guest: 22, host: 2022 , id:
"ssh", auto_correct: true
    testvm12_config.vm.provision :shell, :path => "bootstrap2.sh"
    testvm12_config.vm.synced_folder  "d:/VMmount" , "/VMmount"
  end
  config.vm.define :testvm13 do |testvm13_config|
    testvm13_config.vm.box = "testvm13"
    testvm13_config.vm.network "private_network",  ip: "192.168.200.103",
    virtualbox__intnet: "mynetwork"
    testvm13_config.vm.network "forwarded_port", guest: 22, host: 2023 
    testvm13_config.vm.provision :shell, :path => "bootstrap3.sh"
    testvm13_config.vm.synced_folder  "d:/VMmount" , "/VMmount"
  end
  #config.vm.define :testvm11 do |testvm11_config|
  #  testvm11_config.vm.box = "testvm11"
  #  testvm11_config.vm.network "private_network",  ip: "192.168.200.104",
  #  virtualbox__intnet: "mynetwork"
  #  testvm11_config.vm.network "forwarded_port", guest: 22, host: 2024 
  #  testvm11_config.vm.provision :shell, :path => "bootstrap1.sh"
  #  testvm11_config.vm.synced_folder "d:\VMmount", "/VMmount"
  #end
config.vm.provider "virtualbox" do |v|
  v.memory = 1024
end
end
  
#################################
The following error may show up when export testvm1 to a package and add another VM to the same host. When starting the new VM, the eth1 can not be started. Solution see below.
.................................---
The following SSH command responded with a non-zero exit status.
Vagrant assumes that this means the command failed!

ARPCHECK=no /sbin/ifup eth1 2> /dev/null

Stdout from the command:

Device eth1 does not seem to be present, delaying initialization.


Stderr from the command:
.................................---
remove 
rm -f /etc/udev/rules.d/70-persistent-net.rules    --
or better:
cat /dev/null > /etc/udev/rules.d/70-persistent-net.rules    --
chmod 444 /etc/udev/rules.d/70-persistent-net.rules    --
before packing 
................................. -
.................................veewee -
To build customized vagrant basbox
................................. -
.................................jenkins -
check the ubuntu steps below. virutalbox installation on CentOS has problem +
sudo wget -O /etc/yum.repos.d/jenkins.repo http://pkg.jenkins-ci.org/redhat/jenkins.repo
sudo rpm --import http://pkg.jenkins-ci.org/redhat/jenkins-ci.org.key
yum install jenkins

java -version, this version won't work --
java -version
java version "1.5.0"
gij (GNU libgcj) version 4.4.6 20110731 (Red Hat 4.4.6-3)

for CentOS,  --
yum remove java
yum install java-1.6.0-openjdk

should be this one:  --
[root@vagrant-centos65 jenkins]# java -version
java version "1.6.0_30"
OpenJDK Runtime Environment (IcedTea6 1.13.1) (rhel-3.1.13.1.el6_5-x86_64)
OpenJDK 64-Bit Server VM (build 23.25-b01, mixed mode)

To start --
Find the .war directory:

java -jar jenkins.war
or
nohup java -jar jenkins.war > $LOGFILE 2>&1

To access --
http://192.168.114.234:8080/ 

use rsa key in jenkins "manage credentials"
update all related plugin
then paste in the private key directly

To install virtualbox --
require the building kernel modules,DKMS (Dynamic Kernel Module Support)
wget http://packages.sw.be/rpmforge-release/rpmforge-release-0.5.2-2.el6.rf.x86_64.rpm
rpm -Uvh rpmforge-release-0.5.2-2.el6.rf.x86_64.rpm

yum --enablerepo rpmforge install dkms

yum groupinstall "Development Tools"
yum install kernel-devel

cd /etc/yum.repos.d
wget http://download.virtualbox.org/virtualbox/rpm/rhel/virtualbox.repo
yum search virutalbox
then install latest virtualbox

To start vargent-vm from jenkins --
vagrant init vagrant-vm ./centos65-x86_64-20131205.box
/
......................
...................... on Ubuntu --
To install virutalbox 4.3
sudo sh -c "echo 'deb http://download.virtualbox.org/virtualbox/debian '$(lsb_release -cs)' contrib non-free' > /etc/apt/sources.list.d/virtualbox.list" && wget -q http://download.virtualbox.org/virtualbox/debian/oracle_vbox.asc -O- | sudo apt-key add - && sudo apt-get update && sudo apt-get install virtualbox-4.3 dkms 

dpkg -i vagrant_1.4.3_x86_64.deb
vagrant init vagrant-vm ./centos65-x86_64-20131205.box

vagrant up

vagrant ssh

install jenkins --
wget -q -O - http://pkg.jenkins-ci.org/debian/jenkins-ci.org.key | sudo apt-key add -
sudo sh -c 'echo deb http://pkg.jenkins-ci.org/debian binary/ > /etc/apt/sources.list.d/jenkins.list'
sudo apt-get update
sudo apt-get install jenkins

......................puppet master -

 apt-get install puppetmaster ----

To enable autosigning, put a file "autosign.conf" into /etc/puppet, containing the following content:
*.example.com

This will automatically sign all certificate requests from clients with a matching hostname (e.g., web01.example.com)  and  remove  the  extra  step  of  doing  a certificate  exchange  before master and client can communicate with each other. 
Now, restart the Puppet master to make our change visible:

 service puppetmaster restart ----

To test connection from an agent to the master
puppet agent --test --server calpmcs02-linux.orsypgroup.com ----


For this error from agent side: --
err: Could not retrieve catalog from remote server: Server hostname '192.168.114.174' did not match server certificate; expected one of calpmcs02-linux.orsypgroup.com, DNS:calpmcs02-linux.orsypgroup.com, DNS:puppet, DNS:puppet.orsypgroup.com


To see the puppet master’s certified hostnames, run: ---

  $ sudo puppet master --configprint certname ----

Re-generate the puppet master’s certificate: ---

Stop puppet master.
Delete the puppet master’s certificate, private key, and public key:

 $ sudo find $(puppet master --configprint ssldir) -name "$(puppet master --configprint certname).pem" -delete ----

Edit the certname setting in the puppet master's /etc/puppet/puppet.conf file to match the puppet master's actual hostname, and the dns_alt_names setting in that file to match any other DNS names you expect the master to need to respond to.

Start a non-daemonized WEBrick puppet master instance, and wait for it to generate and sign a new certificate:

  $ sudo puppet master --no-daemonize --verbose ----

puppet cert list ----

For this error for the command: --
puppet agent --test --server calpmcs02-linux.orsypgroup.com ----

err: Could not retrieve catalog from remote server: SSL_connect returned=1 errno=0 state=SSLv3 read server certificate B: certificate verify failed.  This is often because the time is out of sync on the server or client 
warning: Not using cache on failed catalog 
err: Could not retrieve catalog; skipping run err: Could not send report: SSL_connect returned=1 errno=0 state=SSLv3 read server certificate B: certificate verify failed.  This is often because the time is out of sync on the server or client 

This command fixed that:
rm -rf /var/lib/puppet/ssl ----

puppet --genconfig ----

To setup agent, server communication: set this in /etc/puppet/puppet.conf on the agent side --
In here:
[agent]
    server = calpmcs02-linux.orsypgroup.com ----

...................... prepare a new ubuntu server node as puppet agent-
echo '192.168.114.174 calpmcs02-linux.orsypgroup.com' >> /etc/hosts
vim /etc/puppet/puppet.conf

#[master]
# These are needed when the puppetmaster is run by passenger
# and can safely be removed if webrick is used.
#ssl_client_header = SSL_CLIENT_S_DN
#ssl_client_verify_header = SSL_CLIENT_VERIFY

[agent]
    server = calpmcs02-linux.orsypgroup.com

On the master:
  puppet cert clean raring64.orsypgroup.com ----

On the agent:
  #rm -f /var/lib/puppet/ssl/certs/raring64.orsypgroup.com.pem
 rm -rf /var/lib/puppet/ssl ----

 puppet agent -t ----

In script --
puppet master side: ---
puppet cert clean raring64.orsypgroup.com 
puppet agent side: ---
echo '192.168.114.174 calpmcs02-linux.orsypgroup.com' >> /etc/hosts
echo '[agent]' >>/etc/puppet/puppet.conf 
echo '    server = calpmcs02-linux.orsypgroup.com' >>/etc/puppet/puppet.conf 
 rm -rf /var/lib/puppet/ssl 
puppet agent -t --debug

...................... fpm
Quickly create custom software packages with FPM
http://www.openlogic.com/wazi/bid/296143/Quickly-create-custom-software-packages-with-FPM
rpm -e pkg_name # to remove a package
#To install
gem install fpm

fpm -s dir -t rpm -n node -v 0.8.8 -C /tmp/node-install usr/bin usr/lib 

fpm -s dir  -t rpm -n sd_files -C /home/SD/sources/  -v 0.0.1   SmokeDetector
#that package will install everything under /SmokeDetector

fpm -s gem -t deb rails
dpkg -c rubygen-rails_4.0.2_all.deb
dpkg -I #to get info from a package

fpm -s gem -t rpm rails
rpm -qp rubygem-rails-4.0.2-1.noarch.rpm --requires # to find the
dependencies.

fpm -s cpan -t deb Regexp::Common

fpm --verbose -s python -t deb Django
#fpm will download the latest version of the package first

fpm -s pear -t deb Mail_Mime

# source is a tar.gz file
# -n is the new package name
# -a is the target archtecture: can be all or noarch
fpm -s tar -t deb -n apapche-maven -v 3.1.1 -C apache-maven-3.1.1 --prefix
/opt/maven apache-maven-3.1.1-bin.tar.gz
......................
class boardie {

  require ruby::dev
  require build
  require build::sqlite

  sinatra::app { 'boardie':
    giturl   => 'https://gitbox.local:boardie',
    revision => 'e1f262dd5e05df8bb02bec461c54835db0da1e94',
    rackup   => "puppet:///modules/boardie/config.ru",
  }

  $config = "/opt/boardie/config/config.yml"

  file { $config:
    ensure  => present,
    content => template('boardie/config.yml.erb'),
    owner   => 'www-data',
    group   => 'www-data',
    require => Sinatra::App['boardie'],
  }

  bundler::install { $root:
    require => [
      Sinatra::App['boardie'],
      File[$config],
    ],
  }
}

package { 'vim-enhanced':
  ensure => present,
}

node webserver {
  include apache
  include mysql
  include sinatra
}

node downloadserver {
  include apache
  downloads::sync { '/srv/bigfiles': }
}

node default {
  include apache

  class {'ntp':
	enable => false;
  }

  apache::vhost {'personal_site':
	port    => 80,
	docroot => '/var/www/personal',
	options => 'Indexes MultiViews',
  }
}

#Puppet can convert catalogs into dot files, which is a format for storing
graphs. You can use tools like Omnigraffle or Graphiz to convert graph files (
produced with 
puppet agent --graph 
#and stored in $vardir/state/graphs) to produce an image of the graph that¡¯s
pretty easy to read. You can also use gephi to manipulate and explore graphs,
view how things interrelate, and do some pretty neat transforms on the data.


#For only creating a file if it doesn't exist, try setting replace to false,
like so:

file { "/etc/myconfig.conf":
  ensure => present,
  source => "puppet:///modules/${module_name}/myconfig.conf",
  replace => false,
}


#In Puppet 2.7 you can issue the command:
puppet catalog select $hostname $type

#all the file resources puppet manage:
puppet catalog select somenode file

#To list all the services managed by puppet on that system:
puppet catalog select somenode service

/#.......................Deploy code from Git using Puppet
http://livecipher.blogspot.ca/2013/01/deploy-code-from-git-using-puppet.html

#In puppet master you may install the module using this command:
    sudo puppet module install puppetlabs/vcsrepo
/#Alternatively, you may download the module and store it in
/etc/puppet/modules/ directory.

#The puppet module template can be generated using this command. In this case,
the module name is git:

    puppet module generate zwa/git
#Once the module template is generated, you may add/edit new manifests. 

...........#Node definition
#manifests/nodes/dog-park.net.pp

    node 'dog-park.net' {
        class { git::clone: repo => 'dogfood' }
    }

#  Manifests to pull code from Git
# modules/git/manifests/init.pp

    class git {
            class { git::clone: }
    }

#modules/git/manifests/clone.pp
#The following manifests are used to perform following tasks:

1.  Create the user, default devchick
2.  Create the group, default devchick
3.  Create the directory /opt/code
4.  clone latest code from specified repository in gitrul.com using default branch master.

     class git::clone ($repo, $username='devchick') {
        $group = $username

        group { $username:
            ensure  => present,
            gid     => 2000,
        }

        user { $username:
            ensure  => present,
            gid     => $group,
            require => Group[$group],
            uid     => 2000,
            home    => "/home/${username}",
            shell   => "/bin/bash",
            managehome  => true,
        }

        file { '/opt/code' :
            ensure  => directory,
            group   => $group,
            owner   => $username,
            mode    => 0755,
        }

        file { '/home/${username}':
            ensure  => directory,
            group   => $group,
            owner   => $username,
            mode    => 0700,
        }

        package { 'git':
            ensure => installed,
        }
       
        vcsrepo { "/opt/code/${repo}":
            ensure   => latest,
            owner    => $owner,
            group    => $owner,
            provider => git,
            require  => [ Package["git"] ],
            source   => "http://giturl.com/proj/${repo}.git",
            revision => 'master',
        }
    }

#For a specific revision or branch (can be a commit SHA, tag or branch name):
    vcsrepo { "/path/to/repo":
        ensure => present,
        provider => git,
        source => 'git://example.com/repo.git',
        revision => 'development'   # tab or branch name
    }
#another implementation
vcsrepo { "/home/fiesta/fiesta":
  owner => fiesta,
  group => fiesta,
  ensure => latest,  # latest!!
  revision => "prod",  # prod branch
  provider => git,
  require => [ Package["git"],
               Sshkey["git.fiesta.cc"] ],
  source => "ssh://git@git.fiesta.cc/home/git/fiesta.git"
}

# restarting after source code update, 
service { "www":      # define the service in puppet
  ensure => running,
  subscribe => Vcsrepo["/home/fiesta/fiesta"],   # ensure that every time repo updated, the service will restart
  start => "/home/fiesta/fiesta/www.py start",
  stop => "/home/fiesta/fiesta/www.py stop",
  status => "/home/fiesta/fiesta/www.py status",
  require => Service["mongod"]
}

# NOTE: the vcsrepo is different from git post receive hook. This one is pull
# from git everytime the agent run
# the git post receive hook is a push from git

#dryrun -- test run
     $ sudo puppet agent --test --noop

#Deploy code from Git
     $ sudo puppet agent --test


puppet parser validate manifests/init.pp

/#use git pre-commit hook to check puppet script commited
#copy paste the precommit hood from the web
#Add a pre-receive git hook to the remote git server side
#1. add the remote repository
git remote
git remote add origin git@githost.puppetlet.com:username/motd.git         /
git branch
git push origin master
git commit manifests/init.pp         /
git push origin master
#The pre-receive hook will trigger an error message, the push will fail

puppet-lint manifests/init.pp           /

#Every time the developer checkin new change in Git, it is deployed
automatically using puppet! To deploy same code in multiple servers, you may
define that many node definition, or you may use regular expression based node
definition to match multiple nodes.

puppet-lint
http://puppet-lint.com/
rspec-puppet
http://rspec-puppet.com/tutorial/

/#...................... using puppet dynamic envioronment in config

[main]
  server = puppet.example.com
  environment = production
  confdir = /etc/puppet
[master]
  environment = production
  manifest    = $confdir/environments/$environment/manifests/site.pp
  modulepath  = $confdir/environments/$environment/modules
[agent]
  report = true
  show_diff = true
  environment = production

.........../###################### hiera
Separate date from manifest
#hiear yaml file
---
allowUsers: ['zach','cody']
banner: '/etc/issue.net'
logLevel: 'verbose'
port: 22
companyName: 'Puppet Labs'

$allowUsers=hiera('allowUsers',[])  
# hiera  is the lookup function; allowUsers is the key to check; [] is the
# default value

The result:
$allowUsers=['zach','cody']

......................Hiera Installation
OS packages
Ruby gems

...................... Hiera Configuration
#/etc/puppet/hiera.yaml
---
:backends:  # can use multiple backend
 - yaml
:yaml:
 :datadir: /var/lib/hiera   
/#
:hierarchy: # the following define the searching sequence. first fqdn, then
environemt, last global
 - "%{fqdn}"
 - "%{environment}" #this one and the %{fqdn} will be replaced by factor at
   run time
 - global

$facter fqdn --yaml
---
fqdn: debian.puppetconf.lab

...........using hiera in class
class openssh::server::hiera(
  $companyName  = hiera('companyName'),
  $allowUsers   =hiera('allowUsers',[]) ,
  $banner       = hiera('banner','/etc/issue.net'),
){

#The acctual hiera file for the node
# There can be a yaml for each node, and each environment and a default one.
# In the above example, global.yaml
#/var/lib/hiera/debian.puppetconf.lab.yaml
---
allowUsers:
 -"admin"
 -"ben"
 -"cody"
 -"kelsy"
 -"zach"
passwordAuthentication:"yes"
permitRootLogin:"no"
port:2222

#the debian.puppetconf.lab
node 'debian.puppetconf.lab' {
  include users
  include openssh:server:hiera
}


#To find the port that will be used. It will use the search order defined in
the hiera.yaml config
#hiera command:
hiera port -d  # to find the value for key port

hiera port -d -y facts.yaml

#to show the local info
#cat facts.yaml
fqdn: debian.puppet.conf.lab
environment: production

......................ENC
# to get variable value at run time

$ /bin/classifier debian.puppetconf.lab

[master]
  node_terminus = exec
  external_nodes = /bin/classifier 

#sample ENC:
# cat /usr/local/bin/puppet_node_classifier
#!/bin/bash
DATADIR='/var/lib/enc'
NODE=$1
cat "#{DATADIR}/${NODE}.yaml"

......................#http://www.tokiwinter.com/implementing-git-dynamic-workflows-puppet/

To allow select the manifests to use according a variable

$ git clone me@git.server:/opt/git/puppet.git
/
$ cd puppet
$ git branch testing
$ git checkout testing
... make some edits
$ git add *
$ git commit -m "made some edits"
$ git push origin testing

Then test the testing code, the code is on the puppet master
# puppet agent --test --environment=testing
Info: Retrieving plugin
Info: Caching catalog for sun.local
Info: Applying configuration version '1371740640'

git branch  # to list all branches
git branch -r # to list all remote branches
git status
git log
################################# git flow
$ apt-get install git-flow 

git flow init

git flow feature start MYFEATURE 

git flow feature finish MYFEATURE 

git flow feature publish MYFEATURE 

git flow feature pull origin MYFEATURE 

git flow feature track MYFEATURE

git flow release start RELEASE [BASE] 

git flow release publish RELEASE 

git flow release track RELEASE

git flow release finish RELEASE 

git push --tags

git flow hotfix start VERSION [BASENAME] 

git flow hotfix finish VERSION 


          |  init     |  start
git flow -   feature -   finish -  name
          |  release  |  publish
          |  hotfix   |  pull

................................. git ssh access
create a ssh key on local node
ssh-keygen -t rsa -C "zwa@orsyp.com"

Copy the pub key to gitlap
cat ~/.ssh/id_rsa.pub

git remote rm origin # remove the old origin defined

# push as git user, seems not need to have a user created on the git server
git remote add origin git@192.168.114.174:zwa/packagetofile.git
git push -u origin master

