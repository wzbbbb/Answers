fpm : package builder
http://www.tuxz.net/blog/archives/2012/09/08/how_to_easily_build_native_packages_of_everything/
https://github.com/jordansissel/fpm

mrepo(yam)
reprepo
pulp
.................................
package { "vim": 
	ensure => present, 
} 

type { title: 
	attribute => value, 
} 

save as test.pp, then:
puppet apply test.pp

...........
factor
......................
Installing on Red Hat Enterprise Linux and Fedora
# yum install ruby ruby-libs ruby-shadow

Next, to get the latest releases of Puppet, you will need to add the EPEL repository (see sidebar) to your host and then install packages from that repository. You can add the EPEL repository by adding the epel-releaseRPM (.rpm package manager). 
# rpm -Uvh http://download.fedora.redhat.com/pub/epel/5/i386/epel-release-5-3.noarch.rpm 

rpm -Uvh http://dl.fedoraproject.org/pub/epel/5/x86_64/epel-release-5-4.noarch.rpm

On the master,
# yum install puppet puppet-server facter
On the agent,
# yum install puppet facter 

If puppet is not avaialbe in yum, run the following to add the puppet repository for yum, then run yum install

http://docs.puppetlabs.com/guides/puppetlabs_package_repositories.html

CentOS5:
i386
$ sudo rpm -ivh http://yum.puppetlabs.com/el/5/products/i386/puppetlabs-release-5-7.noarch.rpm

x86_64
$ sudo rpm -ivh http://yum.puppetlabs.com/el/5/products/x86_64/puppetlabs-release-5-7.noarch.rpm

Enterprise Linux 6:
i386
$ sudo rpm -ivh http://yum.puppetlabs.com/el/6/products/i386/puppetlabs-release-6-7.noarch.rpm

x86_64
$ sudo rpm -ivh http://yum.puppetlabs.com/el/6/products/x86_64/puppetlabs-release-6-7.noarch.rpm
.................................
config file
/etc/puppetlabs/puppet/puppet.conf

If not exist:
# puppetmasterd --genconfig > puppet.conf 
.................................
github
git config --global user.name 'zwa'
git config --global user.email 'zwa@orsyp.com'

To add /etc/puppetlabs to git repository.
root@cookbook:/etc/puppet# git init
Initialized empty Git repository in /etc/puppet/.git/
root@cookbook:/etc/puppet# git add manifests/ modules/
root@cookbook:/etc/puppet# git commit -m "initial commit"
[master (root-commit) c7a24cf] initial commit
 59 files changed, 1790 insertions(+), 0 deletions(-)
 create mode 100644 manifests/site.pp
 create mode 100644 manifests/utils.pp
 ...

git commit -a # to commit everything
env GIT_SSL_NO_VERIFY=true  git push -u origin master
.................................
Here’s a notify resource that depends on a file resource:

    file {'/tmp/test1':
      ensure  => present,
      content => "Hi.",
    }

    notify {'/tmp/test1 has already been synced.':
      require => File['/tmp/test1'],
    }

.................................
    file { '/etc/ssh/sshd_config':
      ensure => file,
      mode   => 600,
      source => 'puppet:///modules/ssh/sshd_config',
    }
    service { 'sshd':
      ensure    => running,
      enable    => true,
      subscribe => File['/etc/ssh/sshd_config'],    
    }

In this example, the sshd service will be restarted if Puppet has to edit its
config file.
This "source" 'puppet:///modules/ssh/sshd_config' is a local file.
.................................
creat a file:

    # /root/examples/file-1.pp

    file {'testfile':
      path    => '/tmp/testfile',
      ensure  => present,
      mode    => 0640,
      content => "I'm a test file.",
    }
.................................

    # /root/examples/file-2.pp

    file {'/tmp/test1':
      ensure  => file,
      content => "Hi.\n",
    }

    file {'/tmp/test2':
      ensure => directory,
      mode   => 0644,
    }

    file {'/tmp/test3':
      ensure => link,
      target => '/tmp/test1',
    }

    user {'katie':
      ensure => absent,
    }

    notify {"I'm notifying you.":}
    notify {"So am I!":}

.................................
puppet resource service

puppet describe -l — List all of the resource types available on the system.
puppet describe -s <TYPE> — Print short information about a type, without describing every attribute
puppet describe <TYPE> — Print long information, similar to what appears in the type reference.

user  puppet@example.com  
password  learningpuppet 
https://<IP ADDRESS>;  
facter ipaddress 

$::ipaddress

puppet resource user root

# puppet resource user katie ensure=present shell="/bin/zsh" home="/home/katie" managehome=true

notice: /User[katie]/ensure: created

user { 'katie':
  ensure => 'present',
  home   => '/home/katie',
  shell  => '/bin/zsh'
}
.................................  ensure
As a normal file (ensure => file)
As a directory (ensure => directory)
As a symlink (ensure => link)
As any of the above (ensure => present)
As nothing (ensure => absent)

.................................before, require, notify, and subscribe metaparameters.
file {'/tmp/test1':
      ensure  => present,
      content => "Hi.",
    }

    notify {'/tmp/test1 has already been synced.':
      require => File['/tmp/test1'],
    }

Type['title']
File['/tmp/test1'] is a resource reference. 

......................Before and Require

"before" and "require" make simple dependency relationships, where one resource must be synced before another. "before" is used in the earlier resource, and lists resources that depend on it; "require" is used in the later resource, and lists the resources that it depends on.

These two metaparameters are just different ways of writing the same relationship — our example above could just as easily be written like this:

    file {'/tmp/test1':
      ensure  => present,
      content => "Hi.",
      before  => Notify['/tmp/test1 has already been synced.'],
    }

    notify {'/tmp/test1 has already been synced.':}

......................Notify and Subscribe
A few resource types (service, exec, and mount) can be “refreshed” — that is, told to react to changes in their environment.

The "notify" and "subscribe" metaparameters make dependency relationships the way before and require do, but they also make notification relationships. Not only will the earlier resource in the pair get synced first, but if Puppet makes any changes to that resource, it will send a refresh event to the later resource, which will react accordingly.

    file { '/etc/ssh/sshd_config':
      ensure => file,
      mode   => 600,
      source => 'puppet:///modules/ssh/sshd_config',
    }
    service { 'sshd':
      ensure    => running,
      enable    => true,
      subscribe => File['/etc/ssh/sshd_config'],
    }

In this example, the sshd service will be restarted if Puppet has to edit its config file.
......................
    file {'/tmp/test1':
      ensure  => present,
      content => "Hi.",
    }

    notify {'after':
      message => '/tmp/test1 has already been synced.',
    }

    File['/tmp/test1'] -> Notify['after']

Is the same as:

    file {'/tmp/test1':
      ensure  => present,
      content => "Hi.",
    }
    ->
    notify {'after':
      message => '/tmp/test1 has already been synced.',
    }
.................................
.................................
common service config:

    # /root/examples/break_ssh.pp
    file { '/etc/ssh/sshd_config':
      ensure => file,
      mode   => 600,
      source => '/root/examples/sshd_config',
    }
    service { 'sshd':
      ensure     => running,
      enable     => true,
      subscribe  => File['/etc/ssh/sshd_config'],
    }

.................................
.................................
common package config:

    package { 'openssh-server':
      ensure => present,
      before => File['/etc/ssh/sshd_config'],
    }
    file { '/etc/ssh/sshd_config':
      ensure => file,
      mode   => 600,
      source => '/root/examples/sshd_config',
    }
    service { 'sshd':
      ensure     => running,
      enable     => true,
      subscribe  => File['/etc/ssh/sshd_config'],
    }

...................... variable

Fully qualified variables look like $scope::variable. Top scope variables are
the same, but their scope is nameless. (For example: $::top_scope_variable.)

    $longthing = "Imagine I have something really long in here. Like an SSH
key, let's say."

    file {'authorized_keys':
      path    => '/root/.ssh/authorized_keys',
      content => $longthing,
    }


    file {'motd':
      ensure  => file,
      path    => '/etc/motd',
      mode    => 0644,
      content => "This Learning Puppet VM's IP address is ${ipaddress}. It
thinks its
    hostname is ${fqdn}, but you might not be able to reach it there
    from your host machine. It is running ${operatingsystem}
${operatingsystemrelease} and
    Puppet ${puppetversion}.
    Web console login:
      URL: https://${ipaddress_eth0}
      User: puppet@example.com
      Password: learningpuppet
    ",
    }

...................... if
if condition {
  block of code
}
elsif condition {
  block of code
}
else {
  block of code
}

    if str2bool("$is_virtual") {
      service {'ntpd':
        ensure => stopped,
        enable => false,
      }
    }
    else {
      service { 'ntpd':
        name       => 'ntpd',
        ensure     => running,
        enable     => true,
        hasrestart => true,
        require => Package['ntp'],
      }
    }

...................... case
    case $operatingsystem {
      centos: { $apache = "httpd" }
      # Note that these matches are case-insensitive.
      redhat: { $apache = "httpd" }
      debian: { $apache = "apache2" }
      ubuntu: { $apache = "apache2" }
      default: { fail("Unrecognized operating system for webserver") }
    }
    package {'apache':
      name   => $apache,
      ensure => latest,
    }

or

    case $operatingsystem {
      centos, redhat: { $apache = "httpd" }
      debian, ubuntu: { $apache = "apache2" }
      default: { fail("Unrecognized operating system for webserver") }
    }

    case $ipaddress_eth0 {
      /^127[\d.]+$/: {
        notify {'misconfig':
          message => "Possible network misconfiguration: IP address of $0",
        }
      }
    }
String matching is case-insensitive, like the == comparison operator. Regular
expressions are denoted with the slash-quoting used by Perl and Ruby; they’re
case-sensitive by default, but you can use the (?i) and (?-i) switches to turn
case-insensitivity on and off inside the pattern. Regex matches also assign
captured subpatterns to $1, $2, etc. inside the associated code block, with $0
containing the whole matching string. See the regular expressions section of
the Puppet reference manual’s data types page for more details.

......................Selectors

    $apache = $operatingsystem ? {
      centos                => 'httpd',
      redhat                => 'httpd',
      /(?i)(ubuntu|debian)/ => 'apache2',
      default               => undef,
    }
...................... classes
Classes are named blocks of Puppet code, which can be created in one place and
invoked elsewhere.

Defining a class makes it available by name, but doesn’t automatically
evaluate the code inside it.
Declaring a class evaluates the code in the class, and applies all of its
resources.

    class ntp {
      case $operatingsystem {
        centos, redhat: {
          $service_name = 'ntpd'
          $conf_file    = 'ntp.conf.el'
        }
        debian, ubuntu: {
          $service_name = 'ntp'
          $conf_file    = 'ntp.conf.debian'
        }
      }

      package { 'ntp':
        ensure => installed,
      }
      file { 'ntp.conf':
        path    => '/etc/ntp.conf',
        ensure  => file,
        require => Package['ntp'],
        source  => "/root/examples/answers/${conf_file}"       ----
      }
      service { 'ntp':
        name      => $service_name,
        ensure    => running,
        enable    => true,
        subscribe => File['ntp.conf'],
      }
    }

    include ntp

.....................Modules.

The Modulepath is defined in: /etc/puppetlabs/puppet/puppet.conf


[main]
    vardir = /var/opt/lib/pe-puppet
    logdir = /var/log/pe-puppet
    rundir = /var/run/pe-puppet
    modulepath =
/etc/puppetlabs/puppet/modules:/opt/puppet/share/puppet/modules
    user = pe-puppet
    group = pe-puppet
    archive_files = true
    archive_file_server = learn.localdomain

[master]
    ... etc.


You can also get the value of the modulepath by running puppet master
--configprint modulepath. The --configprint option lets you get the value of
any Puppet setting; by using the master subcommand, we’re making sure we get
the value the puppet master will use.


...........Module Structure -

A module is a directory. 
The module’s name must be the name of the directory.
It contains a manifests directory, which can contain any number of .pp files.
The manifests directory should always contain an init.pp file. It contains a
single class definition.

This file must contain a single class definition. The class’s name must be the
same as the module’s name.

put it in the site.pp
include ntp    ----

Then:
 puppet agent --test   ----

........... Resource-Like Class Declarations --
class {'ntp':}
can be declared only once

we’ll use the special puppet:/// URL format to tell Puppet where the files
are: could be a local directory under "modules"

    # ...
      file { 'ntp.conf':
        path    => '/etc/ntp.conf',
        ensure  => file,
        require => Package['ntp'],
        source  => "puppet:///modules/ntp/${conf_file}",
      }
    }


...................... The Puppet Module Subcommand

sudo puppet module install puppetlabs-mysql   ----

sudo puppet module list  ----

...................... template 

The template function expects file paths to be in a specific format:

<MODULE NAME>/<FILENAME INSIDE TEMPLATES DIRECTORY>

    file {'/etc/foo.conf':
      ensure  => file,
      require => Package['foo'],
      content => template('foo/foo.conf.erb'),
    }

..........Variables in Templates  ---

Facts, global variables, and local variables from the current scope are
available to a template as Ruby instance variables — instead of Puppet’s $
prefix, they have an @ prefix. (e.g. @fqdn, @memoryfree, @operatingsystem,
etc.)

Variables from other scopes can be accessed with the scope.lookupvar method,
which takes a long variable name without the $ prefix. (For example,
scope.lookupvar('apache::user').)

inbedded ruby code
...........Non-Printing Tags ----
<% tag containing Ruby code %>


........... Printing an Expression ----

    <%= sectionheader %>
      environment = <%= gitrevision[0,5] %>

........... Comments ----
 <%# This comment will be ignored. %>


...........Suppressing Line Breaks and Leading Space ----
    <%- document += thisline -%>

    # /etc/puppetlabs/puppet/modules/ntp/manifests/init.pp

    class ntp {
      case $operatingsystem {
        centos, redhat: {
          $service_name    = 'ntpd'
          $conf_file   = 'ntp.conf.el'
          $default_servers = [ "0.centos.pool.ntp.org",
                               "1.centos.pool.ntp.org",
                               "2.centos.pool.ntp.org", ]
        }
        debian, ubuntu: {
          $service_name    = 'ntp'
          $conf_file   = 'ntp.conf.debian'
          $default_servers = [ "0.debian.pool.ntp.org iburst",
                               "1.debian.pool.ntp.org iburst",
                               "2.debian.pool.ntp.org iburst",
                               "3.debian.pool.ntp.org iburst", ]
        }
      }

      $servers_real = $default_servers

      package { 'ntp':
        ensure => installed,
      }

      service { 'ntp':
        name      => $service_name,
        ensure    => running,
        enable    => true,
        subscribe => File['ntp.conf'],
      }

      file { 'ntp.conf':
        path    => '/etc/ntp.conf',
        ensure  => file,
        require => Package['ntp'],
        content => template("ntp/${conf_file}.erb"),
      }
    }


The template:
    <%# /etc/puppetlabs/puppet/modules/ntp/templates/ntp %>

    # Managed by Class['ntp']
    <% @servers_real.each do |this_server| -%>
    server <%= this_server %>
    <% end -%>

    # ...

Using a non-printing Ruby tag to start a loop. We reference the $servers_real
Puppet variable by the name @servers_real, then call Ruby’s each method on it.
Everything between do |server| -%> and the <% end -%> tag will be repeated for
each item in the $servers_real array, with the value of that array item being
assigned to the temporary this_server variable.
Within the loop, we print the literal word server, followed by the value of
the current array item.
This snippet will produce something like the following:

# Managed by Class['ntp']
server 0.centos.pool.ntp.org
server 1.centos.pool.ntp.org
server 2.centos.pool.ntp.org

.................................

    <% if @is_virtual == "true" -%>
    # Keep ntpd from panicking in the event of a large clock skew
    # when a VM guest is suspended and resumed.
    tinker panic 0

    <% end -%>


    <% if @is_virtual == "false" -%>
    # Undisciplined Local Clock. This is a fake driver intended for backup
    # and when no outside source of synchronized time is available.
    server 127.127.1.0 # local clock
    fudge 127.127.1.0 stratum 10

    <% end -%>


.................................
for puppet test run or  dry-run use : --noop
puppet apply prepack.pp --noop

.................................
  package {'nfs-utils':
    ensure => '1.2.2-7.el6',
    notify => Service ['rpcgssd'],
    require => Exec ['downgrade-nfs-utils'], 
	}
  exec {'downgrade-nfs-utils': 
    command => 'yum -y downgrade nfs-utils-1.2.2-7.el6', 
    path    => ['/sbin', '/bin', '/usr/sbin', '/usr/bin'], 
    unless  => 'rpm -qa | grep nfs-utils-1.2.2-7', 
  }
                      
................................. install rpm from controlled source
http://silviud.blogspot.ca/2012/10/puppet-install-rpms-via-http-sources.html

rpm -ivh http://example.com/package.rpm

class examplerpm ( $src ) {

  package { 'package':
     provider => 'rpm',
     ensure => installed,
     #source => "${examplerpm::rpm}"
     source => "${examplerpm::src}"
 }
}

class { 'examplerpm':
  src => 'https://example.com/package.rpm',
}

puppet apply --debug --no-daemonize test.pp

puppet help module

puppet module uninstall puppetlabs/nginx # not good

puppet module install jfryman/nginx

############################################
To build GW with puppet:
puppet module install jfryman/nginx

save this as nginx.pp
.................................
class { 'nginx': }
#}
nginx::resource::upstream { 'proxy':
     ensure  => present,
     members => [ 'casplda02:443', ],
}
nginx::resource::vhost { "$::ipaddress_eth0":
    ensure => present,
    proxy  => 'https://proxy',
    proxy_set_header => [ 'Customer-Id 88989',
                          'User-Agent SD_TRAFFIC',
                        ]
}
nginx::resource::vhost { "$::ipaddress_eth1":
    ensure => present,
    proxy  => 'https://proxy',
    proxy_set_header => [ 'Customer-Id 88989',
                          'User-Agent SD_TRAFFIC',
                        ]
}
.................................
then, run:
puppet apply nginx.pp


...........gw5.sh
curl -s 192.168.115.41/download/gw5.sh|bash

#For CentOS 5 i386
#!/bin/bash
yum -y -q install ruby ruby-libs ruby-shadow #-y: to always answer 'y'
rpm -ivh
http://yum.puppetlabs.com/el/5/products/i386/puppetlabs-release-5-7.noarch.rpm
# to build puppet repository
yum -y -q install puppet facter # -q to install quietly
puppet module install jfryman/nginx
curl -s -O 192.168.115.41/download/nginx.pp  # -s: silent mode
puppet apply nginx.pp
/sbin/service iptables stop
curl -s -O 192.168.115.41/download/nginx.logrotate #enable logrotate
cp ./nginx.logrotate /etc/logrotate.d/nginx


...........gw6.sh
curl -s 192.168.115.41/download/gw6.sh|bash

#!/bin/bash
yum -y -q install ruby ruby-libs ruby-shadow
yum install curl
rpm -Uvh
http://dl.fedoraproject.org/pub/epel/6/x86_64/epel-release-6-8.noarch.rpm #use
the new repo
yum -y -q install puppet facter
puppet module install jfryman/nginx
curl -s -O 192.168.115.41/download/nginx.pp
puppet apply nginx.pp
/sbin/service iptables stop
curl -s -O 192.168.115.41/download/nginx.logrotate #enable logrotate
cp ./nginx.logrotate /etc/logrotate.d/nginx

...........gw6_ssl.sh
curl -s 192.168.115.41/download/gw6_ssl.sh |bash /dev/stdin '192.168.114.242' '@2a@10@iQhay0Bvrzdciex3oARlIuOSkX4AN8NCTWycsLqlHGHC5\/pVFPOCi' 

#!/bin/bash
#set -x -v
yum -y -q install ruby ruby-libs ruby-shadow
yum install curl
rpm -Uvh
http://dl.fedoraproject.org/pub/epel/6/x86_64/epel-release-6-8.noarch.rpm #use
the new repo
yum -y -q install puppet facter
puppet module install jfryman/nginx
curl -s -O 192.168.115.41/download/nginx_ssl.pp_template
#download and store certificate
curl -s -O 192.168.115.41/download/server.key
curl -s -O 192.168.115.41/download/server.crt
mkdir /root/sd
mv ./server.* /root/sd
#updating puppet script
IP=$1
CID=$2
pp='nginx_ssl.pp'
templ='nginx_ssl.pp_template'
sed "s/$::ipaddress_eth1/$IP/" $templ|sed "s/8888/$CID/" >$pp
puppet apply nginx_ssl.pp
#stoping firewall
/sbin/service iptables stop
#enable logrotate
curl -s -O 192.168.115.41/download/nginx.logrotate
cp ./nginx.logrotate /etc/logrotate.d/nginx
#enable heartbeat
curl -s -O 192.168.115.41/download/heartbeat_ssl.sh
chmod +x ./heartbeat_ssl.sh
echo '10 * * * * root ~root/heartbeat_ssl.sh' >> /etc/crontab
#prepare version control
echo '0'>   ~/gw.version
touch ~/ready_for_upgrade

......................nginx.logrotate
/var/log/nginx/*log {
    missingok
    notifempty
    sharedscripts
    nomail
    rotate 3
    size=5M
    daily
    postrotate
        /usr/local/nginx/sbin/nginx -s reload
    endscript
}

#################################  -
vagrant -
################################# -

To prepare current directory to a vagrant directory, create Vagrantfile config file, also add the first CentOS box

$ vagrant init precise32 http://files.vagrantup.com/precise32.box
or 
$ vagrant init centos65-x86_64-20131205 https://github.com/2creatives/vagrant-centos/releases/download/v6.5.1/centos65-x86_64-20131205.box ----

To fire it up
$ vagrant up ----

To add more box into the config file.
vagrant box add centos65-x86_64-20131205 https://github.com/2creatives/vagrant-centos/releases/download/v6.5.1/centos65-x86_64-20131205.box ----

vagrant box remove precise64 virtualbox  ----

then login as:
127.0.0.1:2222  ----
root:vagrant


If the guest machine is already running from a previous step, run 
vagrant reload --provision  ----
which will quickly restart your virtual machine, skipping the initial import step. 

vagrant suspend  ----
vagrant resume  ----
will save the current running state of the machine and stop it.

vagrant destroy # can only clean a particular VM----
vagrant destroy testvm11----
vagrant halt ----

vagrant package --output test.box

................................. multi-VM -
In a single VM environment, vagrant up starts that VM. In a multi-VM environment vagrant up starts every VM. If a name is specified to the command such as "vagrant up web" then it will start only that specific VM.

This pattern follows for every other command as well, although some don’t implement the “every VM” functionality when it doesn’t make sense, such as "vagrant ssh", which requires that a VM name be specified if it’s in a multi-VM environment.

................................. package to install on Vagrant CentOS 6.5
yum -y install vim
yum -y install compat-glibc.x86_64
yum -y install libidn.i686
yum -y install telnet
yum -y install libgcc.i686

yum install tomcat6 tomcat6-webapps tomcat6-admin-webapps
service tomcat6 start

...........Vagrantfile -
To use DHCP: ---
Vagrant.configure("2") do |config|
  config.vm.network "public_network"
end

To config bootstrap: ---
Vagrant.configure("2") do |config|
  config.vm.box = "precise32"
  config.vm.provision :shell, :path => "bootstrap.sh"
end
Using Multi-VM             ---
Vagrant::Config.run do |config|
  config.vm.define :web do |web_config|
    web_config.vm.box = "web"
    web_config.vm.forward_port 80, 8080
  end
  config.vm.define :db do |db_config|
    db_config.vm.box = "db"
    db_config.vm.forward_port 3306, 3306
  end
  config.vm.define :test do |test_config|
    test_config.vm.box = "test"
    test_config.vm.network "public_network"
  end
end

......................sample file: -
In d:/vagrant
# -*- mode: ruby -*-
# vi: set ft=ruby :

# Vagrantfile API/syntax version. Don't touch unless you know what you're
# doing!
VAGRANTFILE_API_VERSION = "2"

Vagrant.configure(VAGRANTFILE_API_VERSION) do |config|
  # All Vagrant configuration is done here. The most common configuration
  # options are documented and commented below. For a complete reference,
  # please see the online documentation at vagrantup.com.

  # Every Vagrant virtual environment requires a box to build off of.
    #config.vm.box = "centos65-x86_64-20131205"
    config.vm.box = "base"
    # The url from where the 'config.vm.box' box will be fetched if it
    # doesn't already exist on the user's system.
    #config.vm.box_url =
"https://github.com/2creatives/vagrant-centos/releases/download/v6.5.1/centos65-x86_64-20131205.box"

  config.vm.define :test do |test_config|
    test_config.vm.box = "test"
    test_config.vm.network "private_network",  ip: "192.168.200.100",
    virtualbox__intnet: "mynetwork"
    test_config.vm.network "forwarded_port", guest: 8080, host: 8080 
    test_config.vm.network "forwarded_port", guest: 22, host: 2020 
    test_config.vm.provision :shell, :path => "bootstrap.sh"
  end
  config.vm.define :testvm1 do |testvm1_config|
    testvm1_config.vm.box = "testvm1"
    #testvm1_config.vm.network "private_network",  ip: "192.168.200.101",
    #virtualbox__intnet: "mynetwork"
    #testvm1_config.vm.network "forwarded_port", guest: 8080, host: 8081 
    #testvm1_config.vm.network "forwarded_port", guest: 22, host: 2021 
    #testvm1_config.vm.provision :shell, :path => "bootstrap1.sh"
    #testvm1_config.vm.synced_folder "d:/VMmount", "/VMmount"
  end
  config.vm.define :testvm2 do |testvm2_config|
    testvm2_config.vm.box = "testvm2"
    #testvm2_config.vm.network "private_network",  ip: "192.168.200.102",
    #virtualbox__intnet: "mynetwork"
    testvm2_config.vm.network "forwarded_port", guest: 22, host: 2022 , id:
"ssh", auto_correct: true
    #testvm2_config.vm.provision :shell, :path => "bootstrap2.sh"
    #testvm2_config.vm.synced_folder "d:/VMmount", "/VMmount"
  end
  config.vm.define :testvm3 do |testvm3_config|
    testvm3_config.vm.box = "testvm3"
    #testvm3_config.vm.network "private_network",  ip: "192.168.200.103",
    #virtualbox__intnet: "mynetwork"
    testvm3_config.vm.network "forwarded_port", guest: 22, host: 2023 
    #testvm3_config.vm.provision :shell, :path => "bootstrap3.sh"
    #testvm3_config.vm.synced_folder "d:/VMmount", "/VMmount"
  end
    config.vm.define :testvm11 do |testvm11_config|
    testvm11_config.vm.box = "testvm11"
    testvm11_config.vm.network "private_network",  ip: "192.168.200.101",
    virtualbox__intnet: "mynetwork"
    testvm11_config.vm.network "forwarded_port", guest: 8080, host: 8081 
    testvm11_config.vm.network "forwarded_port", guest: 22, host: 2021 
    testvm11_config.vm.provision :shell, :path => "bootstrap1.sh"
    testvm11_config.vm.synced_folder  "d:/VMmount" , "/VMmount"
  end
#config.vm.provider "virtualbox" do |v|
#  v.memory = 1024
#end
end
.................................
# -*- mode: ruby -*-
# vi: set ft=ruby :

# Vagrantfile API/syntax version. Don't touch unless you know what you're
# doing!
VAGRANTFILE_API_VERSION = "2"

Vagrant.configure(VAGRANTFILE_API_VERSION) do |config|
  # All Vagrant configuration is done here. The most common configuration
  # options are documented and commented below. For a complete reference,
  # please see the online documentation at vagrantup.com.

  # Every Vagrant virtual environment requires a box to build off of.
    config.vm.box = "base"
    # The url from where the 'config.vm.box' box will be fetched if it
    # doesn't already exist on the user's system.

  config.vm.define :testvm11 do |testvm11_config|
    testvm11_config.vm.box = "testvm11"
    testvm11_config.vm.network "private_network",  ip: "192.168.200.101",
    virtualbox__intnet: "mynetwork"
    testvm11_config.vm.network "forwarded_port", guest: 8080, host: 8081 
    testvm11_config.vm.network "forwarded_port", guest: 22, host: 2021 
    testvm11_config.vm.provision :shell, :path => "bootstrap1.sh"
    testvm11_config.vm.synced_folder  "d:/VMmount" , "/VMmount"
  end
  config.vm.define :testvm12 do |testvm12_config|
    testvm12_config.vm.box = "testvm12"
    testvm12_config.vm.network "private_network",  ip: "192.168.200.102",
    virtualbox__intnet: "mynetwork"
    testvm12_config.vm.network "forwarded_port", guest: 22, host: 2022 , id:
"ssh", auto_correct: true
    testvm12_config.vm.provision :shell, :path => "bootstrap2.sh"
    testvm12_config.vm.synced_folder  "d:/VMmount" , "/VMmount"
  end
  config.vm.define :testvm13 do |testvm13_config|
    testvm13_config.vm.box = "testvm13"
    testvm13_config.vm.network "private_network",  ip: "192.168.200.103",
    virtualbox__intnet: "mynetwork"
    testvm13_config.vm.network "forwarded_port", guest: 22, host: 2023 
    testvm13_config.vm.provision :shell, :path => "bootstrap3.sh"
    testvm13_config.vm.synced_folder  "d:/VMmount" , "/VMmount"
  end
  #config.vm.define :testvm11 do |testvm11_config|
  #  testvm11_config.vm.box = "testvm11"
  #  testvm11_config.vm.network "private_network",  ip: "192.168.200.104",
  #  virtualbox__intnet: "mynetwork"
  #  testvm11_config.vm.network "forwarded_port", guest: 22, host: 2024 
  #  testvm11_config.vm.provision :shell, :path => "bootstrap1.sh"
  #  testvm11_config.vm.synced_folder "d:\VMmount", "/VMmount"
  #end
config.vm.provider "virtualbox" do |v|
  v.memory = 1024
end
end
  
#################################
The following error may show up when export testvm1 to a package and add another VM to the same host. When starting the new VM, the eth1 can not be started. Solution see below.
.................................---
The following SSH command responded with a non-zero exit status.
Vagrant assumes that this means the command failed!

ARPCHECK=no /sbin/ifup eth1 2> /dev/null

Stdout from the command:

Device eth1 does not seem to be present, delaying initialization.


Stderr from the command:
.................................---
remove 
rm -f /etc/udev/rules.d/70-persistent-net.rules    --
or better:
cat /dev/null > /etc/udev/rules.d/70-persistent-net.rules    --
chmod 444 /etc/udev/rules.d/70-persistent-net.rules    --
before packing 
................................. ---
